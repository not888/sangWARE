--[[@@@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8
@888X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8
@@8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 
@XS8 8 @S8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
@@SXSX8%8@8SXXS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888.
@@8S8%X8X8%@XX@8X8X8 8 8S8%8.XS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.X
@@XSX8 S8 @8 8 X@88@8 X 8 888S88@.XS8:8S@888X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8%
@@X8:S8SS8SX888 8 8%X8S8 8%8 8S888S8S8 88SX8 888 8%888 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX8SX
@@X@8%X8XX8S88 8 8X8 XX88 8 X 8S888@8 8 @8SSS 8 8 S88.8S8SS@8 8X8SX88 8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 888 
@@8SS8 88SX8%8S 8S888S8 SS8888X8S8@8 X88 @8 8 X888 8%S@8X88 88@8 8 888X8 8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 8 8.@
@@XXXS8SS8 @8 8 888 SXX8S888:8 S8X@@8S8@8%88.8 S8 888X8@8 @8 8S@88@ @8 S88888%8t8 888 S 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 888 8 
@@X8SX888 8 8 SS8XX88@8 888 X 8S@8X8 8S8 8 8X 8 88.8 8 8:8 8 X8 8X@8S88 @ 8 SS88 8 8:8%888 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 8 8 8X8
@@XX8 8 X8 88@ 8X8S@SSS8XX 8 8 8%X8SSX8SXX8 8 88S8X 8 8 SX888 SXX8SS8S@8.8 8 8 X8 888 8 8.S 8 8 888 8S@ 8 888 8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 888:8X8 
@@8SSS88 8 XX 8:8 8 8%8.8 8 888 8 X8S@@8S8X88@ S@88@X888S8S@ 8S888X8 8 8SSX 888 X XXS888 8 88@ 8 8S888 888 8SS8@ 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 8 @X8 8
@@XXX@8X8 8 8 88X8S@8 8888 88@ S @%X8S8 8X888 8%8 8888S@8S8 8 888 8 X888888S88 8 8 8 88 X88 8 888 8 8 8 8 8 8S8.S 8%8:8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8X8@8 8 
@@X8 88 XSS888S88X8%X888 X8 8.8S888S@8SSX8S888@8 888 X8X88 888X@88 8S8 8 X88@8%S888 8S888X 8 888S888 888 S 888.8S8 888 888@8:X 8@8 888S88X8SSXSS88S888 8@8 8%8@8S@S888 %88X8:X 8@8 888S88X8SS8 888 S 8;8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@888888X8 8 X 8
@@8 8SX8S8 8SXXS8 S8%S888 88 888@8 8 X8S8 8X8X8@8S888 X8SX@@8 8S8SS 8:XX8%X8SX8 88 S 8 S88@X8.8 8 8 888 8 888 X8888 8 8X8S8 8S8 8 8X888S8 S888 @t.t;8;8XXSXX8S8%8S8X8t%8t8:X8@@@S88X@88S8 S8 S8.8@8S8SS@S88X@ 8 888 88888@8@8SXS88@8 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@@SXSX 8 8 
@XS8 8S88@8:8%8 8S8 88 XX8S88X888@%@8 XSSX 8 8X8 8S888 S8X8 888X 8 8 8 8 8SS8SS8SX888@8X%8X88SX888.8 8 888 8 8X8@8 8 8S8 8 8 88XS88@S88t88;888t8XX%XS8X8@8@888@8%8S@XX%S88S888888%8 88XX 8.S8 88@X 8t8 8 8 8 X 8 8 8 XS@88XSXXX8:@8@8 8:8 S888S8 8 8XX8 X8SX8X8S8 S8%8 8 8 8XX8 X8SX8X8S8 S8%8 8 8 8 88888X8
@@SS S8 8 8@88%8 X88S8@8XX8 8888S8S8 8 8S8S%XS8 X 8X888S@8 8S8X8 S8 888 8S8 S8SX8 X88@88 8 S8888XXSS888 8 X@8 8 8 8 8XX%8 888 XXS8 8888t8X888888@8888@8888@88@8888888888X88@888tS8@%8888@ 8 X8 X8S8 XS8:8 X88 888 X 8 8@8 8 8 888 8%X8 8 8%8 S@S8X8 8XX8S@8SX@X@@8 S8X8 888 8XX8S@8SX@X@@8 S8X8 888 8 8888@8
@@8888SS @X8%@88@S8@8SXX8 8 8 8 8 8 888:888S8 S8 8 8X8@8 8X 8 @@8 X8S8 88888 8S8 8%S88888 8 X8SX88S8SX88 8X8SXX8X888 8 8 888 8 8@%%888888X@88S@888SS88@X@88888888@S88S888@88X8X8X8@88888@X88XX8%X8;8S8S8 88X 8 8 8 88@ 8 888XSS8.8 8 X%S SS88S8%8S88 8SS8 XSX8 8 S8 88X@88 8 8 S@S8 8 8S8 8%8SX8S8 888 SS8X8
@@S%S8S8 S8 8 8S@8 8X8XSS88@ 8 8 888 8S8 8 X 8.88 S%8X@XXXX8 8X8@8 S8SSX8X8@8 888:8%X8X8:8%8 8 8 8X888X 8 8;8 8S8.XXS88 8 8 8@8%@%@88@SSSS8XSS8SS88X888S@8X8S8X@SS8XS8888@8SS88888888@8@8@888.X@XX8 88888S88@X88XS888@8 8X8@88 SSSS88 8 8%8 X8 888 SX8S8 8 8 8SS8 %8 8X8XX8X8:8 8 SS88X8 S 8 8 X888@X888X88S
@@X8XXXX@8X8@ S8 SX@8 8%8 8.888%S88 888 8;8%88@ S8S8 XXS8 888 8X@X8S8X8SX8X8 8 8;8 8 8 8@ 888 888S8 S8 888 XS88XXX8 8 S%S 8888@8888X88888XS88888S888S88@888S8X8S@S8S88X@SS8888888888888X8X88S8888@X S8888SS8X8:88@8@888XX8 8 8 888S8 8 888.8 888XS8S8;8 S 888 8S888X8@8 8X8888XS88S8%8SS8%8t8.8 8@8SS 888@8@
@@XX8@8SS8S8S8.S8 @ XXSS8 SS8SX8%8%S 8 X 888 8 8.X8888 8 8 8;8 8X8%@SS8 8 8 888 888 88XS8S 8 8 8 S 8S@8 8 8 88@8XS88.8 8S ;888XS@@S8SXX8888S88@X8S@SS8888SS88888X88888SS8888888X88S88@SSS88@@888@888 8 @S8 XSS888@8 8:8 8 8 888 88888 888 8 @%88@@ 888;8%8.8 88@ S8%88X888 @88S8XS8.8 8 SS88@8 8 XS8S8SX8@8 
@@8XX@%8SS8 S 8 S8;8 8S88@%888XX8 8S8 8 8 8 8 888@88888.X8888X8S@@8S8 SS 888X8 8%8 8 8 X 8 8 S888 8 8%X8.888S8 XS8.88 88@t8888SS888XS8X888S:8XX8X8S@X8S888S88XXS8888@X88888888X@@S@8X888888S88@S8888888SSS8%8 X8 8S@XXX8 8 8 8 8S8X8SS88 888:8 888@@8 X%88X 8 8 8 8 888X8 8 8:8 8S@8 88@S8%8SS888 888 8 8 @@
@@XXSSXX8S@8S88X S8 888 8 888 8X@8 888 888 888 8 8 8@@88S8X8@8%@8SSSX8 88@SXX 888 88@ 8 8 88X 88 888 8 888X X 8%8S8 888@@888@S888SXS8X888S8@S8888S8X88@S8S888SS88X@S888888X88@SS88888888X8X8SSSX@88S%88 8S8888SX8 8 8S8S@S S8 888 8 8X8 X 8 8 8 @8@8%X88888S%8 8 88XS8 @ 8 8 8 88@ @8 8 8S@SXS@8 8 8 8@8 8 8
@@XXX8X8 8SX888 8 X8 8 88XXX 8 8S@8 8 888 8 8 8 888 8 X 8;888%8SS8 8 S 8XS8S8SS8%8 8 S 888 8 8 88@8 888 8888S8 8X8 88888@@@88888@S8S888888S8SX888888888888SX8888@8SS8SXX8888XS888@SX8888X8888S@S8XSXX88%XX8.SS8 X8 8 X 8X8X8SS88 8 888 8 8 888 8 8 8@S%S8SX8 88 888 8:8S8 8S8X8 8 8 X8 8 8 8 8SS%88X8 8.X 8 
@@8X8 8;8 8S8 88888888888 8S8 8 8 X8;X@@SX%X 888;8 8 8 8 8X888S8 XS88%8 8 X8 8 8 888X88X8 8 8 8X8X88 8 @ X@888S8 S8t8888SSX88888S8888888XS88X8X;8@88@@@@XXXX8S@XX@8888888tt@88@@8888888X8SS888S88888X@8888@8%888%@8 8 8 8 8S8 8.X 8S888888888 8 888S8S8SX8XX8S8SX8SX 8 888:8S8SS 8 8 XSX8 888 8S8888%8;8 888
@@XSSS88 8 888@8 X8X8X8SX8 888 X88 S8S8 8%8 888 8 8t8:8;X 8@8@888S8 X88888X@8 8 88 888SX8XSSX8t888S8888@888 888 8S8X88@SS888S88S88@@S@88888 8@S@XXXXX@X@SXXSS8 8S8XS8SX@@XXS@88X8XX8@XSS8:888X8S8888888888tS8888888888 888 S88:8 888S8X8S8S8 888 8 8:S 8S@8SX8X8 8 8 888X%8 8 8S8 88@S8 XS8 X8X8 SX8 S8 8 8 
@@X8888X8X8S88S@8%X8 8 8 XS8SX8S8 8 XS8@@888 8 8 888XX 8%8 8X8S888@8S8 8XX8 X888 8 8X88 8 8 88@X8@8S8X8S8888@@ 8 XS8@88SX8@X8@S8888SS8S888XX8SXXXXXX8 8 8 @X8 8 XS8 8SXXXXX8SXSX88X8SS88888SSS88@XX@X8S888@8S8 8.88SX 8 8 8S8%SX8 8 8 8 8 8 8 8 8 S 8S8;8S@@XS888X88@SX@X8 888.X%8 8 8S888X8 88S8 8 8%SS888 
@@XSX8@X8%S8X@8XX8%@8 8;8 8 8 S88888 8X8S88.@88 888X8S88@ S 8 8X8@@@888 8XX8 88 888 8 8X@8 8 8 8X8@88S@X@8SXX8 88S8888S8@X8@88XS88888.@X88S8 @X8X8 8 8 8 8%8 X 8 8 8 8 8 8 X8 8S@SS@8X88S88S888XSS8S8X8S8S888S8 8S@88X8 888%S8S8SX 8 888 8 888S88@ 888 8@8 88X8X88@8 8 8 888SS88XSX8 S888X8 888 SSSS888 8SX8
@@8@8 8 888S8S@8SS8 XS88X888.8 @ 8X@8 @%8 88S888XX 8 8 8:8S8 XSXXX8@8X@8 8SX8SX8X@88 8S8 888SS8 8X8X@XSXX8 8S88t@8X8SSSX8SS88@8@S88X8@@XXSSS8SXXXS8 888 8 8 8 888 8tXS8 88XS88 8 8SX%X:@X8X888888888S8888888@8%X 8 X8%8888 8 S8S8 888 8 888 @ X@8 8 8 8 8.8 XSS8 8S%8XX8 S8 8 X8888S8%8 X8 X 8 8 88X888888 X
@@XSX8 8 S8 X8%88@S8 8 8 @ S8 88@ 8XX8 8 8SX8 8X88 XSSS88 88@X8 8 8 8X8 8 8 S8%X88X 8 8 8;8 8S888X 8 8S8 8SS8 St88888;88S888888S8XSX@XXXXXXS8 8S8S88@8 8%888S8 8S8 8888X88:8S@8 8 8 8%X8@8X8888XS88S88888S@88888 S8 888S8 S 8 8@ 8 8 8 8 8 X 8S8 8X8 888 8 8 8 8 X8X8S888 X8:8 X8 8 88:8S@8 8t@ 888 888X88XX
@@X8 8 88S88SX8 X8SX8S8 888 XS8 8 8X888 88@S88S8 8S8888X 8 8 888 8 8 X%888 8 888 8S8 888t88XX8X8 8 SXSSS8:8 S8S8@@X@@@88S88X@8888 XXX8 8%8 888 X 8X8X88@8S8 S%8 888 @8 8.8X 8%88888SS8%8 88S88S8S@S88888XS8X888X8 8 SS8S88%888S88S888:8X8%88%%8 8S88888 888 888 @SSXSS8S88 8@X8S@8 8%8X@8 8 88%X 8 8.88@SXSX
@@8 88@ XXSX8  8 8X8 S%8 8 8 88@ 8 8X888XX 8 @XS888 SX888X8 8X8888888%8 8 88@ @8XSS 88X%@%8X8.8@S 8%88X8 X@8 @@SSSS8@8@@8XS8X8@S8X8 8 8 888S8 8 8 888X8 @XS888@88@ 8S8888 8 S8S8S888 SSX8 88@S88S8S8X8XS8S8S8X@.S88@ 8;8 S8S8 8 8 8S88X8 8 88%S88@X8S8@888 8 8 8 8 8S8 8 X8 8S88XS8 8%8 8 S8 S88SS8S8 8 8 8 
@XS8 8 8 888@8 8 X8t8 8;S 88@S8 888 8S8@88 X8 8 8SX8X8S8%888.8X8S8SX 8 8 8 8.8XX8 8 X8 8S8 88@@888S8 8%S8S8:::SS8X8888888t8@@S88SSS8 8t8 8.X8 S888X@S8 8S8S%8 888 8 8SS8 8 8 S8 8S888 8 8S@S8X8S888@X888888888X8 8%88;8 8S8 S8 8 88@ XSS88@ X8SX8 8@8S8X888 S 888 888 S 888SX8 @8XS88@ 88@ 8S8.88 S888 8 888
@@SSX8888X8@8 88X 8@S888S8S8 8X8S8 8 88XSS88 8 888XS8X8888%88@8 8 8S888t8X8 8%8 SX88 SSX888X8 8 S8 SSS8 S8 Xt888X88888@8S8XS88;%XX88XSS8888XS@8 @S8 8 8%8%8 SS 8 888 8SX888:8SS8 8XX 8 8 8S8t8S8S:S@@XXXStSSXX;88@8 SSS888 8 XSS 8 X888@8SX8 888SX8%SXX@@@88 8 8 8 8 8 8 8 8 S8 8 8 8 8 8 8888XS88X88@8 SX8.
@@88888S8XSX88 8 8S8 SXS8;8 88XXXX88@X@8 888SS 88@8 X8@88S888@S8 8 8 8;88@S8%8%8%8 8S8888%8 88@8SS8S88@8 8%888@S88888X88SS8@S88XX8.@88 8 8S8 888XSX8X8S8S8 8 8 X888 S 8%88 8S8 X8 8S888 S 8X8@S8SXS8%@SX@SXS8SXX8SS8 8 88 88@S8 88@X@XX@@8 88.888 S8 8%X8X8 888 S%888 888:XX88 888 888 888 8 X88%XXSXX@8S8S@
@@S%S888%XX8S@8 8 X888X8 888SX8%8S88 8S8888 8 888XX8 88S@X 8.8%S S88@;8 8 888 8@8;888 8SS8X8S8 @8 S8S8 88 888@888X8SSX8888888SX8 @8 88@:8 888S888X8S8 8@8 S 888S8 XX8SS8SX8S8X8S88t8 8 8 8 8X8SX8 8 8%@XSXXXS8 8 8  88@S@8 8.S 88@ 8S8 8 X8 88X@ @S88%8 8 8888 8 8%8 8 8 8S8 8 8S8 X8 S @ 8 888SX8XXX8S@8 8 
@@X888S88SSS8S@8 8 S888%8S8%8 %8S@SS8 8S8 8 SS88S8X@8 X8%8%8@ 8 8 8%SS8 8%%8 8SX88X8 8X8%8XS8S8 8S8:XX8S88 88XX88S88S888S8SX8;SS8SX88888X8X8 8S8 8@8 8S8:8S8 8 @ 8 S 8 88XX8S888 8X 8 SX88@88SXSS8 8 8 8 XX8 8SX8X8 X8 8%88@8S8 8:XS88X@88 @ X8S8 8 8X8 888S%8S 888 888 S 8:SS88@ 8 S8S8t888 8S8 88S8 8 S8 8
@@XSSX8 88SSS8 88X888@S8@8 8t8 SX8 888 8 8 8 8%8X88S@8S8@ 8X@S@8.888%888 8 S8X8 8X8X8X8@8X8SX8XS 8;8 8 8 88S8SX@S8XS8@888S8S88SXXX8%X8X8SS8S@@SS8S@X8 8;8 888 8 8 8 88@ @8SSS8SX8X8S 8S8 8@8 8%8 8 S8 8 8 8 888 @ S888 %8X8SX8;888S8%8 8:8 S8%X8t8 8S8 88@X8 X8 8S88%8 8 888S888@8:8% 888%8 S 8 8 SX%8 8 X8 
@@8XXSX8%X8XSX8X8 X 88X88X@88@888S8S8SS 88888 8S8SX8SS8S8 S888X 8 8 X 8 88@S8SS8 8%8 8X8S@S8@8X8 S8 8 888S888888X88888S@S888S8XXX8:8 SSS@8X8S88%S88@@8.@XS8SS S88888@8 8%X8 8 8 S888S@8 8 X%8 8 88@ X8 S 888 8 88@ X8 8 88@8S88XX 8@888 8 8 S8 8@@8:888%8 @ 8 XSX8 8@88@888 888888X@8 XX%8 8 8 888SX888 8 X8
@@X8 8 88@X8@8 X 8 @ XXSX88@8 8.8 S8X8 8 8 8 888 8S@8SS8X8XXSSX88@ 8 8 8 8 8 8 S8 8 888X8S8X8 XX8 S8 88S 8@8SX88XS8888S888X888@8 8 X8 8 S8 S8 888 888S8 8%S888%88888XSX8S8 888 8S8 X8X88X8 888 88X 8 X8 88@ 8 8 8 8 S8S8%8S@8 88S8 8X8888888 S8S8 8X%8 8 8 8 8 @ S8%8X8S%X88.8 8 8@888 8 S8888@ 8 8 X8 S 8 X
@8 8 S8 88%SSS8 888 8S8 8 8 88 888S8 SS888888 8 X 8S@8X8 S8%8 8 XX8.8 XX88@X X8 X8 888S8 8X888@X88 X8S8S88888S@8888X8S888888@8@8XS8 S X8 8X8 8 888@8 @8 S8 8X8X888SX8 8 8;XS8 888 8 %8S8S88 8 8 8 X 8 S8X8 8888@ 88@ S8 8 8 88 8 8SS8S8888S@8 SX@8S8 S8 8 888 88@ SSS8S8S8 8X 8 8%@S 88S8 88@8 8 88XS888888S
@@8 888S@%XX8 %888888@@8 8 8S88XXS8 8 8 8@88X@ 8 8 8S@8%8 8 SS88%8S8 8 8 888SXX8S88S888 X 8X888S8 8S88S8 8X8SS88S@S88888SS888@@@8 X888S88.888X8 88SS8SS888 @88S8888 X888%8 8 8 8 X88 X8 8 8@@88888%888S8 8 X8 8 8 8 8 X8 S 8SX@X8:8 SXXX%@8S88S8 SS88 XSS 88S8 8 88@ 8@8888%8%88.8S88X8S8888 88X8 8.8 888X8@
@XX8 @ 8 8 888 8888X8@8%S8888 X8 8 88X88 8.@88 S888@8SXXS88@S8 X8S8;X8888X@ 8%8 8 8X8 X88S 8X888SS 8.88S8@888888S8SSX888@X8S8S8XS8 88@S8 8S8@8X8SX8XX88X8%8 S8%88SX8S8 SXS88888 8 888SS8 8X8S8X8S88@8 8 88@ SX8 %8 88@ X8 8 8%8 8XX8 8S8S8 8 XXX8 8 X8 88SS8 SS8888 8S8 8888 8 8@8888 S8S88 8S8%888888 88XSX
@@8;888 888 8 8 @8 8 8;8 8S888 X8X8;8X8 8 8SXS8 @ @ S8%8 8SS8 8 @X88 888S8 8.888 8 8 8 8;8 X8X8 8 888 S8S8S8888888S88888888X8888XS8S8 8SSX8%8S8 8 @8 888 X 8 X8%X8S@888S8 88%8 S 8%8.8SXX8888 8 8S8%88@88888 88@ 88 8 8 SS88SSS8S8 8 S8 88888%8 SS 8 S8 8 88@ 8 8%8X%888X8 XS88S8S8 @8 SXS88% XX8888X88 X88@
@@@X%8 8 8 8 888SS8 8 888 8X@ 8S8 @8 8 888888 88X8 8 8%88;8 X88@X8 88X8SX%8.888 888 888 8%8 888SX88X 8 S8SS88888@S888X8SS88888888SX%8 S8S8.XS8 X 8 8S8 XS88 8 S8 8X8S@X8S8 XS8 8 88 X@8X8X8S8@ 8 8 8S8 X8X8SXS8.8 S888 8S8 8S88XSX8 8S88@8X@ 8:8 8 X8 X888 8 88@.8 8%SS8@S8S8S 8 @@8 X8 8X8%8S8 %X 8 8 8 XX@
@8 8 S8 888S888 8 8% @X888@S@8:888 XSS8S8X8X88:8%88@SS8%8X@8S88 8X8 888@SXX8X8 8 8 8t8 888 8 X8X8 SXS88 88@8XXXSS.8@SSS8@888888@8S8 888S888S8X888S8:S 8 8 8@88SS888 8X8 @X8S888 8 S8X8 8 @88S88SXS88888 SXX8SX 8 8%8 S888 888 8S@88888S8888XX 8 888 8X8 8 8 S%8;8 88X88 8 8 S8 S8X8@8 SS 8@8S888S8%S8 888S8 
@@8 8 X8 8:8 8 8 88@%S8S8S88SX8%8 8S88@ XX@XS@8 8S8 8 88@8SX8 X8SS%8SX@8S8SX8S888 S 8 8t8 8%8 XSS8 8 8S8 88%888S888SS88888X88888888t X8S8SX8X8 888S8 8 88X88 88%8SX8 8 8XS8888 88@ S88S888X%8 88888%8SX8 8SS8 888 S88 XXS8 8 8 8:88SX 8S8 X8%888 8 888 8t8;8%8SSS8 8 SS8 88@:%@8S8X888 8%X8 8S@ 8:8 8 @8 8 8
@XS@ 8 X8;8 8;888S8 8%@88@%X8 8 88:888 8S8 8X8 8 888:8SX@S8S@8%X88S88@@ 8 8SSS8SX888X%88 888%8 8 8888 8X8SXS8888X8SSS8@SSS8888@@88S88XXXS8SS8X8 X8 %88888 XS8%SX%8S@8 S 8S8X888 8 8 S8S8 8 8 8 X8XX8 8SX8 8 S%88X8%8 8 8 88:888S8 8 8 S8 8 8 8XX8 X88 888 888:8 888 8 88@X@@8SS8 X8X888:8 888@8 X8 8 8 SS8  
@@8SX 8 S888 8 8.XX S8 S@S8 8%X8S88S888.8X8.@XS88 8 8S8%8 88%S8 888XSX@8 8SX8%%888X8888X8@XS@X8:8 8 88X8 8S8SX8XS88888S8S@8X8SS8S88@@S88S@88@@@8 S888 8XX8X8SXXX8%8S@8 8:8 8X8S@8 S8 8 8888 8S8 8SX 8 8 SS88S8 8SS8S@8 %8 88X8 8 88@.8 @8 8 8:8 888 X8@8 8%8 X8888S%S8.8%8S8 8SS@SS8X8 X88XX8S@8 X8 888S88@S
@@XX8888 X@S888:8S888X8SSSS888S88SS8S8@8S@88S8 8S8@8X8@8X8 8@ 888SSS8 8S8 8 888X@SSSS8@8X8888S8X 8t8SSXSX 8X8888X88@@888888SS8S8@8888S888@88@8888 %X 8 8SX8X8@S888 8 S888 8 X 8S88888X8S8S88.8X8 8S888 8 8 XX88X8SS8 X8 88 X8 8 8 8 8 8 @8 888 8:@8X8S@ 8 8 8 8X@S8888%X8 8;X888 8 8 @8 8S8 X8SS8%X8S8 @88 8
@@X8.8 S8 8 8XX8.8:88SX8 888 X@8 8  8X8XS8 SX 8 8S888@8S8S8S8SS8 8 8 888 88X X8SXX8888SS8 S@8888 S8 8 8S8XX8SS8%8S8%8X888@S8@8@SSX8S8S@S@888888888 .8@XX8SS8S8 8 S S8 X8 X 8 8 8 8@@88S8%8 88S8S888 8:XS8:8S8%8 88XS8888X@8 X88888XSS8S8 X X8 88XS8 888S8888X8 8 8.SS8X8;88888SX@8%S8S8888 888X8 8 8%S88X 8 
@@SSSX8 S888 8S8@XXS8 8 888 8 88%S8 X8%8  @S8S888X8 X@XXX8@888S88.888 8SS @.8XSXX8 8888%X8S8 8 8 8:S888@@8 @X8S888X8X88@S8S88S888888@SSS8XS@@88@%SXS8888S888.S@ 8 888X8 8 888 8 8%8 888X@@8S8@ 8S8 8 8 8 88888 8 88 X8S8@8 8 888888X8%S88S8 SX8XX8 8 %8X8888@888@X88X888X 8S8@88 888@X88S 8 8 8 8;8:8 @8XS 8
@@888XX8 X8 8;8%8 8SS8X8%8 888 8X88XSSSS8SS8 8 X8 S88SS@8S8@8 8 X8S888@8 8 8S8 8 88 8SX8SS8S@XS88;8 @ 88888 8 8 888S8@88888888888X88X8@:8888888X88888888XS@8S888;t88 88888 8;8@8;8 8SX@888 888888888888 8S8 8X888S@8 88@8 S 888 8 S@88S8 8 8 88@S@88@ XS 8 8 8.8%8 8S888S8 @S8 88 88S8;@8%S%88SS88 X88 @8%8 
@@S 88 X88 888 8 8 8 @ S8 8X8@8 8;XX88X888 8S @ S8XXSX8 888X88@8S%8X8X8 88@XX 8 8S88%@SS8SX8S8 8SXS8:8S@XX88 8 8S@X888@X888@XS888888SS8@X@XX88XSSSS8@X888X88@8888X88@tX8%@8S8SX8X%88888888888S888888@8888@888888X8X88 8SS8S8t8SSX8X8 X@88 S 8 8 8 88 8 8 88@8 8@8SXXXSSSS%8 8 8 88%SSS8 8 8 8S8%8%8X8 8%X88S
@@@8 88XS8 SXS888 888 8 S8:X%8 888 8 8 S8S8:8XS8:S8SX8S8S8 8S8SX8XSXS8%S88 8X888 8 8@S8 8X8 @@8;8 8 X8@ 8@88XX8 8XX8S@S:@@88S@88@88X88XS88888@8888S8888@S88S@8X@X@88X@X@:.8@@8 88X8888888888X8888888888%8888%@8888888888@SX88S8S@@8 8%8S@8S888 X88 @8 888S8S88XX 8S8SXX8 888 8 8 88 8 8%88 8.S 8;XS8 888 X@8
@@X@8SX8 88 8 8 8.X8 88@ @8 8 8 8 888 8 S888 8%88SS8SSX 8 8 8 8%X8 8 X8X8 8 8 8 888S8 X888 8X8 XS88XS8%888 @8X88 8S@S88@XX@88@@XX8X;88888@88S88XX8888S8XX8S888@S8888@S8@XXX8SX8 8 8S88@888888888888888@8888@888888888888X8@88 XX@8@8@8 8SXS88 8 X88 88%@X8%8 88X8 8 8 888 8 888 8SX88@8@%8XS88XX88888XX @S8X
@@8XX8 8S88SX8.888XX8 8 8 SX8 X8;XS8%88XS88 X8888X88@8%88S%8S8 8SSS @ SS88@888:@@@8S 8%8 S8 8 8 8 8 X 8X8 8.S8%X8 8 8S@88888XSS888X888S88@@X8888@S8888S8888888S8S8X @@@8SXSS8S@88@ @ 8S8@8@888X88888X8888X8888@88888888@8888888XS@@X@88 8 8 S8 8 S88%888@ 8 8 8@88 8X8S8 8 8 8S88@S88%8S8 8 888X 8 8:8 8 8 8
@@XXSS888 @8 8XXXS8S88 8 8%88@ S8 8 8 8 8 888888@8888S88888X8888888 S8888SSX8 8 8.@88:888 XS888 8% 8 8 8 @88 S@SS8X8 8S@X@8t8888@8888SX888888X@SS888@X8S888@8888@@X@XSXSXX8 8X8S8@8 8 88S88@S%888@888888@888@8888888888888888888888@8SX8 8 8SX888%XX8%X8 8 8 8X8 88S8%X@888X8 8 8.8 8@ 8 8:8SX8 8;8.888 SS8 
@@XXX88@ 8.X8X8 8S@8XX8 888 8 8 S8 8888888888888888888888X888888888888S8 @8XXX 8 8SX@8X@ 8S8 8 88@SS888 8S888 8S8S8S@@SXXX8SX@8S8X88SS8XS8888XS8@88SSS@@S8X%:@SSX8SSXX8 8S88;8 8%8 8 8%8S8 @8 8 88888@88888888@8@8@8@8@88888X88888888XX88 88@%88 8X8SXSXX8 88%X@8S88 8X8S88XX8 888 8X8 888@88 8 %8 8X888 8;8
@@8XX%X8 S8 SX@8:8 8 8 88@ 8 88@ X888X88888888888888888888888888888888888X8@8 888 888SX8 SS88888 8S8SX 8 8X8@888X888@8@S8%8S@SSX88tS88@88888SSS888S8S8X88@8@88 8%XSXXSS8:8 8XXX 8 888 8 8 8 8SX88@@@888@8@888.@@888@8888888888888888888 SS8 X8 8X 8X88S8 888X8S@X8SX8 8 8%@8%888S8 SS88S8@8 X8X8%S%X8S8SX 8 
@@XX8S8 8 S8S8 S8 88@ S 8 888 8 X8X8888888888888888X888888888888888888888888@8X8 S 8S8%8888X8X88S 888X888 8X8S88@8SXXXSSX8 8 8S8@8S8X@88.%8888888888%@%8@X@88 8 8 8 8 88X 8%8S8S 8 8 8 S 8 8 8 8 XXXX8@X88@88888888@8888888@8@88888888@@8S888 @S8SS8 @@ 88@@8 8S8@8S8888;8 888 SS8888SS8%888 88X8S8 X8 8 8 @
@@X8.8 S 888 S8 @8 8 8 8 8 8 8888X8888888888X888888888888X888888888888X88888888S88 XXX8 S888XXX88@@@8 8%S8 8 8 8888 8 8 8 8XS@8 8 8 8S8SX@S@888@S@8t8@@SXXXSS@ 8 8t8:8 8 8 8 X 8 S8 88@ 8 S 888 8 8 8 XXSS@8@88@88888.@88@8888888@88888888@%8 S8 8S88S8 XX 8 S 8X888S88 XX888 8 888SS8SX8X8@8 8SSX@8S88@@X8 
@@XX8 888 8 8:88 XS8 S88888 88888888888X888@8888888@8@8888888888@8@888888888X888888@8SX8 8 88S8.8 8S8888 8%X8 8X8@@8 888;8%8S8 8 8 8 X 8%8%88X@X88888@8X@XX8 8 88X88SSSXS8888%8:8 8@ 8 8 8@@@%8t8%8X8@;@;8 8t 88888888888@888.888@8@88888S8888 X8;8 X8 8 8%%8%8 8X@X8 @8 8 8 888 8 8 8 8 8X888@8 @ S8S8@8 8S
@@8S%X88X8 SX8888S88@ X8 88888X8SXS@@X@8S88XX@@X 8@8888@88888@8@8@88@888@888888S888S888 8.8%X@SX 8 8S8X@88XS88%@@XS%8 8:X8@888S8@ X 8 8 8 8S@8X88888888888888 8 8 S8X8 8S8@88888888t88%88X8X@X@X@X8XS8@S@X88@888S@X@@XX@888888888888@8X88888888%8X 8 8 8888 8  8 X8SS8 XS88888 8 8 8 S8 X 8X8X888;8 88XXX8.8
@@XX888S8 8%8 8SSS@8 8 X@8@8 XSXXX8 8 8 8S8@SXX8SXXX8S8888 @8888X8888X888@8888@88888888S88S8 8 8 888@88 8SX8 88SSX8 8 88%8X8 88888 888.8X8 8S88888@8@88888888S888888S88.8S8@88888@@X8@@888X88XXSS@S@8XX@@@8@@88@@SXXXXXXX@@X@88888@8@88@888X888XXX888X8 8 SXS8 S8 X8%X8 8 @ 8 888 888 X8 8 8X@@@@8 8 @8 8 8X
@@X8 X8@X88X 8 8 8SX8 @S@XSS8S88@8 S 8 X%8SSXXSS8 8 @88 8@@888@@888888@88@8888888@8888@888888S88XX8S8%8SS8 8S8S8 8 888 S8@8 888SS88 8 8S8 8X8888@8@88 @88888@88888888888 @88t8%8S88XX@@@SS888888888888S8888S8@88@@SXXXX8 8XXS8S8@8888@8@88888888@8.8 8.8t8S88888 8S88X%8:8 888 8 8 8 8 8 8X8SXX8%@8%8SSS88X8
@@SS88@8@8 8 88X8 8 8X@8 8S8 XS8 S88SS8S8SXX8 8 S8@8S8%@SX8@@X@@8888@888 @88@8@88888@88888888S8@8XXS88 8S88;8X888 8 @@X8XX 8S8%8S8 8 888S888888888@888888888888888888SXX8 8 @888:%888888S8XX8S8S8S8S888888S8X888@8XX8 8 8 8%8 8 8S8X88@8@88@888888SS8 X88@8 8 S8X88 88 %8 SS8 8 888 X 888 8 8 8 8 S8 8 8 8S8
@@8SXXXS88@X8X8%88:8X8 XS@88888 8SX88 S8@S8SS88@S8 X8X8 8SXXSXS@@@888@8@8888@88@888888@88888@8888888XX8:8 8X 8X888X8S8%X8S8 8 8 8%X88X888888X888888 88@8@8888888888 XXXSX8 8X@8S@SS@:@8X;8SS888XS8888X8@S88X8SS888@SS888 8 8 8@8 8 8S@X888888888888X 8S8@8%@@8S8%@X8 X8 88 8.S8888 8%8:8 8t8 8 8 8 X8 888 8 
@@XX8 8 S8X8 X 8 8@ 8%8 8S8 S@888@ @88X8%X888 8 X 8S8SS8 8 8S88 88@8@88888@88@8@@@8@88888888888X88888888 8S8 S8X8X@X8 8 8 8X88888888@888888@88@88@888 8888@8@88@@SS8S8 8S8888 8 8 8 8X8.%88888888888S8XS;88888X8@88XS8888S8%8X8 8 8 8 8 8888@8@88888X 8 @ 8X8%XX8@8 8 X8 8 S888 8SS88888 S888 888 8 S 8XXS 8
@@X8SS @%X88S88 8 8% 888 8:8%8@8S@8S8.8 8 8SX8 8 8 8@8 XSSSX8%@8S88 88XX888888@88@88@88 @8888888888888888@88888@888SX88888888X8X@8888888888888@8@8@8888888@8@XXXXXSX%8 S8%8X@8 8%8 8 8 8SX8;888@@X888X8X8XXS88888888 SX8S8 8:8 8.8SXX8X8%8@8888888888X 8 8 @88S8 8XS88 8%S8 S888 8X8X8 8 8:8 888 888X888S8SS
@@XS8%888 X88S8XS888 8 8  8 8 8 8 SSS8S8;8 8 X8t88@X8 8 8S8 S8 8 8 8SXXXXS@8@8@88@888888888@888888888888888888888X@888888@@888S8888888888888X888@888@88@8SXXXX@XX8 8S888XX@8 XS88XS88 8 8SXX@S8SS8888X888@88X88888888X8SX%888%XSX88X8S8 8 @@@X88@88888X 8888SSX@8@8 8S8 888S8S@88 8 8 888 8 8888 X8 8 8 X%8X
@@8SSX88 8X8 8S8 88 8 88@S%888 8 8 8 8 X8 S 8 S8 8 8:XS888 8 8 X8 8 8S8@S8 8X88@88888X88888@88888888888888888X8888888X8888888@88888888888888888X88888888SXXX8 8%8 888 88S8XX8 8 8 8 XXX8X8 8 888SX88888S@88888@8XS888 888%88.8S8 8 8@8 X 8SSXS@88888888888 8888%X888:SS8 @ 88@X8SX8 8 88 888:8 X8 S888 8 8 X
@@XX8S8SXS88SXXS8SX888 8 8 8SX8 S 888 8 X8 88X @8 8 8 8 8 X88.8 XSSSX8X@SX@8SX8X@8@8@888@888888888@8@88@88888888888S@888888X8888X88@88@888 @88.@8888@XXSXX8 8SSSSS88 @S@8.8 SS 8 8 8%8%8SX8 8S@888S8888X8SS88888S8SS8X@8@8 8@@X 8 8S8.8S8 8S8@S8X888888888X8X 8X8SX@8 8 888 8 8%@SSS88 XS8S88XX 88S8S8 8888X
@@X8 8SX8 888X8 S8 88X8 888 8 X8S888 88@ SSS8.8 XSS888%8X8S@@8 8 8888S88%8S@8 XX88888.8888@8X8.8@8@88 888@8@88888888888888@888S888@8@888.888@8888@XXXXX8 8 888S8888S@@8 8X 8 8 8@ 888 888 XSXSX@@8X8X8S88888888S888X88XXX@8X8%8S8888 88@ S 888X8XS88888@888S8S88XX8SS8 8 8 8 X 8 8%@ X8S88@S8S8 8S88888S8X8S
@@SS8 8S88X@SX%8 SX@8 XS8 X%S8 SXX8888%@@8SX8888S8S8 %8X8 8SS%888 S%8S8 8:8 8X8 88XX@S888@888888888@88888@88@8@8888888@88X88888888@88888888@88@X@XX@XSSS8 8S8 888:888XS8S8 X888 S888 8S8 8S8 8 8 8@8SS888XXX88S88XXX88 8S8@8@888%8S8@8XX8S8%8X8S@X@888888 @X@8 @8 88XS@88X8t8S8 888 888 SXS8S 8SS8S8X888 8 X
@@88 8 8 S8 8 8.8 8 S8 888S888%888S8 8X8 S8S8X88888@8 SX88 8 888 88888 XS8 8 8 8 XXXS8@S8888@@88@88@888 88@8@88@888 X88888888888@888@8X88888S8SXX8SS8 8 888 88%@X8 8.8 SSX8 S@@8 88X8 8 8;S 88@ @ 8888SX88888888@SS88;% 8@8S8X8@8 8S@@8 888 XXX8%8%XX@8888@@@X8 X8%X8X888X@8 S 8 8 8 8 8 8 88SS8SS8%8X8 8 8S
@@SSX888%8 8 S 888 888%S8 8 8 8 X8X88 888 S8%8X8X88XX8 8 SS888XX8t8@8@8 8 X 888 8 8 8 8 8S8X88.888888@8888@88@8@8.888888@8888@8X8@@88888@XSS8 88%88%X8 8 8 8 8@S8 8 X 8S8 S8S8 S8%8 X8 888X8 8 8 88@S8t88X8@@@@8888X88SX 8 @S8X@88 8X8 8 8 8 8XXS@8 XX8888@8S8 8SX8 8 8 88  8 888.888SS 888 XX8 8 SSXX@8 XSX
@@X8SS8 888X8S8S8 8 8 @SX888 88@ SXX@8S@@8 8X88;8 X8SX8:8 8 8 8 8X 8X888 8 888 S 8 8 S 8 X 8S@S8888888X8@88888@888@88@8.88888@88888888@XXX8 @8 @8888 X88@ X 8S8 88 8%8:S 8.X888S8SS8 XS8S8 8SXX 8 88@X@88@888S88XXS8S8X88:88 @8S@88 8 X88 8 8 8 8 S@8 88X8@S8 8 8SS8X8 8 888 888XSS8 8888@ 8 88@@8 8 8 XX88X
@@8.8 S8X8X8%@88@8 88@.8 8SX8 8.8%8S8 8S8 8S8 @X 8 8XX 8 888.8X8S8XX8X@@888@8 8 888 8 8 8S8 8@SX@X8888@88@8888@8888@888888@8X888888XXSXX@SS8 88S8@8 8%8 S8 888 8S8X@8 8S888S8 X8X8 S8S888 8S8%8%8X8SSSX8S88@888@S88@@8XS88S8@8 8S888X8%8 XSXX8 8;8 8 8XX8@8SSX 8 8 @ X8 8888SS8 8 8:888.8 8 8S8SSS8 8:8 8 X8
@XXXS8 SX@8%8X8S8 8%8 888 8 8S 8 888.SS8SXS S8 8 8 X88XS8888@8 X8 8S@8S8X88888S8X8 888X8 88@X8@SXXXX8X@888888 888@888.@8888888@X8X8@SXXXS8 8X8S8 8 8 X88 S%88 88@S8%888X88 8.8 8XX8 X888 888 X88@8X@88888XS8888888@88%S@S8@ 8 XX8S8S8 8 8 8S888 8 8 8 8 X8 8888XX888888888 X8@8@@8:X8XX8S8 88X 8%88@ 8 888 8
@@88S@888%X8XSS8;888 8 8;8 88@S 8 8:8 888S88S8%S8:8 X88888 8 88S%SX8 XSSS 8X8%X8 8SS8S@88 8 8%8%XX8 XS%S888.88888888@8888.@XX8SSX8SX8 8S@S8:8X888@XS8%8 8%8 X8@8 @ 8S8X8 X8 S88;8 X8%8 S8 8 8S8 @ 888S88S8S888@X@888@%X@8S8SS88X%@SX%8 S 888 8 888 888 8 8XXSX8X8 8 X8X8SS8 888@8;8 S8 8 X8 XX8 8 XX88@%8 8 
@@SX8%8888X8S8 8XS8 888 888SX 8 X8SS8 S8%8S8 S8 8X @8 8 8 888 88S8SX8 8S8SX@ 8 S8.8 X88X 8 X8XS8 8 8 SS888S888@8X8888@X8X88SXSXXSS8 8 S888 888@8@8S88@@8:888S8 SX8 SX@XS8SS8 88X 8:S8:8 8 S8:8 8S8 @88@@88888S8S88@@@8S8SX 8 @8S8 8XX%8 8 8:XS8 @ 88X 8 8 8 8.X8 8;8SSS%8%X8 X 8 8;88SS 8 S88XSS88S8 XX8 S 8
@@XX@8%8 8 8@88S8SS8 @ 8 8:X88 8 S8 S8% @X888 S8 8 88XS8 8 8 @%S8 8 S SS88X8S%88 888 X8 88@ 8SXS888 8%X%8888@8@8X8888888888SXXX8 8 888S@%8%8 X@@XS8 8S8 8S8@888S8 8 8S8  8 888 8% 8 @8 8 8 88 888 8X@SS88888X88X88X8888XX88 8 XXS8 8 888 888S8 8:8 8 888 8 888XX8SXX8 8 S8 S8S8 8 X888 888S8S8 8 SX88S8 8S8 
@@8@8 8 8 8X8 @X%8S8888SS88S@8S 8 S8888@@8S888 88S8SX8S@8 S 88@ X888 8S8 XX@8 X8S8 S8 8 X8.X8@8 8SS8 8  t@X8X8X@@8X@S888@888X8 8S 8 8 8SSS8 8 8 8 %8:888@8S8S888@@8@ XS8 8888 8 8%S@ @8 888 SS88X8.888S8888X8XXX8888888%8 8X 8%8SS888 88@8 SS888@XX8 S8 888 8 8 X888@8%88@8%X8 88@ 8X@8 8 8X8X8%8S8 S8S8SX88
@@S8.888SSX8 8 8%X8888888SS8 8%888 X8 8@8%S8XX8;8 88XS8SX8 8 8 8 88 888 8 8XS8 X888 X888 SXS88SX 8S888S 8888SSS88XS8888888XX8S8 8 S8SXS888S888 8 8 88@8X8 8@8S8X8%8 8%88888XX8 S 88S8 @8 8 8 888X8@8X8888XSS88888S88%X@ 8S8%8 888 8S88 8SS8 8 8@8 888 88%8 8 8 8 S8@8%S88 X8 S%88S@@X888@8@8X8%S88@8S8 S8 8X
@@SS8S8 8S8SX8 S8 X @XX@888@8 X88 8 X8 XXXXS8SSX @SX8 888S8 888 8S@8 8:@X8 8 S8 8 S8 88 8 8 888 8:8 888 St8X888888t8S88888888X 88@ X8S8 X888XS@8888 X@%8 8@8@XXXXX@8 8 8 SX8S@8 888SS8XX88@88 8 8:888S88XS888SSX88@@.SX8;8X8 8 8 88@XX8 8 SS 8 S 8 @X88 8 888 S 8 X8%@8X 8 S8 8 SXXS8X8X8 @XX@8 8S8%@@8 SX%8
@@88S8 8 8;8 8 S 8 @X8S8 @8 XSX88XX8S@8 8 8 S8888 8 88 8888888.X 8S88 8 8 8;8 88.8 88 88@88@S8 8 S88@8 @ 8St8@S@888888XSX888X8@X8 8 S8 88 XS8@8@8SS8S8 8888S8X8 8X8 8 88@ 8 8 S%88 8 8%8S8X888:888888888S.@XS8S88@@8@X8%8S8 888 8 8 8 X888 8 S8S888SXS8 S8 8 8 888 S@8S8SS8 88S8%8 8 XS8 8X8X8 8 8:8X8 8 8 X
@@SSXX8 S 8 88@88888X 8S8 8 8 8:8 8 8 SX8 S8 8 X8%X8 X8S8X8S@X8 88@ 8@888SS888S8@X8 88X8S88%X 8 8 8 8 8 8@88SSS8XS@88888888@8888X%@8S%888X8 @8%X 8 S8S8X8X88S@%8 8 888 8 888 8 8 SSXSX8 XS8X@X88888XX888S88888SS888;S8 @XSS8.8 S 8 S @8S8 88@ XS@8 8 88@ XS8888S8 8S@S8 8S88S8X888SX8 8 S 8 8 8 S 8 8 88888 
@@X8S8 8 888 8 8888@S888 888 888 8 88@%88@ SS8 888 S8%X8SXS8S8 8 8 8S8 S8S8.@X8X8 S8SS888 8@X8 888 X@8%@XS88S8888S8S@XS888S8@88888 88SX8S8 8 X8S8.8 88S8S8SSSSS888SX8 888 8 S 888 8 @ X8 8 8 88X88SSX88@S8SX8888888XSS8XXX88SX8%888 888 8 X8 8 @ SS8 S8 8 888 8%X8:8 8 X@8 X8S8 88S88XS888888@X88XS88@X8X888
@@8 8 S 88@ X 8:8X@%8X@ 8 8 88@ S 8 8 X88S88888 8S8 S8 888 SSSXX88S8@S8SS8 888S%X88 8@8 8S8%8 8;X 8X8%@XX8Xt@S88S8X8S8S888@8S@8888: X8SSSSS88S@8t888S8 S@SXX8 8 X8X8SS @ 8 8 8 8 8 88X SX8 S:t@8@SSS8X8S888888S8@X8XXXX8 888@8:8 8:8 8 888 X888 8 888 888X SX8 @ 8@@8 8S8.88 8%8 SX%88X 8 8888XS@8S88%XS8X@@
@XS888 8 8 8%888 8 8 X88.8 8 8 8 888 8S8 X 8S8 8 8888S8X8@8 8S8 X8S88XS8SS8@8X8S8 8SSXX8 8 SSS88 8 8tXX8 8SX.8XS88XS88888S88888SX@S88X8 @S8 S8 X@X8SSS8%8 8 888 8.X8@8SS8888@ 888X8S8 8 8X%;S888S888888XSS88@S8S88 8S8 88S8 88SXX 888 8 8 8 88 888%8 888S8X8%8 X8S8S8888 @SS8@8 8S8 X88SX8 8.8 8 S8 8@S8%X8@
@@S8S8 SS88X8 8 8 888 88SS%S888:8 8;8;8S@88.@@888S@%8 X8S@@8:X 8%X8 8 8 8S8 XX@8S@X8 8S8888S8S8 888 8 8 8.8 8;8X8888@S88@88888XS8X8888%8 888 S8 888XSSS88XX888 88@S8SX8 888XX8X8S8 8X88;;8%8@S8S88X@X8X8.888SSS88@8 8 888%88t8 8%8 8 S 888 8 88@8SSX888 8%888X8 SXX8S8XX8XXS8 SS8888S 8888SS8 8S888S8 8 XSS8
@@8:8S8 8 @ SSX8t8 8:8 888888X%8 888 8888 88S8SX%8 XS@SS88XS8 88@S8XS888 @88S8 SX8SS888S8 S88@ S%8 888;88888SX.@8X88888888@X888S88@8888888X@XX88S8X88 888@888 888S@ 8 SX8888 8888;@8%t8%88888SS8888S8888888X8X88X8%8 8 8 8 8X@8 88@.8 8.8 8S888%X8 8.8 X 8S8 88X%8 X8 8 888%8888%8%@8SSSSXSSXS88@8 8X%X8 8 X
@@@8@8 888 8%8 S888 888 X88888 @8 8 8S8 8S8t8@8 8;8 8 8 888 S8 8 8X8S88%8X8 @@8 @S8 S8 S @SX8 8 8;S88 8 8 8%XXX@88XXX88X88888@S8S888XS@8@88S88.88X8S88:8 8 8 X888S8 S888S88@ X%t88SXX8X8@@X8SS88S@S8X88S@8X8888XXS8 888X8S8 8S88 8 S 888 888 SS8SS8SX 8 8 8 8 8 8%8 8S%8SX8S8.X8 S8 XX88@8S8 8 @ 88%8S8 88@ 
@8 8 8888 888 8 S8 8 8 8S8 8 X8 X8 8 8 8 X88%88888XS 88XX888 XX8 S8 8 8X888@8SS8SXX8 SX88 8 S888 8 8%SX8.8 8S8SXXSX8@888S@S8S@888X8SSS8X8888tS88888S%8%88@8 8888X8S8X@888t8@X8X8X@88@X8SSSSS8SXXSS888@S8888@88@X@SS888S8%XXS%8 88 8 8 8 8 888S8SX8%88@X888 888 888S8 8 @8 8 88S88%X88X88 SX88.8 8 88888XXX 8
@@8 8 888@X@SX 8 88 8 888 8 8.S8%S X8 8 8 X88@8X8S8S8;8 8X888X88XSX88XX8 @88X8 S8S8@8X8 8  8S88SX888 @ S8 S 8 8 8S.88S8X8X:8@XX88SS8S88@S888@S88@888@@%8@888888X8888888@88888XX@888SS888888888SS88S@S88888XXXX8 8%8 8 @ 8S8 8 @%888S8X@8 8S8@8X8 XXS8X8%X 888 8 8 8.XX8SSX8 8.8.X88 88888%8SX8 88XS8S8@@8S8 
@XS88@S8X8 8%8 88S8XXS8 SSS%88 X8888 8888XS8 @S8 8%X88@8 8X@@%@8 8 8%@X @S8S8 8 S8S@88%XS8 X8 X8%8S@8:8 X8S8;8 8 8 88888X88SSS8SX8@8@S8X8S888@@8888X8@XX@88888888888888@@8@SSS88S8SS8SXX8@88SSS8SSS8SS888:@X8S88 888 8 8 888;8;8%88888X8XX8S@XSX8S8%X8%8%8;8S@ 888 8S8 8 88@ 888 X88X8 8 8 8 888SXX@XSSS%888
@@8 8 8 8 X 888 S@88XS88S8 8 X8X@S%S 8 8X@8 8 8 8t8X8X@88XS8S8SX8 88@X8SX8 888X8 888X 8SX888X8 8@888XS 8 8 S8 8 8 8 8X;8@SSS8X8SS8@S8:8888X888X8X888S88888888@X888@888S88888888S8888S888888SS8XXSS.888X S@XX@8S88 8 S 888 8 8:8@8@8S@8 8888@8 8SS8%8 8X 8 8 8 88@ 888.X8888 8 8;8 @8 S@8 S8888 8 8X8@S8 8 8 
@XS8 8 888%8 8 8%8 XS8.8@8SX8 S8S8S8S88;8 SS88X S8 8 8 8X8SXXS8S@8 8 8 8%88@8SSS8 X8X8 8S8 XSX8X8 X8S8 8 8 8;888 8 8S8 8888X8XS8S888@888X88@@X8888@S8SX8S8S888S@8S@8S8S8S8X888@8S888SXX8@SS8X8X8S8SS888@XSXSS@8 8 S8 8 8 8 S 8X8X8%8 @8 8:8 S8 8SX8S8S8S8X88.8X8 8 8 8 8 8.88 88 8S@8%888 %888SS888X@S888 8%
@@8;8 8X88888 888 8 888%8 8S888S8@8%8 8X 8%8 8S@ S8 S 8 8X8S8 S8 X8 8 S@8 X8 8 SS8XXXS8 88888X 8:8 XS888 88%S88 8X8 XS8S@S88X88@8888SX8S8888@8SXXS8X8888X8888SSS8@8S888888888X8888@S8S8@SS88@X888;8@@@XS@XX8 8 88@ S888 88@ 888 888X8 8 8@X8S@8 8@8.SX 8X8 88%8 888 8 88@ 8S888X@ 8S88@8 8S@SSX88X 8 8 8 8 8
@@@8 S 8X8S8888XX XSX8 8 8;8 8888 S%X8X8SS8 8 8;8 X8%8 88X @ 8:X8%SS88X8 8 @8 8%8 8 8 S8X8 888% 8 8 8 8.8 %88SX8S8S8S8 8 8X8 888S8@SS88XSX8888XS888@SS88XX88SS8XX@88X8S8X888@@X88S8X8888888888;@XX8SXX@SX8 8 888XX@ X8 8 8 8 8 8X8S8X%8888S88XX8%@X8 8SS8 8 8888 8 88@ 8 S 8 S8X8 S888 8SS8SX8S 8 8 888.888;
@8 X88 X8 8S8XX888 @ 8 88 88X @888 8 SS@8 S888 8.8 8 S8S8S8S88@ X888S%8 8 888888 88@:88 8%8S8 8 8 888@:888SXX8 8 X888S8X8 8 8S888t88X8888888@X8X8@S8@8888888S8888888XS88888XSS888888S88888%:8@XX8SSXX8 8S88 8 8 8S 8 S%S8 888 8 8@8S88X 8 8 88%X8@8 88@%88 8S8X888XS8 8 8 88@%X8 8 X88SS8 8S8%8 8 8888 8 8 @
@@8 888 8%S8 8 X@8SS8.8 8XX8 8X8S8SS8S8 S8 88 X 8:88@S8 X8%S8%X88SS8 8 8 888 8SX8 8:XS88%8 8 888888 8 8 8;8 8 8 8S8 8 @ XSX8 8@8 8X@88.S8@@SX8X888S8S88XX88S:8@XS888@88@@SS888@@X88S8t88@XXXXXSXSXX8 8 S8S8X 8 8 8 X88@ 88 8 88@@8@8@8S8 8 8XX8SSX@8 8 8SX888 8S8 8 88@8.8 8.8 8 88X8 8 8 X8X8.88@X8 8@S8 8 
@XX8 8S8.8 SS@8S8 8 8XS8 8 8 8 8%S8 S8:8 888@8S8 X8@X888%88 88 8S8 8SS888 8 8 8 S8:8 XS8SX8 88X 8 X8 888SX 88888 8S88 X8 8 S8@8S@X8S8 8@S@88%8888S8888S8S8888S88SX888888S88X888X888XXX@XXX8 8XXXXX8SX88SX8%8SSSS%88 X8 8 S 888S@8X888X8 888 8 8 8S8S@8 %8 8%@8 8 8t8X8 8@@8 S88 8 8SX8 88@ SX8888 8%8%8 88 8
@@88S8X8XX8 @ S@88X8S8 88888888.8 X8 @8 888X8S888 8888SX8 88 8 SSS888 88 8 8 S @8%S @88S8 S8S8%X @SS8.8 8S8:8 8 8 8 8S%8888%8XSX8 88%8S8X8S@S@@88888:8t8XXXSX88888SS;;88;88888XSXXX@XXXX8 @8@SX8 8 X8.88 8888 888 S8 S8 8 8 8 8S@XXXX@88 8 8 8 8 @88%888S8 8S@8 888SX@8@8 X8SS8@@8X8 XS8 8S8X8X888XS8 S8 S%X
@@%8X8 8888%S8S8@8.S8 8SS8888S8S 8 88 XS8SXX@8S888%@888SX8 88@888888@8XX888:8%888%8 S888@@8S8 8 8 8 8XX888.8X8:X 8 88@S8 888 8 8 8 8SX@X8@SSXX8%X@@@S@ @X8SSXXXX8SSXXS8SX8S@XXX8 8SXSXX8 8 8%8 8% 8 88:88S8 8  8 88@8 8888888S@8S8 8 8XX8 888 88XX8@8 X8 X8 8S888SX88XX8 8 88888 88S8 8 888 8 X8@8 888 @8S8 
@8 8 88 8XS8 8 8 88 888@ S 88888 X8 8S8S%8%8 X8X@@8 8X88SX8S8 @XSSX8 X8 8%SS888X@S88 S8S8 X8 888.88@S8 8SX8S8:8%888 8.S 8 8;8 8 888 XX8@8SXX8 XXXX8S@S8S8 @X@XSXS8 8S8 8 XXXX8 8SSXX8 8 8 8S8X88@%S8 88 XS88X888@88  @88%8 88888X88.8 8S@8S8 S 8 8X888 S8%SX8S8SX8SXX8 XX88 @8XXXX8 SS888X8 S8 S8%8 8 8 XX@8
@@8 8%8888SX8 88XS88 8SX888 @8SX8 8%S8 8 SS@8S@8S8 8 8S@8%S8S8S8 8 X@SSSX8S8 8 8 8:88SX8 8S88X@ 8 8 8 888XS8SXXS88 X88%888 XS88@ 8 8 8 8:88 88X8 8%XSXS8:8 8 8@SSS8 8 8 8 8 8 8 8 8 S8 88@X8S888 8 88 88888SXS888SS8 8888S8 X8SX8 8@XX8S8 S@8S8 8 8X888 S8S888.8 @8 8 8 8 S8 XX8X8 8 888 888 8 8  S 8 X8 @ S
@XX888X8SX8S8888 8 8888%SXX8 X8 S888S8 8 8S8 8 8 88 @@8S@8S@8@S8S @ 88888X888@8@88@88@8 X8%SS8S888 888.8%8SX8S888S8X8 888 8 8 8 888 888 8 @8 8@88 8 8 8%X88 8S88 8 8 8 S 8 8 S 888 888 S8SXS8X8XS88 88 8@X@888S 8XX @S8S8X88SS8SS8X8S8.88@X8 8 888 8X888%@8 88SX8SS8X8:8:8 888X88888X%S88 8 88@:8%8 888S8 8 
@@8S8 8 8S@888X 8 8S8X88XXS8SXX88@@ 8 88@:X 8 8 8 888X 8S@8@8XX 8 88 @X 8X8@8X8SS8 @8SS8 888@8888SX8S@8%@S8SS8X8888 888 %88888 8 8 8 8.X @SS8%8%88 X 888@8 8 8XX8 888S8 888 8 88@ 8 8 8 SX88 8S8X@ 8 88 8S8 8S8%888@@8 8S8 88%S8%S8 X 8 8 X 888%8 8.8S@@@SS8 8X8:8 8888S8 8 8888X8@8S8%8 8;8 8:88@88SS8%S888
@@SXX8 88@SX8 8 888@ 8%88SX 8 8S88 8;8 8t8S888%8X8%S8XX 8X@8 8 8 8 S8X8SSSS8;8X8 S8 X8 X8 X8X8@8.8%X@XS8 8 8S8 S88.8 8@8 8S88 88@ 888 8 8 888S88S88 8t8 8 888 8 X888S88@ 8 S 888 888 S88S8 XX8 8 8 88888 8 88888 @8@8;8 8 8 X8 8 8 8S888:8S8S8 XXS88XSXS8 888 XSX 8 X88XS8%8SX@ 8 8:X@8 X88 88@S88888SS8 88 
@8%8 8 8XX8 XSX8X8@8XX8 @8 888 8 XS88@X 8 8 8:8X8 8 88S8;8S8@XX888X8 888 8 88S8 8 8%X88 X8 8 8 8888 88 XX8 S8 8S8@8 8S888@8%S8S8 8 8 88@:8%8 8 X8 X888S8 8SXSX @8S8 8S8@8S8 88@ 8 8 8S8 X 8 888 888:8X888 8S88XS8S@8%X88XS88S88@8 8 8 8:8 888 8S8 8X88 888%X 8 8S888 8%XS88 8 8 8SX8X888X8.8 8S@S@88%8SX8S@8
@X8 888 8 8888X 8 X 8S@8 8 88 8 8 8 @X8 8% 8 8 8S@X8 8 8X 8X8S8 8 88@X888S8 88 888.8X8 8 S888 @88 8S88XSS88%S8;8@8XS 8X8@8 8SS8X888X8S8 888 S @SX88S8 888 8S8 888 8888S@8888@8 8 888 8S@88 8S@SSS8 @@@@@88 8 88SS8SX8X8SS8 S8S8S88@888:888%8 888 8 8SX8S8 8 88@ X88 8 8 8 8SXS88 88S8%888SXSSX8S88 8 888S8 X
@XS8 8 888@8SSX8:8S@ 8S88.8 8 S8%S 8 X88.8S888@ 8 8 88XS8SS8 @88888SX8X@ 888SX8 8:8 8 S @%8XX8:XS8 8 SX8 88@ 8X88%8S8;888S@XX8@8:X8SX8XS8S@8S8;8SS8SX8 8 X 8 S 8 @@8 XX@88X8SXS8888 8 88S88X8 88888SSX8X@ 888SXX@X8 XSS888SSS8:8%8X88 XX8 X8 S8 888 8 SS8  8 8 8S8SXSS8888 8 8 S8 8 S8S@@8S8S8 8 8XS8SS8 S8 
@@88S88S8X8X8S8 X@8 8 8 8@8SS8 X8%888 88@ 8 88X8 888 8 X 8%@888S8 8 8 8%8@@@8 X8.@888 8 S8:8 8 8 S888S888 8:8X8 @8 8 8X888S88@@S8 S8X8S88@ XX88@8 X8S%S 8 88@ 8 8 XX8%8 S%8 8 8 8X@8 8SX8 88@8 88888 8 8S8 8%8 8S888 8 8XS8 8 8@8%8 88 8 88 888 88 8 8%88@SS88X8X88S8 8 X88 88@S8S8888@8 XX 8;XS8S8 88 88SS8
@@%8S@8@ 8SX 8 8X8S8X8S8S8 8888X 8t8%8.8 88XSXXS8 8SXS8 8 8 X@ 8%88@SSXXX8@@ @ 88 8X8888 88 8 88X8S8 @88.X 8 X88SS 888X8SS@X8S8@ 8 8 X8 8 8 8 @ S8 888X888 8 888 8 8 888S8 88888 8X@8 8 888%8 8.8X8 888 888 8 8 8X8@888@8 88 8X888X8 8S 8 8 8 S8 XXS S%88 8 X8%8X8 8:8 8X8 SS8 8 888 8 S8%8 S8 8%SS8SX8 888S
@8 8X8%8S888XSX8@ 8S@88X8 X88 XXS88 XX8t8 8 8 8 S888%888 S @S8 XS8SX8S888SX@8.8 8@@8 88 8 S888 8 8 X8S8@8 888%XSX8%88SXS8 8 %8X888XS8SS8.888X8:8 88 888 8SXX 8S8 S8 8 8 8 8S8@888 8SX8 8 @@8 888 8 8;8 8 8 8 888 8X8S8S888S8X@8S8%SS8:88XX%88X X8 88888S@8 8 XX 8 8%X8S8S888S88X8 8 X88 X888%S8 8 8 8 888S8X
@@8 8SX 8 S888X88@ 8S8X8.8X8 8 8%888SX@8 8 888%8 8888S8%8 888:8 88X SX 8S88SXX88X8X88 8 S888 S% 88@  8X888 8 8X8888 8@SSS8 8SS8 S8X8.8 88 88S 8 8 88X888 8 8 888 8888@%8 S 8 8X888 8 X8 8X8 8 8S888t8 888.888 8tXS8% S8S@ 8S8%@XS8 888 8X88S8 8 S8S8%X 8 88X8X8SSS88S8SX8 S8 8 888.88X @ SX88888SS 888 8X@%8
@XS888 8 8SX888 XX8;8 @ 8 8 S 88@X888X8 88@@@ 8 8X8X88 S8888 S88 8 8X8%S8 88SX 8888 88 8%%X 8 8 88S8 S8S8 8 8 8S8S88 8 8 SS8S8 8 8 8 X8 88:88 8 88S888@ 8 888S8 8t8 8 88@ 888 8X888 8 X8 8 8 8 8 8:8 888 8 8.X 8 8 8 888 8 8@8S8S88%8XX 8:8%8XX8 @S8 8 S8%8 888888%S8 8 S8 SS 8 @;XS8%8 8S8 X8X88X8S8 X 8S@S
@@8 8 888 888S88 8.@88 8 S 8 8 8 8X8@8XS88S8S8 88@ 8 X8X88@@S8.8X888@@8 8S@S8%888 8S88XX88XS 888 SS@8 X8%XS8S8:X 8%X8 888S888 8 888 8 S8 88 XS88 SXS@8%8 88888@X 8 8 8 8 8 8 X 8X8 8 8 X8 8888888.888%8 888 8 888 S88S888 8SXSS@8 8@S8%8 SS8X8 8 S8.88@ SS@8X8%S888SX8t8SX8 8 88;8 8.888 8S8 XX%8%X888 8 8 8
@XS8 8 8.8:XX8 8 S88X%8 8 88888 8.8X8SX8 8 8 X8 8 8 8 S8S88SX88 8%8S8%X8;8@8 8 XS8 8 88@888 8 8 8 8SS8 88888@XX8 S8 8%SX 8;8 8t8.8 88@ X8SX8 8 88@8888%88;8X888 888.888 888 8 8 8%8 8%8 X8S8%8X8 8 8;SXX 8 88@.8%88XX8S888 8 8X8.8 8 8 888S8@S888 X8%8 8 8 88888S8 8 S8 8 S 88S88 888%8 888S8 8SS8%8 SX8 XSS]]

--[[@@@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8
@888X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8
@@8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 
@XS8 8 @S8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
@@SXSX8%8@8SXXS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888.
@@8S8%X8X8%@XX@8X8X8 8 8S8%8.XS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.X
@@XSX8 S8 @8 8 X@88@8 X 8 888S88@.XS8:8S@888X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8%
@@X8:S8SS8SX888 8 8%X8S8 8%8 8S888S8S8 88SX8 888 8%888 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX8SX
@@X@8%X8XX8S88 8 8X8 XX88 8 X 8S888@8 8 @8SSS 8 8 S88.8S8SS@8 8X8SX88 8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 888 
@@8SS8 88SX8%8S 8S888S8 SS8888X8S8@8 X88 @8 8 X888 8%S@8X88 88@8 8 888X8 8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 8 8.@
@@XXXS8SS8 @8 8 888 SXX8S888:8 S8X@@8S8@8%88.8 S8 888X8@8 @8 8S@88@ @8 S88888%8t8 888 S 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 888 8 
@@X8SX888 8 8 SS8XX88@8 888 X 8S@8X8 8S8 8 8X 8 88.8 8 8:8 8 X8 8X@8S88 @ 8 SS88 8 8:8%888 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 8 8 8X8
@@XX8 8 X8 88@ 8X8S@SSS8XX 8 8 8%X8SSX8SXX8 8 88S8X 8 8 SX888 SXX8SS8S@8.8 8 8 X8 888 8 8.S 8 8 888 8S@ 8 888 8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 888:8X8 
@@8SSS88 8 XX 8:8 8 8%8.8 8 888 8 X8S@@8S8X88@ S@88@X888S8S@ 8S888X8 8 8SSX 888 X XXS888 8 88@ 8 8S888 888 8SS8@ 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 8 @X8 8
@@XXX@8X8 8 8 88X8S@8 8888 88@ S @%X8S8 8X888 8%8 8888S@8S8 8 888 8 X888888S88 8 8 8 88 X88 8 888 8 8 8 8 8 8S8.S 8%8:8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8X8@8 8 
@@X8 88 XSS888S88X8%X888 X8 8.8S888S@8SSX8S888@8 888 X8X88 888X@88 8S8 8 X88@8%S888 8S888X 8 888S888 888 S 888.8S8 888 888@8:X 8@8 888S88X8SSXSS88S888 8@8 8%8@8S@S888 %88X8:X 8@8 888S88X8SS8 888 S 8;8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@888888X8 8 X 8
@@8 8SX8S8 8SXXS8 S8%S888 88 888@8 8 X8S8 8X8X8@8S888 X8SX@@8 8S8SS 8:XX8%X8SX8 88 S 8 S88@X8.8 8 8 888 8 888 X8888 8 8X8S8 8S8 8 8X888S8 S888 @t.t;8;8XXSXX8S8%8S8X8t%8t8:X8@@@S88X@88S8 S8 S8.8@8S8SS@S88X@ 8 888 88888@8@8SXS88@8 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@@SXSX 8 8 
@XS8 8S88@8:8%8 8S8 88 XX8S88X888@%@8 XSSX 8 8X8 8S888 S8X8 888X 8 8 8 8 8SS8SS8SX888@8X%8X88SX888.8 8 888 8 8X8@8 8 8S8 8 8 88XS88@S88t88;888t8XX%XS8X8@8@888@8%8S@XX%S88S888888%8 88XX 8.S8 88@X 8t8 8 8 8 X 8 8 8 XS@88XSXXX8:@8@8 8:8 S888S8 8 8XX8 X8SX8X8S8 S8%8 8 8 8XX8 X8SX8X8S8 S8%8 8 8 8 88888X8
@@SS S8 8 8@88%8 X88S8@8XX8 8888S8S8 8 8S8S%XS8 X 8X888S@8 8S8X8 S8 888 8S8 S8SX8 X88@88 8 S8888XXSS888 8 X@8 8 8 8 8XX%8 888 XXS8 8888t8X888888@8888@8888@88@8888888888X88@888tS8@%8888@ 8 X8 X8S8 XS8:8 X88 888 X 8 8@8 8 8 888 8%X8 8 8%8 S@S8X8 8XX8S@8SX@X@@8 S8X8 888 8XX8S@8SX@X@@8 S8X8 888 8 8888@8
@@8888SS @X8%@88@S8@8SXX8 8 8 8 8 8 888:888S8 S8 8 8X8@8 8X 8 @@8 X8S8 88888 8S8 8%S88888 8 X8SX88S8SX88 8X8SXX8X888 8 8 888 8 8@%%888888X@88S@888SS88@X@88888888@S88S888@88X8X8X8@88888@X88XX8%X8;8S8S8 88X 8 8 8 88@ 8 888XSS8.8 8 X%S SS88S8%8S88 8SS8 XSX8 8 S8 88X@88 8 8 S@S8 8 8S8 8%8SX8S8 888 SS8X8
@@S%S8S8 S8 8 8S@8 8X8XSS88@ 8 8 888 8S8 8 X 8.88 S%8X@XXXX8 8X8@8 S8SSX8X8@8 888:8%X8X8:8%8 8 8 8X888X 8 8;8 8S8.XXS88 8 8 8@8%@%@88@SSSS8XSS8SS88X888S@8X8S8X@SS8XS8888@8SS88888888@8@8@888.X@XX8 88888S88@X88XS888@8 8X8@88 SSSS88 8 8%8 X8 888 SX8S8 8 8 8SS8 %8 8X8XX8X8:8 8 SS88X8 S 8 8 X888@X888X88S
@@X8XXXX@8X8@ S8 SX@8 8%8 8.888%S88 888 8;8%88@ S8S8 XXS8 888 8X@X8S8X8SX8X8 8 8;8 8 8 8@ 888 888S8 S8 888 XS88XXX8 8 S%S 8888@8888X88888XS88888S888S88@888S8X8S@S8S88X@SS8888888888888X8X88S8888@X S8888SS8X8:88@8@888XX8 8 8 888S8 8 888.8 888XS8S8;8 S 888 8S888X8@8 8X8888XS88S8%8SS8%8t8.8 8@8SS 888@8@
@@XX8@8SS8S8S8.S8 @ XXSS8 SS8SX8%8%S 8 X 888 8 8.X8888 8 8 8;8 8X8%@SS8 8 8 888 888 88XS8S 8 8 8 S 8S@8 8 8 88@8XS88.8 8S ;888XS@@S8SXX8888S88@X8S@SS8888SS88888X88888SS8888888X88S88@SSS88@@888@888 8 @S8 XSS888@8 8:8 8 8 888 88888 888 8 @%88@@ 888;8%8.8 88@ S8%88X888 @88S8XS8.8 8 SS88@8 8 XS8S8SX8@8 
@@8XX@%8SS8 S 8 S8;8 8S88@%888XX8 8S8 8 8 8 8 888@88888.X8888X8S@@8S8 SS 888X8 8%8 8 8 X 8 8 S888 8 8%X8.888S8 XS8.88 88@t8888SS888XS8X888S:8XX8X8S@X8S888S88XXS8888@X88888888X@@S@8X888888S88@S8888888SSS8%8 X8 8S@XXX8 8 8 8 8S8X8SS88 888:8 888@@8 X%88X 8 8 8 8 888X8 8 8:8 8S@8 88@S8%8SS888 888 8 8 @@
@@XXSSXX8S@8S88X S8 888 8 888 8X@8 888 888 888 8 8 8@@88S8X8@8%@8SSSX8 88@SXX 888 88@ 8 8 88X 88 888 8 888X X 8%8S8 888@@888@S888SXS8X888S8@S8888S8X88@S8S888SS88X@S888888X88@SS88888888X8X8SSSX@88S%88 8S8888SX8 8 8S8S@S S8 888 8 8X8 X 8 8 8 @8@8%X88888S%8 8 88XS8 @ 8 8 8 88@ @8 8 8S@SXS@8 8 8 8@8 8 8
@@XXX8X8 8SX888 8 X8 8 88XXX 8 8S@8 8 888 8 8 8 888 8 X 8;888%8SS8 8 S 8XS8S8SS8%8 8 S 888 8 8 88@8 888 8888S8 8X8 88888@@@88888@S8S888888S8SX888888888888SX8888@8SS8SXX8888XS888@SX8888X8888S@S8XSXX88%XX8.SS8 X8 8 X 8X8X8SS88 8 888 8 8 888 8 8 8@S%S8SX8 88 888 8:8S8 8S8X8 8 8 X8 8 8 8 8SS%88X8 8.X 8 
@@8X8 8;8 8S8 88888888888 8S8 8 8 X8;X@@SX%X 888;8 8 8 8 8X888S8 XS88%8 8 X8 8 8 888X88X8 8 8 8X8X88 8 @ X@888S8 S8t8888SSX88888S8888888XS88X8X;8@88@@@@XXXX8S@XX@8888888tt@88@@8888888X8SS888S88888X@8888@8%888%@8 8 8 8 8S8 8.X 8S888888888 8 888S8S8SX8XX8S8SX8SX 8 888:8S8SS 8 8 XSX8 888 8S8888%8;8 888
@@XSSS88 8 888@8 X8X8X8SX8 888 X88 S8S8 8%8 888 8 8t8:8;X 8@8@888S8 X88888X@8 8 88 888SX8XSSX8t888S8888@888 888 8S8X88@SS888S88S88@@S@88888 8@S@XXXXX@X@SXXSS8 8S8XS8SX@@XXS@88X8XX8@XSS8:888X8S8888888888tS8888888888 888 S88:8 888S8X8S8S8 888 8 8:S 8S@8SX8X8 8 8 888X%8 8 8S8 88@S8 XS8 X8X8 SX8 S8 8 8 
@@X8888X8X8S88S@8%X8 8 8 XS8SX8S8 8 XS8@@888 8 8 888XX 8%8 8X8S888@8S8 8XX8 X888 8 8X88 8 8 88@X8@8S8X8S8888@@ 8 XS8@88SX8@X8@S8888SS8S888XX8SXXXXXX8 8 8 @X8 8 XS8 8SXXXXX8SXSX88X8SS88888SSS88@XX@X8S888@8S8 8.88SX 8 8 8S8%SX8 8 8 8 8 8 8 8 8 S 8S8;8S@@XS888X88@SX@X8 888.X%8 8 8S888X8 88S8 8 8%SS888 
@@XSX8@X8%S8X@8XX8%@8 8;8 8 8 S88888 8X8S88.@88 888X8S88@ S 8 8X8@@@888 8XX8 88 888 8 8X@8 8 8 8X8@88S@X@8SXX8 88S8888S8@X8@88XS88888.@X88S8 @X8X8 8 8 8 8%8 X 8 8 8 8 8 8 X8 8S@SS@8X88S88S888XSS8S8X8S8S888S8 8S@88X8 888%S8S8SX 8 888 8 888S88@ 888 8@8 88X8X88@8 8 8 888SS88XSX8 S888X8 888 SSSS888 8SX8
@@8@8 8 888S8S@8SS8 XS88X888.8 @ 8X@8 @%8 88S888XX 8 8 8:8S8 XSXXX8@8X@8 8SX8SX8X@88 8S8 888SS8 8X8X@XSXX8 8S88t@8X8SSSX8SS88@8@S88X8@@XXSSS8SXXXS8 888 8 8 8 888 8tXS8 88XS88 8 8SX%X:@X8X888888888S8888888@8%X 8 X8%8888 8 S8S8 888 8 888 @ X@8 8 8 8 8.8 XSS8 8S%8XX8 S8 8 X8888S8%8 X8 X 8 8 88X888888 X
@@XSX8 8 S8 X8%88@S8 8 8 @ S8 88@ 8XX8 8 8SX8 8X88 XSSS88 88@X8 8 8 8X8 8 8 S8%X88X 8 8 8;8 8S888X 8 8S8 8SS8 St88888;88S888888S8XSX@XXXXXXS8 8S8S88@8 8%888S8 8S8 8888X88:8S@8 8 8 8%X8@8X8888XS88S88888S@88888 S8 888S8 S 8 8@ 8 8 8 8 8 X 8S8 8X8 888 8 8 8 8 X8X8S888 X8:8 X8 8 88:8S@8 8t@ 888 888X88XX
@@X8 8 88S88SX8 X8SX8S8 888 XS8 8 8X888 88@S88S8 8S8888X 8 8 888 8 8 X%888 8 888 8S8 888t88XX8X8 8 SXSSS8:8 S8S8@@X@@@88S88X@8888 XXX8 8%8 888 X 8X8X88@8S8 S%8 888 @8 8.8X 8%88888SS8%8 88S88S8S@S88888XS8X888X8 8 SS8S88%888S88S888:8X8%88%%8 8S88888 888 888 @SSXSS8S88 8@X8S@8 8%8X@8 8 88%X 8 8.88@SXSX
@@8 88@ XXSX8  8 8X8 S%8 8 8 88@ 8 8X888XX 8 @XS888 SX888X8 8X8888888%8 8 88@ @8XSS 88X%@%8X8.8@S 8%88X8 X@8 @@SSSS8@8@@8XS8X8@S8X8 8 8 888S8 8 8 888X8 @XS888@88@ 8S8888 8 S8S8S888 SSX8 88@S88S8S8X8XS8S8S8X@.S88@ 8;8 S8S8 8 8 8S88X8 8 88%S88@X8S8@888 8 8 8 8 8S8 8 X8 8S88XS8 8%8 8 S8 S88SS8S8 8 8 8 
@XS8 8 8 888@8 8 X8t8 8;S 88@S8 888 8S8@88 X8 8 8SX8X8S8%888.8X8S8SX 8 8 8 8.8XX8 8 X8 8S8 88@@888S8 8%S8S8:::SS8X8888888t8@@S88SSS8 8t8 8.X8 S888X@S8 8S8S%8 888 8 8SS8 8 8 S8 8S888 8 8S@S8X8S888@X888888888X8 8%88;8 8S8 S8 8 88@ XSS88@ X8SX8 8@8S8X888 S 888 888 S 888SX8 @8XS88@ 88@ 8S8.88 S888 8 888
@@SSX8888X8@8 88X 8@S888S8S8 8X8S8 8 88XSS88 8 888XS8X8888%88@8 8 8S888t8X8 8%8 SX88 SSX888X8 8 S8 SSS8 S8 Xt888X88888@8S8XS88;%XX88XSS8888XS@8 @S8 8 8%8%8 SS 8 888 8SX888:8SS8 8XX 8 8 8S8t8S8S:S@@XXXStSSXX;88@8 SSS888 8 XSS 8 X888@8SX8 888SX8%SXX@@@88 8 8 8 8 8 8 8 8 S8 8 8 8 8 8 8888XS88X88@8 SX8.
@@88888S8XSX88 8 8S8 SXS8;8 88XXXX88@X@8 888SS 88@8 X8@88S888@S8 8 8 8;88@S8%8%8%8 8S8888%8 88@8SS8S88@8 8%888@S88888X88SS8@S88XX8.@88 8 8S8 888XSX8X8S8S8 8 8 X888 S 8%88 8S8 X8 8S888 S 8X8@S8SXS8%@SX@SXS8SXX8SS8 8 88 88@S8 88@X@XX@@8 88.888 S8 8%X8X8 888 S%888 888:XX88 888 888 888 8 X88%XXSXX@8S8S@
@@S%S888%XX8S@8 8 X888X8 888SX8%8S88 8S8888 8 888XX8 88S@X 8.8%S S88@;8 8 888 8@8;888 8SS8X8S8 @8 S8S8 88 888@888X8SSX8888888SX8 @8 88@:8 888S888X8S8 8@8 S 888S8 XX8SS8SX8S8X8S88t8 8 8 8 8X8SX8 8 8%@XSXXXS8 8 8  88@S@8 8.S 88@ 8S8 8 X8 88X@ @S88%8 8 8888 8 8%8 8 8 8S8 8 8S8 X8 S @ 8 888SX8XXX8S@8 8 
@@X888S88SSS8S@8 8 S888%8S8%8 %8S@SS8 8S8 8 SS88S8X@8 X8%8%8@ 8 8 8%SS8 8%%8 8SX88X8 8X8%8XS8S8 8S8:XX8S88 88XX88S88S888S8SX8;SS8SX88888X8X8 8S8 8@8 8S8:8S8 8 @ 8 S 8 88XX8S888 8X 8 SX88@88SXSS8 8 8 8 XX8 8SX8X8 X8 8%88@8S8 8:XS88X@88 @ X8S8 8 8X8 888S%8S 888 888 S 8:SS88@ 8 S8S8t888 8S8 88S8 8 S8 8
@@XSSX8 88SSS8 88X888@S8@8 8t8 SX8 888 8 8 8 8%8X88S@8S8@ 8X@S@8.888%888 8 S8X8 8X8X8X8@8X8SX8XS 8;8 8 8 88S8SX@S8XS8@888S8S88SXXX8%X8X8SS8S@@SS8S@X8 8;8 888 8 8 8 88@ @8SSS8SX8X8S 8S8 8@8 8%8 8 S8 8 8 8 888 @ S888 %8X8SX8;888S8%8 8:8 S8%X8t8 8S8 88@X8 X8 8S88%8 8 888S888@8:8% 888%8 S 8 8 SX%8 8 X8 
@@8XXSX8%X8XSX8X8 X 88X88X@88@888S8S8SS 88888 8S8SX8SS8S8 S888X 8 8 X 8 88@S8SS8 8%8 8X8S@S8@8X8 S8 8 888S888888X88888S@S888S8XXX8:8 SSS@8X8S88%S88@@8.@XS8SS S88888@8 8%X8 8 8 S888S@8 8 X%8 8 88@ X8 S 888 8 88@ X8 8 88@8S88XX 8@888 8 8 S8 8@@8:888%8 @ 8 XSX8 8@88@888 888888X@8 XX%8 8 8 888SX888 8 X8
@@X8 8 88@X8@8 X 8 @ XXSX88@8 8.8 S8X8 8 8 8 888 8S@8SS8X8XXSSX88@ 8 8 8 8 8 8 S8 8 888X8S8X8 XX8 S8 88S 8@8SX88XS8888S888X888@8 8 X8 8 S8 S8 888 888S8 8%S888%88888XSX8S8 888 8S8 X8X88X8 888 88X 8 X8 88@ 8 8 8 8 S8S8%8S@8 88S8 8X8888888 S8S8 8X%8 8 8 8 8 @ S8%8X8S%X88.8 8 8@888 8 S8888@ 8 8 X8 S 8 X
@8 8 S8 88%SSS8 888 8S8 8 8 88 888S8 SS888888 8 X 8S@8X8 S8%8 8 XX8.8 XX88@X X8 X8 888S8 8X888@X88 X8S8S88888S@8888X8S888888@8@8XS8 S X8 8X8 8 888@8 @8 S8 8X8X888SX8 8 8;XS8 888 8 %8S8S88 8 8 8 X 8 S8X8 8888@ 88@ S8 8 8 88 8 8SS8S8888S@8 SX@8S8 S8 8 888 88@ SSS8S8S8 8X 8 8%@S 88S8 88@8 8 88XS888888S
@@8 888S@%XX8 %888888@@8 8 8S88XXS8 8 8 8@88X@ 8 8 8S@8%8 8 SS88%8S8 8 8 888SXX8S88S888 X 8X888S8 8S88S8 8X8SS88S@S88888SS888@@@8 X888S88.888X8 88SS8SS888 @88S8888 X888%8 8 8 8 X88 X8 8 8@@88888%888S8 8 X8 8 8 8 8 X8 S 8SX@X8:8 SXXX%@8S88S8 SS88 XSS 88S8 8 88@ 8@8888%8%88.8S88X8S8888 88X8 8.8 888X8@
@XX8 @ 8 8 888 8888X8@8%S8888 X8 8 88X88 8.@88 S888@8SXXS88@S8 X8S8;X8888X@ 8%8 8 8X8 X88S 8X888SS 8.88S8@888888S8SSX888@X8S8S8XS8 88@S8 8S8@8X8SX8XX88X8%8 S8%88SX8S8 SXS88888 8 888SS8 8X8S8X8S88@8 8 88@ SX8 %8 88@ X8 8 8%8 8XX8 8S8S8 8 XXX8 8 X8 88SS8 SS8888 8S8 8888 8 8@8888 S8S88 8S8%888888 88XSX
@@8;888 888 8 8 @8 8 8;8 8S888 X8X8;8X8 8 8SXS8 @ @ S8%8 8SS8 8 @X88 888S8 8.888 8 8 8 8;8 X8X8 8 888 S8S8S8888888S88888888X8888XS8S8 8SSX8%8S8 8 @8 888 X 8 X8%X8S@888S8 88%8 S 8%8.8SXX8888 8 8S8%88@88888 88@ 88 8 8 SS88SSS8S8 8 S8 88888%8 SS 8 S8 8 88@ 8 8%8X%888X8 XS88S8S8 @8 SXS88% XX8888X88 X88@
@@@X%8 8 8 8 888SS8 8 888 8X@ 8S8 @8 8 888888 88X8 8 8%88;8 X88@X8 88X8SX%8.888 888 888 8%8 888SX88X 8 S8SS88888@S888X8SS88888888SX%8 S8S8.XS8 X 8 8S8 XS88 8 S8 8X8S@X8S8 XS8 8 88 X@8X8X8S8@ 8 8 8S8 X8X8SXS8.8 S888 8S8 8S88XSX8 8S88@8X@ 8:8 8 X8 X888 8 88@.8 8%SS8@S8S8S 8 @@8 X8 8X8%8S8 %X 8 8 8 XX@
@8 8 S8 888S888 8 8% @X888@S@8:888 XSS8S8X8X88:8%88@SS8%8X@8S88 8X8 888@SXX8X8 8 8 8t8 888 8 X8X8 SXS88 88@8XXXSS.8@SSS8@888888@8S8 888S888S8X888S8:S 8 8 8@88SS888 8X8 @X8S888 8 S8X8 8 @88S88SXS88888 SXX8SX 8 8%8 S888 888 8S@88888S8888XX 8 888 8X8 8 8 S%8;8 88X88 8 8 S8 S8X8@8 SS 8@8S888S8%S8 888S8 
@@8 8 X8 8:8 8 8 88@%S8S8S88SX8%8 8S88@ XX@XS@8 8S8 8 88@8SX8 X8SS%8SX@8S8SX8S888 S 8 8t8 8%8 XSS8 8 8S8 88%888S888SS88888X88888888t X8S8SX8X8 888S8 8 88X88 88%8SX8 8 8XS8888 88@ S88S888X%8 88888%8SX8 8SS8 888 S88 XXS8 8 8 8:88SX 8S8 X8%888 8 888 8t8;8%8SSS8 8 SS8 88@:%@8S8X888 8%X8 8S@ 8:8 8 @8 8 8
@XS@ 8 X8;8 8;888S8 8%@88@%X8 8 88:888 8S8 8X8 8 888:8SX@S8S@8%X88S88@@ 8 8SSS8SX888X%88 888%8 8 8888 8X8SXS8888X8SSS8@SSS8888@@88S88XXXS8SS8X8 X8 %88888 XS8%SX%8S@8 S 8S8X888 8 8 S8S8 8 8 8 X8XX8 8SX8 8 S%88X8%8 8 8 88:888S8 8 8 S8 8 8 8XX8 X88 888 888:8 888 8 88@X@@8SS8 X8X888:8 888@8 X8 8 8 SS8  
@@8SX 8 S888 8 8.XX S8 S@S8 8%X8S88S888.8X8.@XS88 8 8S8%8 88%S8 888XSX@8 8SX8%%888X8888X8@XS@X8:8 8 88X8 8S8SX8XS88888S8S@8X8SS8S88@@S88S@88@@@8 S888 8XX8X8SXXX8%8S@8 8:8 8X8S@8 S8 8 8888 8S8 8SX 8 8 SS88S8 8SS8S@8 %8 88X8 8 88@.8 @8 8 8:8 888 X8@8 8%8 X8888S%S8.8%8S8 8SS@SS8X8 X88XX8S@8 X8 888S88@S
@@XX8888 X@S888:8S888X8SSSS888S88SS8S8@8S@88S8 8S8@8X8@8X8 8@ 888SSS8 8S8 8 888X@SSSS8@8X8888S8X 8t8SSXSX 8X8888X88@@888888SS8S8@8888S888@88@8888 %X 8 8SX8X8@S888 8 S888 8 X 8S88888X8S8S88.8X8 8S888 8 8 XX88X8SS8 X8 88 X8 8 8 8 8 8 @8 888 8:@8X8S@ 8 8 8 8X@S8888%X8 8;X888 8 8 @8 8S8 X8SS8%X8S8 @88 8
@@X8.8 S8 8 8XX8.8:88SX8 888 X@8 8  8X8XS8 SX 8 8S888@8S8S8S8SS8 8 8 888 88X X8SXX8888SS8 S@8888 S8 8 8S8XX8SS8%8S8%8X888@S8@8@SSX8S8S@S@888888888 .8@XX8SS8S8 8 S S8 X8 X 8 8 8 8@@88S8%8 88S8S888 8:XS8:8S8%8 88XS8888X@8 X88888XSS8S8 X X8 88XS8 888S8888X8 8 8.SS8X8;88888SX@8%S8S8888 888X8 8 8%S88X 8 
@@SSSX8 S888 8S8@XXS8 8 888 8 88%S8 X8%8  @S8S888X8 X@XXX8@888S88.888 8SS @.8XSXX8 8888%X8S8 8 8 8:S888@@8 @X8S888X8X88@S8S88S888888@SSS8XS@@88@%SXS8888S888.S@ 8 888X8 8 888 8 8%8 888X@@8S8@ 8S8 8 8 8 88888 8 88 X8S8@8 8 888888X8%S88S8 SX8XX8 8 %8X8888@888@X88X888X 8S8@88 888@X88S 8 8 8 8;8:8 @8XS 8
@@888XX8 X8 8;8%8 8SS8X8%8 888 8X88XSSSS8SS8 8 X8 S88SS@8S8@8 8 X8S888@8 8 8S8 8 88 8SX8SS8S@XS88;8 @ 88888 8 8 888S8@88888888888X88X8@:8888888X88888888XS@8S888;t88 88888 8;8@8;8 8SX@888 888888888888 8S8 8X888S@8 88@8 S 888 8 S@88S8 8 8 88@S@88@ XS 8 8 8.8%8 8S888S8 @S8 88 88S8;@8%S%88SS88 X88 @8%8 
@@S 88 X88 888 8 8 8 @ S8 8X8@8 8;XX88X888 8S @ S8XXSX8 888X88@8S%8X8X8 88@XX 8 8S88%@SS8SX8S8 8SXS8:8S@XX88 8 8S@X888@X888@XS888888SS8@X@XX88XSSSS8@X888X88@8888X88@tX8%@8S8SX8X%88888888888S888888@8888@888888X8X88 8SS8S8t8SSX8X8 X@88 S 8 8 8 88 8 8 88@8 8@8SXXXSSSS%8 8 8 88%SSS8 8 8 8S8%8%8X8 8%X88S
@@@8 88XS8 SXS888 888 8 S8:X%8 888 8 8 S8S8:8XS8:S8SX8S8S8 8S8SX8XSXS8%S88 8X888 8 8@S8 8X8 @@8;8 8 X8@ 8@88XX8 8XX8S@S:@@88S@88@88X88XS88888@8888S8888@S88S@8X@X@88X@X@:.8@@8 88X8888888888X8888888888%8888%@8888888888@SX88S8S@@8 8%8S@8S888 X88 @8 888S8S88XX 8S8SXX8 888 8 8 88 8 8%88 8.S 8;XS8 888 X@8
@@X@8SX8 88 8 8 8.X8 88@ @8 8 8 8 888 8 S888 8%88SS8SSX 8 8 8 8%X8 8 X8X8 8 8 8 888S8 X888 8X8 XS88XS8%888 @8X88 8S@S88@XX@88@@XX8X;88888@88S88XX8888S8XX8S888@S8888@S8@XXX8SX8 8 8S88@888888888888888@8888@888888888888X8@88 XX@8@8@8 8SXS88 8 X88 88%@X8%8 88X8 8 8 888 8 888 8SX88@8@%8XS88XX88888XX @S8X
@@8XX8 8S88SX8.888XX8 8 8 SX8 X8;XS8%88XS88 X8888X88@8%88S%8S8 8SSS @ SS88@888:@@@8S 8%8 S8 8 8 8 8 X 8X8 8.S8%X8 8 8S@88888XSS888X888S88@@X8888@S8888S8888888S8S8X @@@8SXSS8S@88@ @ 8S8@8@888X88888X8888X8888@88888888@8888888XS@@X@88 8 8 S8 8 S88%888@ 8 8 8@88 8X8S8 8 8 8S88@S88%8S8 8 888X 8 8:8 8 8 8
@@XXSS888 @8 8XXXS8S88 8 8%88@ S8 8 8 8 8 888888@8888S88888X8888888 S8888SSX8 8 8.@88:888 XS888 8% 8 8 8 @88 S@SS8X8 8S@X@8t8888@8888SX888888X@SS888@X8S888@8888@@X@XSXSXX8 8X8S8@8 8 88S88@S%888@888888@888@8888888888888888888888@8SX8 8 8SX888%XX8%X8 8 8 8X8 88S8%X@888X8 8 8.8 8@ 8 8:8SX8 8;8.888 SS8 
@@XXX88@ 8.X8X8 8S@8XX8 888 8 8 S8 8888888888888888888888X888888888888S8 @8XXX 8 8SX@8X@ 8S8 8 88@SS888 8S888 8S8S8S@@SXXX8SX@8S8X88SS8XS8888XS8@88SSS@@S8X%:@SSX8SSXX8 8S88;8 8%8 8 8%8S8 @8 8 88888@88888888@8@8@8@8@88888X88888888XX88 88@%88 8X8SXSXX8 88%X@8S88 8X8S88XX8 888 8X8 888@88 8 %8 8X888 8;8
@@8XX%X8 S8 SX@8:8 8 8 88@ 8 88@ X888X88888888888888888888888888888888888X8@8 888 888SX8 SS88888 8S8SX 8 8X8@888X888@8@S8%8S@SSX88tS88@88888SSS888S8S8X88@8@88 8%XSXXSS8:8 8XXX 8 888 8 8 8 8SX88@@@888@8@888.@@888@8888888888888888888 SS8 X8 8X 8X88S8 888X8S@X8SX8 8 8%@8%888S8 SS88S8@8 X8X8%S%X8S8SX 8 
@@XX8S8 8 S8S8 S8 88@ S 8 888 8 X8X8888888888888888X888888888888888888888888@8X8 S 8S8%8888X8X88S 888X888 8X8S88@8SXXXSSX8 8 8S8@8S8X@88.%8888888888%@%8@X@88 8 8 8 8 88X 8%8S8S 8 8 8 S 8 8 8 8 XXXX8@X88@88888888@8888888@8@88888888@@8S888 @S8SS8 @@ 88@@8 8S8@8S8888;8 888 SS8888SS8%888 88X8S8 X8 8 8 @
@@X8.8 S 888 S8 @8 8 8 8 8 8 8888X8888888888X888888888888X888888888888X88888888S88 XXX8 S888XXX88@@@8 8%S8 8 8 8888 8 8 8 8XS@8 8 8 8S8SX@S@888@S@8t8@@SXXXSS@ 8 8t8:8 8 8 8 X 8 S8 88@ 8 S 888 8 8 8 XXSS@8@88@88888.@88@8888888@88888888@%8 S8 8S88S8 XX 8 S 8X888S88 XX888 8 888SS8SX8X8@8 8SSX@8S88@@X8 
@@XX8 888 8 8:88 XS8 S88888 88888888888X888@8888888@8@8888888888@8@888888888X888888@8SX8 8 88S8.8 8S8888 8%X8 8X8@@8 888;8%8S8 8 8 8 X 8%8%88X@X88888@8X@XX8 8 88X88SSSXS8888%8:8 8@ 8 8 8@@@%8t8%8X8@;@;8 8t 88888888888@888.888@8@88888S8888 X8;8 X8 8 8%%8%8 8X@X8 @8 8 8 888 8 8 8 8 8X888@8 @ S8S8@8 8S
@@8S%X88X8 SX8888S88@ X8 88888X8SXS@@X@8S88XX@@X 8@8888@88888@8@8@88@888@888888S888S888 8.8%X@SX 8 8S8X@88XS88%@@XS%8 8:X8@888S8@ X 8 8 8 8S@8X88888888888888 8 8 S8X8 8S8@88888888t88%88X8X@X@X@X8XS8@S@X88@888S@X@@XX@888888888888@8X88888888%8X 8 8 8888 8  8 X8SS8 XS88888 8 8 8 S8 X 8X8X888;8 88XXX8.8
@@XX888S8 8%8 8SSS@8 8 X@8@8 XSXXX8 8 8 8S8@SXX8SXXX8S8888 @8888X8888X888@8888@88888888S88S8 8 8 888@88 8SX8 88SSX8 8 88%8X8 88888 888.8X8 8S88888@8@88888888S888888S88.8S8@88888@@X8@@888X88XXSS@S@8XX@@@8@@88@@SXXXXXXX@@X@88888@8@88@888X888XXX888X8 8 SXS8 S8 X8%X8 8 @ 8 888 888 X8 8 8X@@@@8 8 @8 8 8X
@@X8 X8@X88X 8 8 8SX8 @S@XSS8S88@8 S 8 X%8SSXXSS8 8 @88 8@@888@@888888@88@8888888@8888@888888S88XX8S8%8SS8 8S8S8 8 888 S8@8 888SS88 8 8S8 8X8888@8@88 @88888@88888888888 @88t8%8S88XX@@@SS888888888888S8888S8@88@@SXXXX8 8XXS8S8@8888@8@88888888@8.8 8.8t8S88888 8S88X%8:8 888 8 8 8 8 8 8X8SXX8%@8%8SSS88X8
@@SS88@8@8 8 88X8 8 8X@8 8S8 XS8 S88SS8S8SXX8 8 S8@8S8%@SX8@@X@@8888@888 @88@8@88888@88888888S8@8XXS88 8S88;8X888 8 @@X8XX 8S8%8S8 8 888S888888888@888888888888888888SXX8 8 @888:%888888S8XX8S8S8S8S888888S8X888@8XX8 8 8 8%8 8 8S8X88@8@88@888888SS8 X88@8 8 S8X88 88 %8 SS8 8 888 X 888 8 8 8 8 S8 8 8 8S8
@@8SXXXS88@X8X8%88:8X8 XS@88888 8SX88 S8@S8SS88@S8 X8X8 8SXXSXS@@@888@8@8888@88@888888@88888@8888888XX8:8 8X 8X888X8S8%X8S8 8 8 8%X88X888888X888888 88@8@8888888888 XXXSX8 8X@8S@SS@:@8X;8SS888XS8888X8@S88X8SS888@SS888 8 8 8@8 8 8S@X888888888888X 8S8@8%@@8S8%@X8 X8 88 8.S8888 8%8:8 8t8 8 8 8 X8 888 8 
@@XX8 8 S8X8 X 8 8@ 8%8 8S8 S@888@ @88X8%X888 8 X 8S8SS8 8 8S88 88@8@88888@88@8@@@8@88888888888X88888888 8S8 S8X8X@X8 8 8 8X88888888@888888@88@88@888 8888@8@88@@SS8S8 8S8888 8 8 8 8X8.%88888888888S8XS;88888X8@88XS8888S8%8X8 8 8 8 8 8888@8@88888X 8 @ 8X8%XX8@8 8 X8 8 S888 8SS88888 S888 888 8 S 8XXS 8
@@X8SS @%X88S88 8 8% 888 8:8%8@8S@8S8.8 8 8SX8 8 8 8@8 XSSSX8%@8S88 88XX888888@88@88@88 @8888888888888888@88888@888SX88888888X8X@8888888888888@8@8@8888888@8@XXXXXSX%8 S8%8X@8 8%8 8 8 8SX8;888@@X888X8X8XXS88888888 SX8S8 8:8 8.8SXX8X8%8@8888888888X 8 8 @88S8 8XS88 8%S8 S888 8X8X8 8 8:8 888 888X888S8SS
@@XS8%888 X88S8XS888 8 8  8 8 8 8 SSS8S8;8 8 X8t88@X8 8 8S8 S8 8 8 8SXXXXS@8@8@88@888888888@888888888888888888888X@888888@@888S8888888888888X888@888@88@8SXXXX@XX8 8S888XX@8 XS88XS88 8 8SXX@S8SS8888X888@88X88888888X8SX%888%XSX88X8S8 8 @@@X88@88888X 8888SSX@8@8 8S8 888S8S@88 8 8 888 8 8888 X8 8 8 X%8X
@@8SSX88 8X8 8S8 88 8 88@S%888 8 8 8 8 X8 S 8 S8 8 8:XS888 8 8 X8 8 8S8@S8 8X88@88888X88888@88888888888888888X8888888X8888888@88888888888888888X88888888SXXX8 8%8 888 88S8XX8 8 8 8 XXX8X8 8 888SX88888S@88888@8XS888 888%88.8S8 8 8@8 X 8SSXS@88888888888 8888%X888:SS8 @ 88@X8SX8 8 88 888:8 X8 S888 8 8 X
@@XX8S8SXS88SXXS8SX888 8 8 8SX8 S 888 8 X8 88X @8 8 8 8 8 X88.8 XSSSX8X@SX@8SX8X@8@8@888@888888888@8@88@88888888888S@888888X8888X88@88@888 @88.@8888@XXSXX8 8SSSSS88 @S@8.8 SS 8 8 8%8%8SX8 8S@888S8888X8SS88888S8SS8X@8@8 8@@X 8 8S8.8S8 8S8@S8X888888888X8X 8X8SX@8 8 888 8 8%@SSS88 XS8S88XX 88S8S8 8888X
@@X8 8SX8 888X8 S8 88X8 888 8 X8S888 88@ SSS8.8 XSS888%8X8S@@8 8 8888S88%8S@8 XX88888.8888@8X8.8@8@88 888@8@88888888888888@888S888@8@888.888@8888@XXXXX8 8 888S8888S@@8 8X 8 8 8@ 888 888 XSXSX@@8X8X8S88888888S888X88XXX@8X8%8S8888 88@ S 888X8XS88888@888S8S88XX8SS8 8 8 8 X 8 8%@ X8S88@S8S8 8S88888S8X8S
@@SS8 8S88X@SX%8 SX@8 XS8 X%S8 SXX8888%@@8SX8888S8S8 %8X8 8SS%888 S%8S8 8:8 8X8 88XX@S888@888888888@88888@88@8@8888888@88X88888888@88888888@88@X@XX@XSSS8 8S8 888:888XS8S8 X888 S888 8S8 8S8 8 8 8@8SS888XXX88S88XXX88 8S8@8@888%8S8@8XX8S8%8X8S@X@888888 @X@8 @8 88XS@88X8t8S8 888 888 SXS8S 8SS8S8X888 8 X
@@88 8 8 S8 8 8.8 8 S8 888S888%888S8 8X8 S8S8X88888@8 SX88 8 888 88888 XS8 8 8 8 XXXS8@S8888@@88@88@888 88@8@88@888 X88888888888@888@8X88888S8SXX8SS8 8 888 88%@X8 8.8 SSX8 S@@8 88X8 8 8;S 88@ @ 8888SX88888888@SS88;% 8@8S8X8@8 8S@@8 888 XXX8%8%XX@8888@@@X8 X8%X8X888X@8 S 8 8 8 8 8 8 88SS8SS8%8X8 8 8S
@@SSX888%8 8 S 888 888%S8 8 8 8 X8X88 888 S8%8X8X88XX8 8 SS888XX8t8@8@8 8 X 888 8 8 8 8 8S8X88.888888@8888@88@8@8.888888@8888@8X8@@88888@XSS8 88%88%X8 8 8 8 8@S8 8 X 8S8 S8S8 S8%8 X8 888X8 8 8 88@S8t88X8@@@@8888X88SX 8 @S8X@88 8X8 8 8 8 8XXS@8 XX8888@8S8 8SX8 8 8 88  8 888.888SS 888 XX8 8 SSXX@8 XSX
@@X8SS8 888X8S8S8 8 8 @SX888 88@ SXX@8S@@8 8X88;8 X8SX8:8 8 8 8 8X 8X888 8 888 S 8 8 S 8 X 8S@S8888888X8@88888@888@88@8.88888@88888888@XXX8 @8 @8888 X88@ X 8S8 88 8%8:S 8.X888S8SS8 XS8S8 8SXX 8 88@X@88@888S88XXS8S8X88:88 @8S@88 8 X88 8 8 8 8 S@8 88X8@S8 8 8SS8X8 8 888 888XSS8 8888@ 8 88@@8 8 8 XX88X
@@8.8 S8X8X8%@88@8 88@.8 8SX8 8.8%8S8 8S8 8S8 @X 8 8XX 8 888.8X8S8XX8X@@888@8 8 888 8 8 8S8 8@SX@X8888@88@8888@8888@888888@8X888888XXSXX@SS8 88S8@8 8%8 S8 888 8S8X@8 8S888S8 X8X8 S8S888 8S8%8%8X8SSSX8S88@888@S88@@8XS88S8@8 8S888X8%8 XSXX8 8;8 8 8XX8@8SSX 8 8 @ X8 8888SS8 8 8:888.8 8 8S8SSS8 8:8 8 X8
@XXXS8 SX@8%8X8S8 8%8 888 8 8S 8 888.SS8SXS S8 8 8 X88XS8888@8 X8 8S@8S8X88888S8X8 888X8 88@X8@SXXXX8X@888888 888@888.@8888888@X8X8@SXXXS8 8X8S8 8 8 X88 S%88 88@S8%888X88 8.8 8XX8 X888 888 X88@8X@88888XS8888888@88%S@S8@ 8 XX8S8S8 8 8 8S888 8 8 8 8 X8 8888XX888888888 X8@8@@8:X8XX8S8 88X 8%88@ 8 888 8
@@88S@888%X8XSS8;888 8 8;8 88@S 8 8:8 888S88S8%S8:8 X88888 8 88S%SX8 XSSS 8X8%X8 8SS8S@88 8 8%8%XX8 XS%S888.88888888@8888.@XX8SSX8SX8 8S@S8:8X888@XS8%8 8%8 X8@8 @ 8S8X8 X8 S88;8 X8%8 S8 8 8S8 @ 888S88S8S888@X@888@%X@8S8SS88X%@SX%8 S 888 8 888 888 8 8XXSX8X8 8 X8X8SS8 888@8;8 S8 8 X8 XX8 8 XX88@%8 8 
@@SX8%8888X8S8 8XS8 888 888SX 8 X8SS8 S8%8S8 S8 8X @8 8 8 888 88S8SX8 8S8SX@ 8 S8.8 X88X 8 X8XS8 8 8 SS888S888@8X8888@X8X88SXSXXSS8 8 S888 888@8@8S88@@8:888S8 SX8 SX@XS8SS8 88X 8:S8:8 8 S8:8 8S8 @88@@88888S8S88@@@8S8SX 8 @8S8 8XX%8 8 8:XS8 @ 88X 8 8 8 8.X8 8;8SSS%8%X8 X 8 8;88SS 8 S88XSS88S8 XX8 S 8
@@XX@8%8 8 8@88S8SS8 @ 8 8:X88 8 S8 S8% @X888 S8 8 88XS8 8 8 @%S8 8 S SS88X8S%88 888 X8 88@ 8SXS888 8%X%8888@8@8X8888888888SXXX8 8 888S@%8%8 X@@XS8 8S8 8S8@888S8 8 8S8  8 888 8% 8 @8 8 8 88 888 8X@SS88888X88X88X8888XX88 8 XXS8 8 888 888S8 8:8 8 888 8 888XX8SXX8 8 S8 S8S8 8 X888 888S8S8 8 SX88S8 8S8 
@@8@8 8 8 8X8 @X%8S8888SS88S@8S 8 S8888@@8S888 88S8SX8S@8 S 88@ X888 8S8 XX@8 X8S8 S8 8 X8.X8@8 8SS8 8  t@X8X8X@@8X@S888@888X8 8S 8 8 8SSS8 8 8 8 %8:888@8S8S888@@8@ XS8 8888 8 8%S@ @8 888 SS88X8.888S8888X8XXX8888888%8 8X 8%8SS888 88@8 SS888@XX8 S8 888 8 8 X888@8%88@8%X8 88@ 8X@8 8 8X8X8%8S8 S8S8SX88
@@S8.888SSX8 8 8%X8888888SS8 8%888 X8 8@8%S8XX8;8 88XS8SX8 8 8 8 88 888 8 8XS8 X888 X888 SXS88SX 8S888S 8888SSS88XS8888888XX8S8 8 S8SXS888S888 8 8 88@8X8 8@8S8X8%8 8%88888XX8 S 88S8 @8 8 8 888X8@8X8888XSS88888S88%X@ 8S8%8 888 8S88 8SS8 8 8@8 888 88%8 8 8 8 S8@8%S88 X8 S%88S@@X888@8@8X8%S88@8S8 S8 8X
@@SS8S8 8S8SX8 S8 X @XX@888@8 X88 8 X8 XXXXS8SSX @SX8 888S8 888 8S@8 8:@X8 8 S8 8 S8 88 8 8 888 8:8 888 St8X888888t8S88888888X 88@ X8S8 X888XS@8888 X@%8 8@8@XXXXX@8 8 8 SX8S@8 888SS8XX88@88 8 8:888S88XS888SSX88@@.SX8;8X8 8 8 88@XX8 8 SS 8 S 8 @X88 8 888 S 8 X8%@8X 8 S8 8 SXXS8X8X8 @XX@8 8S8%@@8 SX%8
@@88S8 8 8;8 8 S 8 @X8S8 @8 XSX88XX8S@8 8 8 S8888 8 88 8888888.X 8S88 8 8 8;8 88.8 88 88@88@S8 8 S88@8 @ 8St8@S@888888XSX888X8@X8 8 S8 88 XS8@8@8SS8S8 8888S8X8 8X8 8 88@ 8 8 S%88 8 8%8S8X888:888888888S.@XS8S88@@8@X8%8S8 888 8 8 8 X888 8 S8S888SXS8 S8 8 8 888 S@8S8SS8 88S8%8 8 XS8 8X8X8 8 8:8X8 8 8 X
@@SSXX8 S 8 88@88888X 8S8 8 8 8:8 8 8 SX8 S8 8 X8%X8 X8S8X8S@X8 88@ 8@888SS888S8@X8 88X8S88%X 8 8 8 8 8 8@88SSS8XS@88888888@8888X%@8S%888X8 @8%X 8 S8S8X8X88S@%8 8 888 8 888 8 8 SSXSX8 XS8X@X88888XX888S88888SS888;S8 @XSS8.8 S 8 S @8S8 88@ XS@8 8 88@ XS8888S8 8S@S8 8S88S8X888SX8 8 S 8 8 8 S 8 8 88888 
@@X8S8 8 888 8 8888@S888 888 888 8 88@%88@ SS8 888 S8%X8SXS8S8 8 8 8S8 S8S8.@X8X8 S8SS888 8@X8 888 X@8%@XS88S8888S8S@XS888S8@88888 88SX8S8 8 X8S8.8 88S8S8SSSSS888SX8 888 8 S 888 8 @ X8 8 8 88X88SSX88@S8SX8888888XSS8XXX88SX8%888 888 8 X8 8 @ SS8 S8 8 888 8%X8:8 8 X@8 X8S8 88S88XS888888@X88XS88@X8X888
@@8 8 S 88@ X 8:8X@%8X@ 8 8 88@ S 8 8 X88S88888 8S8 S8 888 SSSXX88S8@S8SS8 888S%X88 8@8 8S8%8 8;X 8X8%@XX8Xt@S88S8X8S8S888@8S@8888: X8SSSSS88S@8t888S8 S@SXX8 8 X8X8SS @ 8 8 8 8 8 88X SX8 S:t@8@SSS8X8S888888S8@X8XXXX8 888@8:8 8:8 8 888 X888 8 888 888X SX8 @ 8@@8 8S8.88 8%8 SX%88X 8 8888XS@8S88%XS8X@@
@XS888 8 8 8%888 8 8 X88.8 8 8 8 888 8S8 X 8S8 8 8888S8X8@8 8S8 X8S88XS8SS8@8X8S8 8SSXX8 8 SSS88 8 8tXX8 8SX.8XS88XS88888S88888SX@S88X8 @S8 S8 X@X8SSS8%8 8 888 8.X8@8SS8888@ 888X8S8 8 8X%;S888S888888XSS88@S8S88 8S8 88S8 88SXX 888 8 8 8 88 888%8 888S8X8%8 X8S8S8888 @SS8@8 8S8 X88SX8 8.8 8 S8 8@S8%X8@
@@S8S8 SS88X8 8 8 888 88SS%S888:8 8;8;8S@88.@@888S@%8 X8S@@8:X 8%X8 8 8 8S8 XX@8S@X8 8S8888S8S8 888 8 8 8.8 8;8X8888@S88@88888XS8X8888%8 888 S8 888XSSS88XX888 88@S8SX8 888XX8X8S8 8X88;;8%8@S8S88X@X8X8.888SSS88@8 8 888%88t8 8%8 8 S 888 8 88@8SSX888 8%888X8 SXX8S8XX8XXS8 SS8888S 8888SS8 8S888S8 8 XSS8
@@8:8S8 8 @ SSX8t8 8:8 888888X%8 888 8888 88S8SX%8 XS@SS88XS8 88@S8XS888 @88S8 SX8SS888S8 S88@ S%8 888;88888SX.@8X88888888@X888S88@8888888X@XX88S8X88 888@888 888S@ 8 SX8888 8888;@8%t8%88888SS8888S8888888X8X88X8%8 8 8 8 8X@8 88@.8 8.8 8S888%X8 8.8 X 8S8 88X%8 X8 8 888%8888%8%@8SSSSXSSXS88@8 8X%X8 8 X
@@@8@8 888 8%8 S888 888 X88888 @8 8 8S8 8S8t8@8 8;8 8 8 888 S8 8 8X8S88%8X8 @@8 @S8 S8 S @SX8 8 8;S88 8 8 8%XXX@88XXX88X88888@S8S888XS@8@88S88.88X8S88:8 8 8 X888S8 S888S88@ X%t88SXX8X8@@X8SS88S@S8X88S@8X8888XXS8 888X8S8 8S88 8 S 888 888 SS8SS8SX 8 8 8 8 8 8%8 8S%8SX8S8.X8 S8 XX88@8S8 8 @ 88%8S8 88@ 
@8 8 8888 888 8 S8 8 8 8S8 8 X8 X8 8 8 8 X88%88888XS 88XX888 XX8 S8 8 8X888@8SS8SXX8 SX88 8 S888 8 8%SX8.8 8S8SXXSX8@888S@S8S@888X8SSS8X8888tS88888S%8%88@8 8888X8S8X@888t8@X8X8X@88@X8SSSSS8SXXSS888@S8888@88@X@SS888S8%XXS%8 88 8 8 8 8 888S8SX8%88@X888 888 888S8 8 @8 8 88S88%X88X88 SX88.8 8 88888XXX 8
@@8 8 888@X@SX 8 88 8 888 8 8.S8%S X8 8 8 X88@8X8S8S8;8 8X888X88XSX88XX8 @88X8 S8S8@8X8 8  8S88SX888 @ S8 S 8 8 8S.88S8X8X:8@XX88SS8S88@S888@S88@888@@%8@888888X8888888@88888XX@888SS888888888SS88S@S88888XXXX8 8%8 8 @ 8S8 8 @%888S8X@8 8S8@8X8 XXS8X8%X 888 8 8 8.XX8SSX8 8.8.X88 88888%8SX8 88XS8S8@@8S8 
@XS88@S8X8 8%8 88S8XXS8 SSS%88 X8888 8888XS8 @S8 8%X88@8 8X@@%@8 8 8%@X @S8S8 8 S8S@88%XS8 X8 X8%8S@8:8 X8S8;8 8 8 88888X88SSS8SX8@8@S8X8S888@@8888X8@XX@88888888888888@@8@SSS88S8SS8SXX8@88SSS8SSS8SS888:@X8S88 888 8 8 888;8;8%88888X8XX8S@XSX8S8%X8%8%8;8S@ 888 8S8 8 88@ 888 X88X8 8 8 8 888SXX@XSSS%888
@@8 8 8 8 X 888 S@88XS88S8 8 X8X@S%S 8 8X@8 8 8 8t8X8X@88XS8S8SX8 88@X8SX8 888X8 888X 8SX888X8 8@888XS 8 8 S8 8 8 8 8X;8@SSS8X8SS8@S8:8888X888X8X888S88888888@X888@888S88888888S8888S888888SS8XXSS.888X S@XX@8S88 8 S 888 8 8:8@8@8S@8 8888@8 8SS8%8 8X 8 8 8 88@ 888.X8888 8 8;8 @8 S@8 S8888 8 8X8@S8 8 8 
@XS8 8 888%8 8 8%8 XS8.8@8SX8 S8S8S8S88;8 SS88X S8 8 8 8X8SXXS8S@8 8 8 8%88@8SSS8 X8X8 8S8 XSX8X8 X8S8 8 8 8;888 8 8S8 8888X8XS8S888@888X88@@X8888@S8SX8S8S888S@8S@8S8S8S8X888@8S888SXX8@SS8X8X8S8SS888@XSXSS@8 8 S8 8 8 8 S 8X8X8%8 @8 8:8 S8 8SX8S8S8S8X88.8X8 8 8 8 8 8.88 88 8S@8%888 %888SS888X@S888 8%
@@8;8 8X88888 888 8 888%8 8S888S8@8%8 8X 8%8 8S@ S8 S 8 8X8S8 S8 X8 8 S@8 X8 8 SS8XXXS8 88888X 8:8 XS888 88%S88 8X8 XS8S@S88X88@8888SX8S8888@8SXXS8X8888X8888SSS8@8S888888888X8888@S8S8@SS88@X888;8@@@XS@XX8 8 88@ S888 88@ 888 888X8 8 8@X8S@8 8@8.SX 8X8 88%8 888 8 88@ 8S888X@ 8S88@8 8S@SSX88X 8 8 8 8 8
@@@8 S 8X8S8888XX XSX8 8 8;8 8888 S%X8X8SS8 8 8;8 X8%8 88X @ 8:X8%SS88X8 8 @8 8%8 8 8 S8X8 888% 8 8 8 8.8 %88SX8S8S8S8 8 8X8 888S8@SS88XSX8888XS888@SS88XX88SS8XX@88X8S8X888@@X88S8X8888888888;@XX8SXX@SX8 8 888XX@ X8 8 8 8 8 8X8S8X%8888S88XX8%@X8 8SS8 8 8888 8 88@ 8 S 8 S8X8 S888 8SS8SX8S 8 8 888.888;
@8 X88 X8 8S8XX888 @ 8 88 88X @888 8 SS@8 S888 8.8 8 S8S8S8S88@ X888S%8 8 888888 88@:88 8%8S8 8 8 888@:888SXX8 8 X888S8X8 8 8S888t88X8888888@X8X8@S8@8888888S8888888XS88888XSS888888S88888%:8@XX8SSXX8 8S88 8 8 8S 8 S%S8 888 8 8@8S88X 8 8 88%X8@8 88@%88 8S8X888XS8 8 8 88@%X8 8 X88SS8 8S8%8 8 8888 8 8 @
@@8 888 8%S8 8 X@8SS8.8 8XX8 8X8S8SS8S8 S8 88 X 8:88@S8 X8%S8%X88SS8 8 8 888 8SX8 8:XS88%8 8 888888 8 8 8;8 8 8 8S8 8 @ XSX8 8@8 8X@88.S8@@SX8X888S8S88XX88S:8@XS888@88@@SS888@@X88S8t88@XXXXXSXSXX8 8 S8S8X 8 8 8 X88@ 88 8 88@@8@8@8S8 8 8XX8SSX@8 8 8SX888 8S8 8 88@8.8 8.8 8 88X8 8 8 X8X8.88@X8 8@S8 8 
@XX8 8S8.8 SS@8S8 8 8XS8 8 8 8 8%S8 S8:8 888@8S8 X8@X888%88 88 8S8 8SS888 8 8 8 S8:8 XS8SX8 88X 8 X8 888SX 88888 8S88 X8 8 S8@8S@X8S8 8@S@88%8888S8888S8S8888S88SX888888S88X888X888XXX@XXX8 8XXXXX8SX88SX8%8SSSS%88 X8 8 S 888S@8X888X8 888 8 8 8S8S@8 %8 8%@8 8 8t8X8 8@@8 S88 8 8SX8 88@ SX8888 8%8%8 88 8
@@88S8X8XX8 @ S@88X8S8 88888888.8 X8 @8 888X8S888 8888SX8 88 8 SSS888 88 8 8 S @8%S @88S8 S8S8%X @SS8.8 8S8:8 8 8 8 8S%8888%8XSX8 88%8S8X8S@S@@88888:8t8XXXSX88888SS;;88;88888XSXXX@XXXX8 @8@SX8 8 X8.88 8888 888 S8 S8 8 8 8 8S@XXXX@88 8 8 8 8 @88%888S8 8S@8 888SX@8@8 X8SS8@@8X8 XS8 8S8X8X888XS8 S8 S%X
@@%8X8 8888%S8S8@8.S8 8SS8888S8S 8 88 XS8SXX@8S888%@888SX8 88@888888@8XX888:8%888%8 S888@@8S8 8 8 8 8XX888.8X8:X 8 88@S8 888 8 8 8 8SX@X8@SSXX8%X@@@S@ @X8SSXXXX8SSXXS8SX8S@XXX8 8SXSXX8 8 8%8 8% 8 88:88S8 8  8 88@8 8888888S@8S8 8 8XX8 888 88XX8@8 X8 X8 8S888SX88XX8 8 88888 88S8 8 888 8 X8@8 888 @8S8 
@8 8 88 8XS8 8 8 88 888@ S 88888 X8 8S8S%8%8 X8X@@8 8X88SX8S8 @XSSX8 X8 8%SS888X@S88 S8S8 X8 888.88@S8 8SX8S8:8%888 8.S 8 8;8 8 888 XX8@8SXX8 XXXX8S@S8S8 @X@XSXS8 8S8 8 XXXX8 8SSXX8 8 8 8S8X88@%S8 88 XS88X888@88  @88%8 88888X88.8 8S@8S8 S 8 8X888 S8%SX8S8SX8SXX8 XX88 @8XXXX8 SS888X8 S8 S8%8 8 8 XX@8
@@8 8%8888SX8 88XS88 8SX888 @8SX8 8%S8 8 SS@8S@8S8 8 8S@8%S8S8S8 8 X@SSSX8S8 8 8 8:88SX8 8S88X@ 8 8 8 888XS8SXXS88 X88%888 XS88@ 8 8 8 8:88 88X8 8%XSXS8:8 8 8@SSS8 8 8 8 8 8 8 8 8 S8 88@X8S888 8 88 88888SXS888SS8 8888S8 X8SX8 8@XX8S8 S@8S8 8 8X888 S8S888.8 @8 8 8 8 S8 XX8X8 8 888 888 8 8  S 8 X8 @ S
@XX888X8SX8S8888 8 8888%SXX8 X8 S888S8 8 8S8 8 8 88 @@8S@8S@8@S8S @ 88888X888@8@88@88@8 X8%SS8S888 888.8%8SX8S888S8X8 888 8 8 8 888 888 8 @8 8@88 8 8 8%X88 8S88 8 8 8 S 8 8 S 888 888 S8SXS8X8XS88 88 8@X@888S 8XX @S8S8X88SS8SS8X8S8.88@X8 8 888 8X888%@8 88SX8SS8X8:8:8 888X88888X%S88 8 88@:8%8 888S8 8 
@@8S8 8 8S@888X 8 8S8X88XXS8SXX88@@ 8 88@:X 8 8 8 888X 8S@8@8XX 8 88 @X 8X8@8X8SS8 @8SS8 888@8888SX8S@8%@S8SS8X8888 888 %88888 8 8 8 8.X @SS8%8%88 X 888@8 8 8XX8 888S8 888 8 88@ 8 8 8 SX88 8S8X@ 8 88 8S8 8S8%888@@8 8S8 88%S8%S8 X 8 8 X 888%8 8.8S@@@SS8 8X8:8 8888S8 8 8888X8@8S8%8 8;8 8:88@88SS8%S888
@@SXX8 88@SX8 8 888@ 8%88SX 8 8S88 8;8 8t8S888%8X8%S8XX 8X@8 8 8 8 S8X8SSSS8;8X8 S8 X8 X8 X8X8@8.8%X@XS8 8 8S8 S88.8 8@8 8S88 88@ 888 8 8 888S88S88 8t8 8 888 8 X888S88@ 8 S 888 888 S88S8 XX8 8 8 88888 8 88888 @8@8;8 8 8 X8 8 8 8S888:8S8S8 XXS88XSXS8 888 XSX 8 X88XS8%8SX@ 8 8:X@8 X88 88@S88888SS8 88 
@8%8 8 8XX8 XSX8X8@8XX8 @8 888 8 XS88@X 8 8 8:8X8 8 88S8;8S8@XX888X8 888 8 88S8 8 8%X88 X8 8 8 8888 88 XX8 S8 8S8@8 8S888@8%S8S8 8 8 88@:8%8 8 X8 X888S8 8SXSX @8S8 8S8@8S8 88@ 8 8 8S8 X 8 888 888:8X888 8S88XS8S@8%X88XS88S88@8 8 8 8:8 888 8S8 8X88 888%X 8 8S888 8%XS88 8 8 8SX8X888X8.8 8S@S@88%8SX8S@8
@X8 888 8 8888X 8 X 8S@8 8 88 8 8 8 @X8 8% 8 8 8S@X8 8 8X 8X8S8 8 88@X888S8 88 888.8X8 8 S888 @88 8S88XSS88%S8;8@8XS 8X8@8 8SS8X888X8S8 888 S @SX88S8 888 8S8 888 8888S@8888@8 8 888 8S@88 8S@SSS8 @@@@@88 8 88SS8SX8X8SS8 S8S8S88@888:888%8 888 8 8SX8S8 8 88@ X88 8 8 8 8SXS88 88S8%888SXSSX8S88 8 888S8 X
@XS8 8 888@8SSX8:8S@ 8S88.8 8 S8%S 8 X88.8S888@ 8 8 88XS8SS8 @88888SX8X@ 888SX8 8:8 8 S @%8XX8:XS8 8 SX8 88@ 8X88%8S8;888S@XX8@8:X8SX8XS8S@8S8;8SS8SX8 8 X 8 S 8 @@8 XX@88X8SXS8888 8 88S88X8 88888SSX8X@ 888SXX@X8 XSS888SSS8:8%8X88 XX8 X8 S8 888 8 SS8  8 8 8S8SXSS8888 8 8 S8 8 S8S@@8S8S8 8 8XS8SS8 S8 
@@88S88S8X8X8S8 X@8 8 8 8@8SS8 X8%888 88@ 8 88X8 888 8 X 8%@888S8 8 8 8%8@@@8 X8.@888 8 S8:8 8 8 S888S888 8:8X8 @8 8 8X888S88@@S8 S8X8S88@ XX88@8 X8S%S 8 88@ 8 8 XX8%8 S%8 8 8 8X@8 8SX8 88@8 88888 8 8S8 8%8 8S888 8 8XS8 8 8@8%8 88 8 88 888 88 8 8%88@SS88X8X88S8 8 X88 88@S8S8888@8 XX 8;XS8S8 88 88SS8
@@%8S@8@ 8SX 8 8X8S8X8S8S8 8888X 8t8%8.8 88XSXXS8 8SXS8 8 8 X@ 8%88@SSXXX8@@ @ 88 8X8888 88 8 88X8S8 @88.X 8 X88SS 888X8SS@X8S8@ 8 8 X8 8 8 8 @ S8 888X888 8 888 8 8 888S8 88888 8X@8 8 888%8 8.8X8 888 888 8 8 8X8@888@8 88 8X888X8 8S 8 8 8 S8 XXS S%88 8 X8%8X8 8:8 8X8 SS8 8 888 8 S8%8 S8 8%SS8SX8 888S
@8 8X8%8S888XSX8@ 8S@88X8 X88 XXS88 XX8t8 8 8 8 S888%888 S @S8 XS8SX8S888SX@8.8 8@@8 88 8 S888 8 8 X8S8@8 888%XSX8%88SXS8 8 %8X888XS8SS8.888X8:8 88 888 8SXX 8S8 S8 8 8 8 8S8@888 8SX8 8 @@8 888 8 8;8 8 8 8 888 8X8S8S888S8X@8S8%SS8:88XX%88X X8 88888S@8 8 XX 8 8%X8S8S888S88X8 8 X88 X888%S8 8 8 8 888S8X
@@8 8SX 8 S888X88@ 8S8X8.8X8 8 8%888SX@8 8 888%8 8888S8%8 888:8 88X SX 8S88SXX88X8X88 8 S888 S% 88@  8X888 8 8X8888 8@SSS8 8SS8 S8X8.8 88 88S 8 8 88X888 8 8 888 8888@%8 S 8 8X888 8 X8 8X8 8 8S888t8 888.888 8tXS8% S8S@ 8S8%@XS8 888 8X88S8 8 S8S8%X 8 88X8X8SSS88S8SX8 S8 8 888.88X @ SX88888SS 888 8X@%8
@XS888 8 8SX888 XX8;8 @ 8 8 S 88@X888X8 88@@@ 8 8X8X88 S8888 S88 8 8X8%S8 88SX 8888 88 8%%X 8 8 88S8 S8S8 8 8 8S8S88 8 8 SS8S8 8 8 8 X8 88:88 8 88S888@ 8 888S8 8t8 8 88@ 888 8X888 8 X8 8 8 8 8 8:8 888 8 8.X 8 8 8 888 8 8@8S8S88%8XX 8:8%8XX8 @S8 8 S8%8 888888%S8 8 S8 SS 8 @;XS8%8 8S8 X8X88X8S8 X 8S@S
@@8 8 888 888S88 8.@88 8 S 8 8 8 8X8@8XS88S8S8 88@ 8 X8X88@@S8.8X888@@8 8S@S8%888 8S88XX88XS 888 SS@8 X8%XS8S8:X 8%X8 888S888 8 888 8 S8 88 XS88 SXS@8%8 88888@X 8 8 8 8 8 8 X 8X8 8 8 X8 8888888.888%8 888 8 888 S88S888 8SXSS@8 8@S8%8 SS8X8 8 S8.88@ SS@8X8%S888SX8t8SX8 8 88;8 8.888 8S8 XX%8%X888 8 8 8
@XS8 8 8.8:XX8 8 S88X%8 8 88888 8.8X8SX8 8 8 X8 8 8 8 S8S88SX88 8%8S8%X8;8@8 8 XS8 8 88@888 8 8 8 8SS8 88888@XX8 S8 8%SX 8;8 8t8.8 88@ X8SX8 8 88@8888%88;8X888 888.888 888 8 8 8%8 8%8 X8S8%8X8 8 8;SXX 8 88@.8%88XX8S888 8 8X8.8 8 8 888S8@S888 X8%8 8 8 88888S8 8 S8 8 S 88S88 888%8 888S8 8SS8%8 SX8 XSS]]

--[[@@@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8
@888X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8
@@8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 
@XS8 8 @S8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
@@SXSX8%8@8SXXS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888.
@@8S8%X8X8%@XX@8X8X8 8 8S8%8.XS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.X
@@XSX8 S8 @8 8 X@88@8 X 8 888S88@.XS8:8S@888X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8%
@@X8:S8SS8SX888 8 8%X8S8 8%8 8S888S8S8 88SX8 888 8%888 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX8SX
@@X@8%X8XX8S88 8 8X8 XX88 8 X 8S888@8 8 @8SSS 8 8 S88.8S8SS@8 8X8SX88 8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 888 
@@8SS8 88SX8%8S 8S888S8 SS8888X8S8@8 X88 @8 8 X888 8%S@8X88 88@8 8 888X8 8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 8 8.@
@@XXXS8SS8 @8 8 888 SXX8S888:8 S8X@@8S8@8%88.8 S8 888X8@8 @8 8S@88@ @8 S88888%8t8 888 S 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 888 8 
@@X8SX888 8 8 SS8XX88@8 888 X 8S@8X8 8S8 8 8X 8 88.8 8 8:8 8 X8 8X@8S88 @ 8 SS88 8 8:8%888 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 8 8 8X8
@@XX8 8 X8 88@ 8X8S@SSS8XX 8 8 8%X8SSX8SXX8 8 88S8X 8 8 SX888 SXX8SS8S@8.8 8 8 X8 888 8 8.S 8 8 888 8S@ 8 888 8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 888:8X8 
@@8SSS88 8 XX 8:8 8 8%8.8 8 888 8 X8S@@8S8X88@ S@88@X888S8S@ 8S888X8 8 8SSX 888 X XXS888 8 88@ 8 8S888 888 8SS8@ 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 8 @X8 8
@@XXX@8X8 8 8 88X8S@8 8888 88@ S @%X8S8 8X888 8%8 8888S@8S8 8 888 8 X888888S88 8 8 8 88 X88 8 888 8 8 8 8 8 8S8.S 8%8:8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8X8@8 8 
@@X8 88 XSS888S88X8%X888 X8 8.8S888S@8SSX8S888@8 888 X8X88 888X@88 8S8 8 X88@8%S888 8S888X 8 888S888 888 S 888.8S8 888 888@8:X 8@8 888S88X8SSXSS88S888 8@8 8%8@8S@S888 %88X8:X 8@8 888S88X8SS8 888 S 8;8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@888888X8 8 X 8
@@8 8SX8S8 8SXXS8 S8%S888 88 888@8 8 X8S8 8X8X8@8S888 X8SX@@8 8S8SS 8:XX8%X8SX8 88 S 8 S88@X8.8 8 8 888 8 888 X8888 8 8X8S8 8S8 8 8X888S8 S888 @t.t;8;8XXSXX8S8%8S8X8t%8t8:X8@@@S88X@88S8 S8 S8.8@8S8SS@S88X@ 8 888 88888@8@8SXS88@8 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@@SXSX 8 8 
@XS8 8S88@8:8%8 8S8 88 XX8S88X888@%@8 XSSX 8 8X8 8S888 S8X8 888X 8 8 8 8 8SS8SS8SX888@8X%8X88SX888.8 8 888 8 8X8@8 8 8S8 8 8 88XS88@S88t88;888t8XX%XS8X8@8@888@8%8S@XX%S88S888888%8 88XX 8.S8 88@X 8t8 8 8 8 X 8 8 8 XS@88XSXXX8:@8@8 8:8 S888S8 8 8XX8 X8SX8X8S8 S8%8 8 8 8XX8 X8SX8X8S8 S8%8 8 8 8 88888X8
@@SS S8 8 8@88%8 X88S8@8XX8 8888S8S8 8 8S8S%XS8 X 8X888S@8 8S8X8 S8 888 8S8 S8SX8 X88@88 8 S8888XXSS888 8 X@8 8 8 8 8XX%8 888 XXS8 8888t8X888888@8888@8888@88@8888888888X88@888tS8@%8888@ 8 X8 X8S8 XS8:8 X88 888 X 8 8@8 8 8 888 8%X8 8 8%8 S@S8X8 8XX8S@8SX@X@@8 S8X8 888 8XX8S@8SX@X@@8 S8X8 888 8 8888@8
@@8888SS @X8%@88@S8@8SXX8 8 8 8 8 8 888:888S8 S8 8 8X8@8 8X 8 @@8 X8S8 88888 8S8 8%S88888 8 X8SX88S8SX88 8X8SXX8X888 8 8 888 8 8@%%888888X@88S@888SS88@X@88888888@S88S888@88X8X8X8@88888@X88XX8%X8;8S8S8 88X 8 8 8 88@ 8 888XSS8.8 8 X%S SS88S8%8S88 8SS8 XSX8 8 S8 88X@88 8 8 S@S8 8 8S8 8%8SX8S8 888 SS8X8
@@S%S8S8 S8 8 8S@8 8X8XSS88@ 8 8 888 8S8 8 X 8.88 S%8X@XXXX8 8X8@8 S8SSX8X8@8 888:8%X8X8:8%8 8 8 8X888X 8 8;8 8S8.XXS88 8 8 8@8%@%@88@SSSS8XSS8SS88X888S@8X8S8X@SS8XS8888@8SS88888888@8@8@888.X@XX8 88888S88@X88XS888@8 8X8@88 SSSS88 8 8%8 X8 888 SX8S8 8 8 8SS8 %8 8X8XX8X8:8 8 SS88X8 S 8 8 X888@X888X88S
@@X8XXXX@8X8@ S8 SX@8 8%8 8.888%S88 888 8;8%88@ S8S8 XXS8 888 8X@X8S8X8SX8X8 8 8;8 8 8 8@ 888 888S8 S8 888 XS88XXX8 8 S%S 8888@8888X88888XS88888S888S88@888S8X8S@S8S88X@SS8888888888888X8X88S8888@X S8888SS8X8:88@8@888XX8 8 8 888S8 8 888.8 888XS8S8;8 S 888 8S888X8@8 8X8888XS88S8%8SS8%8t8.8 8@8SS 888@8@
@@XX8@8SS8S8S8.S8 @ XXSS8 SS8SX8%8%S 8 X 888 8 8.X8888 8 8 8;8 8X8%@SS8 8 8 888 888 88XS8S 8 8 8 S 8S@8 8 8 88@8XS88.8 8S ;888XS@@S8SXX8888S88@X8S@SS8888SS88888X88888SS8888888X88S88@SSS88@@888@888 8 @S8 XSS888@8 8:8 8 8 888 88888 888 8 @%88@@ 888;8%8.8 88@ S8%88X888 @88S8XS8.8 8 SS88@8 8 XS8S8SX8@8 
@@8XX@%8SS8 S 8 S8;8 8S88@%888XX8 8S8 8 8 8 8 888@88888.X8888X8S@@8S8 SS 888X8 8%8 8 8 X 8 8 S888 8 8%X8.888S8 XS8.88 88@t8888SS888XS8X888S:8XX8X8S@X8S888S88XXS8888@X88888888X@@S@8X888888S88@S8888888SSS8%8 X8 8S@XXX8 8 8 8 8S8X8SS88 888:8 888@@8 X%88X 8 8 8 8 888X8 8 8:8 8S@8 88@S8%8SS888 888 8 8 @@
@@XXSSXX8S@8S88X S8 888 8 888 8X@8 888 888 888 8 8 8@@88S8X8@8%@8SSSX8 88@SXX 888 88@ 8 8 88X 88 888 8 888X X 8%8S8 888@@888@S888SXS8X888S8@S8888S8X88@S8S888SS88X@S888888X88@SS88888888X8X8SSSX@88S%88 8S8888SX8 8 8S8S@S S8 888 8 8X8 X 8 8 8 @8@8%X88888S%8 8 88XS8 @ 8 8 8 88@ @8 8 8S@SXS@8 8 8 8@8 8 8
@@XXX8X8 8SX888 8 X8 8 88XXX 8 8S@8 8 888 8 8 8 888 8 X 8;888%8SS8 8 S 8XS8S8SS8%8 8 S 888 8 8 88@8 888 8888S8 8X8 88888@@@88888@S8S888888S8SX888888888888SX8888@8SS8SXX8888XS888@SX8888X8888S@S8XSXX88%XX8.SS8 X8 8 X 8X8X8SS88 8 888 8 8 888 8 8 8@S%S8SX8 88 888 8:8S8 8S8X8 8 8 X8 8 8 8 8SS%88X8 8.X 8 
@@8X8 8;8 8S8 88888888888 8S8 8 8 X8;X@@SX%X 888;8 8 8 8 8X888S8 XS88%8 8 X8 8 8 888X88X8 8 8 8X8X88 8 @ X@888S8 S8t8888SSX88888S8888888XS88X8X;8@88@@@@XXXX8S@XX@8888888tt@88@@8888888X8SS888S88888X@8888@8%888%@8 8 8 8 8S8 8.X 8S888888888 8 888S8S8SX8XX8S8SX8SX 8 888:8S8SS 8 8 XSX8 888 8S8888%8;8 888
@@XSSS88 8 888@8 X8X8X8SX8 888 X88 S8S8 8%8 888 8 8t8:8;X 8@8@888S8 X88888X@8 8 88 888SX8XSSX8t888S8888@888 888 8S8X88@SS888S88S88@@S@88888 8@S@XXXXX@X@SXXSS8 8S8XS8SX@@XXS@88X8XX8@XSS8:888X8S8888888888tS8888888888 888 S88:8 888S8X8S8S8 888 8 8:S 8S@8SX8X8 8 8 888X%8 8 8S8 88@S8 XS8 X8X8 SX8 S8 8 8 
@@X8888X8X8S88S@8%X8 8 8 XS8SX8S8 8 XS8@@888 8 8 888XX 8%8 8X8S888@8S8 8XX8 X888 8 8X88 8 8 88@X8@8S8X8S8888@@ 8 XS8@88SX8@X8@S8888SS8S888XX8SXXXXXX8 8 8 @X8 8 XS8 8SXXXXX8SXSX88X8SS88888SSS88@XX@X8S888@8S8 8.88SX 8 8 8S8%SX8 8 8 8 8 8 8 8 8 S 8S8;8S@@XS888X88@SX@X8 888.X%8 8 8S888X8 88S8 8 8%SS888 
@@XSX8@X8%S8X@8XX8%@8 8;8 8 8 S88888 8X8S88.@88 888X8S88@ S 8 8X8@@@888 8XX8 88 888 8 8X@8 8 8 8X8@88S@X@8SXX8 88S8888S8@X8@88XS88888.@X88S8 @X8X8 8 8 8 8%8 X 8 8 8 8 8 8 X8 8S@SS@8X88S88S888XSS8S8X8S8S888S8 8S@88X8 888%S8S8SX 8 888 8 888S88@ 888 8@8 88X8X88@8 8 8 888SS88XSX8 S888X8 888 SSSS888 8SX8
@@8@8 8 888S8S@8SS8 XS88X888.8 @ 8X@8 @%8 88S888XX 8 8 8:8S8 XSXXX8@8X@8 8SX8SX8X@88 8S8 888SS8 8X8X@XSXX8 8S88t@8X8SSSX8SS88@8@S88X8@@XXSSS8SXXXS8 888 8 8 8 888 8tXS8 88XS88 8 8SX%X:@X8X888888888S8888888@8%X 8 X8%8888 8 S8S8 888 8 888 @ X@8 8 8 8 8.8 XSS8 8S%8XX8 S8 8 X8888S8%8 X8 X 8 8 88X888888 X
@@XSX8 8 S8 X8%88@S8 8 8 @ S8 88@ 8XX8 8 8SX8 8X88 XSSS88 88@X8 8 8 8X8 8 8 S8%X88X 8 8 8;8 8S888X 8 8S8 8SS8 St88888;88S888888S8XSX@XXXXXXS8 8S8S88@8 8%888S8 8S8 8888X88:8S@8 8 8 8%X8@8X8888XS88S88888S@88888 S8 888S8 S 8 8@ 8 8 8 8 8 X 8S8 8X8 888 8 8 8 8 X8X8S888 X8:8 X8 8 88:8S@8 8t@ 888 888X88XX
@@X8 8 88S88SX8 X8SX8S8 888 XS8 8 8X888 88@S88S8 8S8888X 8 8 888 8 8 X%888 8 888 8S8 888t88XX8X8 8 SXSSS8:8 S8S8@@X@@@88S88X@8888 XXX8 8%8 888 X 8X8X88@8S8 S%8 888 @8 8.8X 8%88888SS8%8 88S88S8S@S88888XS8X888X8 8 SS8S88%888S88S888:8X8%88%%8 8S88888 888 888 @SSXSS8S88 8@X8S@8 8%8X@8 8 88%X 8 8.88@SXSX
@@8 88@ XXSX8  8 8X8 S%8 8 8 88@ 8 8X888XX 8 @XS888 SX888X8 8X8888888%8 8 88@ @8XSS 88X%@%8X8.8@S 8%88X8 X@8 @@SSSS8@8@@8XS8X8@S8X8 8 8 888S8 8 8 888X8 @XS888@88@ 8S8888 8 S8S8S888 SSX8 88@S88S8S8X8XS8S8S8X@.S88@ 8;8 S8S8 8 8 8S88X8 8 88%S88@X8S8@888 8 8 8 8 8S8 8 X8 8S88XS8 8%8 8 S8 S88SS8S8 8 8 8 
@XS8 8 8 888@8 8 X8t8 8;S 88@S8 888 8S8@88 X8 8 8SX8X8S8%888.8X8S8SX 8 8 8 8.8XX8 8 X8 8S8 88@@888S8 8%S8S8:::SS8X8888888t8@@S88SSS8 8t8 8.X8 S888X@S8 8S8S%8 888 8 8SS8 8 8 S8 8S888 8 8S@S8X8S888@X888888888X8 8%88;8 8S8 S8 8 88@ XSS88@ X8SX8 8@8S8X888 S 888 888 S 888SX8 @8XS88@ 88@ 8S8.88 S888 8 888
@@SSX8888X8@8 88X 8@S888S8S8 8X8S8 8 88XSS88 8 888XS8X8888%88@8 8 8S888t8X8 8%8 SX88 SSX888X8 8 S8 SSS8 S8 Xt888X88888@8S8XS88;%XX88XSS8888XS@8 @S8 8 8%8%8 SS 8 888 8SX888:8SS8 8XX 8 8 8S8t8S8S:S@@XXXStSSXX;88@8 SSS888 8 XSS 8 X888@8SX8 888SX8%SXX@@@88 8 8 8 8 8 8 8 8 S8 8 8 8 8 8 8888XS88X88@8 SX8.
@@88888S8XSX88 8 8S8 SXS8;8 88XXXX88@X@8 888SS 88@8 X8@88S888@S8 8 8 8;88@S8%8%8%8 8S8888%8 88@8SS8S88@8 8%888@S88888X88SS8@S88XX8.@88 8 8S8 888XSX8X8S8S8 8 8 X888 S 8%88 8S8 X8 8S888 S 8X8@S8SXS8%@SX@SXS8SXX8SS8 8 88 88@S8 88@X@XX@@8 88.888 S8 8%X8X8 888 S%888 888:XX88 888 888 888 8 X88%XXSXX@8S8S@
@@S%S888%XX8S@8 8 X888X8 888SX8%8S88 8S8888 8 888XX8 88S@X 8.8%S S88@;8 8 888 8@8;888 8SS8X8S8 @8 S8S8 88 888@888X8SSX8888888SX8 @8 88@:8 888S888X8S8 8@8 S 888S8 XX8SS8SX8S8X8S88t8 8 8 8 8X8SX8 8 8%@XSXXXS8 8 8  88@S@8 8.S 88@ 8S8 8 X8 88X@ @S88%8 8 8888 8 8%8 8 8 8S8 8 8S8 X8 S @ 8 888SX8XXX8S@8 8 
@@X888S88SSS8S@8 8 S888%8S8%8 %8S@SS8 8S8 8 SS88S8X@8 X8%8%8@ 8 8 8%SS8 8%%8 8SX88X8 8X8%8XS8S8 8S8:XX8S88 88XX88S88S888S8SX8;SS8SX88888X8X8 8S8 8@8 8S8:8S8 8 @ 8 S 8 88XX8S888 8X 8 SX88@88SXSS8 8 8 8 XX8 8SX8X8 X8 8%88@8S8 8:XS88X@88 @ X8S8 8 8X8 888S%8S 888 888 S 8:SS88@ 8 S8S8t888 8S8 88S8 8 S8 8
@@XSSX8 88SSS8 88X888@S8@8 8t8 SX8 888 8 8 8 8%8X88S@8S8@ 8X@S@8.888%888 8 S8X8 8X8X8X8@8X8SX8XS 8;8 8 8 88S8SX@S8XS8@888S8S88SXXX8%X8X8SS8S@@SS8S@X8 8;8 888 8 8 8 88@ @8SSS8SX8X8S 8S8 8@8 8%8 8 S8 8 8 8 888 @ S888 %8X8SX8;888S8%8 8:8 S8%X8t8 8S8 88@X8 X8 8S88%8 8 888S888@8:8% 888%8 S 8 8 SX%8 8 X8 
@@8XXSX8%X8XSX8X8 X 88X88X@88@888S8S8SS 88888 8S8SX8SS8S8 S888X 8 8 X 8 88@S8SS8 8%8 8X8S@S8@8X8 S8 8 888S888888X88888S@S888S8XXX8:8 SSS@8X8S88%S88@@8.@XS8SS S88888@8 8%X8 8 8 S888S@8 8 X%8 8 88@ X8 S 888 8 88@ X8 8 88@8S88XX 8@888 8 8 S8 8@@8:888%8 @ 8 XSX8 8@88@888 888888X@8 XX%8 8 8 888SX888 8 X8
@@X8 8 88@X8@8 X 8 @ XXSX88@8 8.8 S8X8 8 8 8 888 8S@8SS8X8XXSSX88@ 8 8 8 8 8 8 S8 8 888X8S8X8 XX8 S8 88S 8@8SX88XS8888S888X888@8 8 X8 8 S8 S8 888 888S8 8%S888%88888XSX8S8 888 8S8 X8X88X8 888 88X 8 X8 88@ 8 8 8 8 S8S8%8S@8 88S8 8X8888888 S8S8 8X%8 8 8 8 8 @ S8%8X8S%X88.8 8 8@888 8 S8888@ 8 8 X8 S 8 X
@8 8 S8 88%SSS8 888 8S8 8 8 88 888S8 SS888888 8 X 8S@8X8 S8%8 8 XX8.8 XX88@X X8 X8 888S8 8X888@X88 X8S8S88888S@8888X8S888888@8@8XS8 S X8 8X8 8 888@8 @8 S8 8X8X888SX8 8 8;XS8 888 8 %8S8S88 8 8 8 X 8 S8X8 8888@ 88@ S8 8 8 88 8 8SS8S8888S@8 SX@8S8 S8 8 888 88@ SSS8S8S8 8X 8 8%@S 88S8 88@8 8 88XS888888S
@@8 888S@%XX8 %888888@@8 8 8S88XXS8 8 8 8@88X@ 8 8 8S@8%8 8 SS88%8S8 8 8 888SXX8S88S888 X 8X888S8 8S88S8 8X8SS88S@S88888SS888@@@8 X888S88.888X8 88SS8SS888 @88S8888 X888%8 8 8 8 X88 X8 8 8@@88888%888S8 8 X8 8 8 8 8 X8 S 8SX@X8:8 SXXX%@8S88S8 SS88 XSS 88S8 8 88@ 8@8888%8%88.8S88X8S8888 88X8 8.8 888X8@
@XX8 @ 8 8 888 8888X8@8%S8888 X8 8 88X88 8.@88 S888@8SXXS88@S8 X8S8;X8888X@ 8%8 8 8X8 X88S 8X888SS 8.88S8@888888S8SSX888@X8S8S8XS8 88@S8 8S8@8X8SX8XX88X8%8 S8%88SX8S8 SXS88888 8 888SS8 8X8S8X8S88@8 8 88@ SX8 %8 88@ X8 8 8%8 8XX8 8S8S8 8 XXX8 8 X8 88SS8 SS8888 8S8 8888 8 8@8888 S8S88 8S8%888888 88XSX
@@8;888 888 8 8 @8 8 8;8 8S888 X8X8;8X8 8 8SXS8 @ @ S8%8 8SS8 8 @X88 888S8 8.888 8 8 8 8;8 X8X8 8 888 S8S8S8888888S88888888X8888XS8S8 8SSX8%8S8 8 @8 888 X 8 X8%X8S@888S8 88%8 S 8%8.8SXX8888 8 8S8%88@88888 88@ 88 8 8 SS88SSS8S8 8 S8 88888%8 SS 8 S8 8 88@ 8 8%8X%888X8 XS88S8S8 @8 SXS88% XX8888X88 X88@
@@@X%8 8 8 8 888SS8 8 888 8X@ 8S8 @8 8 888888 88X8 8 8%88;8 X88@X8 88X8SX%8.888 888 888 8%8 888SX88X 8 S8SS88888@S888X8SS88888888SX%8 S8S8.XS8 X 8 8S8 XS88 8 S8 8X8S@X8S8 XS8 8 88 X@8X8X8S8@ 8 8 8S8 X8X8SXS8.8 S888 8S8 8S88XSX8 8S88@8X@ 8:8 8 X8 X888 8 88@.8 8%SS8@S8S8S 8 @@8 X8 8X8%8S8 %X 8 8 8 XX@
@8 8 S8 888S888 8 8% @X888@S@8:888 XSS8S8X8X88:8%88@SS8%8X@8S88 8X8 888@SXX8X8 8 8 8t8 888 8 X8X8 SXS88 88@8XXXSS.8@SSS8@888888@8S8 888S888S8X888S8:S 8 8 8@88SS888 8X8 @X8S888 8 S8X8 8 @88S88SXS88888 SXX8SX 8 8%8 S888 888 8S@88888S8888XX 8 888 8X8 8 8 S%8;8 88X88 8 8 S8 S8X8@8 SS 8@8S888S8%S8 888S8 
@@8 8 X8 8:8 8 8 88@%S8S8S88SX8%8 8S88@ XX@XS@8 8S8 8 88@8SX8 X8SS%8SX@8S8SX8S888 S 8 8t8 8%8 XSS8 8 8S8 88%888S888SS88888X88888888t X8S8SX8X8 888S8 8 88X88 88%8SX8 8 8XS8888 88@ S88S888X%8 88888%8SX8 8SS8 888 S88 XXS8 8 8 8:88SX 8S8 X8%888 8 888 8t8;8%8SSS8 8 SS8 88@:%@8S8X888 8%X8 8S@ 8:8 8 @8 8 8
@XS@ 8 X8;8 8;888S8 8%@88@%X8 8 88:888 8S8 8X8 8 888:8SX@S8S@8%X88S88@@ 8 8SSS8SX888X%88 888%8 8 8888 8X8SXS8888X8SSS8@SSS8888@@88S88XXXS8SS8X8 X8 %88888 XS8%SX%8S@8 S 8S8X888 8 8 S8S8 8 8 8 X8XX8 8SX8 8 S%88X8%8 8 8 88:888S8 8 8 S8 8 8 8XX8 X88 888 888:8 888 8 88@X@@8SS8 X8X888:8 888@8 X8 8 8 SS8  
@@8SX 8 S888 8 8.XX S8 S@S8 8%X8S88S888.8X8.@XS88 8 8S8%8 88%S8 888XSX@8 8SX8%%888X8888X8@XS@X8:8 8 88X8 8S8SX8XS88888S8S@8X8SS8S88@@S88S@88@@@8 S888 8XX8X8SXXX8%8S@8 8:8 8X8S@8 S8 8 8888 8S8 8SX 8 8 SS88S8 8SS8S@8 %8 88X8 8 88@.8 @8 8 8:8 888 X8@8 8%8 X8888S%S8.8%8S8 8SS@SS8X8 X88XX8S@8 X8 888S88@S
@@XX8888 X@S888:8S888X8SSSS888S88SS8S8@8S@88S8 8S8@8X8@8X8 8@ 888SSS8 8S8 8 888X@SSSS8@8X8888S8X 8t8SSXSX 8X8888X88@@888888SS8S8@8888S888@88@8888 %X 8 8SX8X8@S888 8 S888 8 X 8S88888X8S8S88.8X8 8S888 8 8 XX88X8SS8 X8 88 X8 8 8 8 8 8 @8 888 8:@8X8S@ 8 8 8 8X@S8888%X8 8;X888 8 8 @8 8S8 X8SS8%X8S8 @88 8
@@X8.8 S8 8 8XX8.8:88SX8 888 X@8 8  8X8XS8 SX 8 8S888@8S8S8S8SS8 8 8 888 88X X8SXX8888SS8 S@8888 S8 8 8S8XX8SS8%8S8%8X888@S8@8@SSX8S8S@S@888888888 .8@XX8SS8S8 8 S S8 X8 X 8 8 8 8@@88S8%8 88S8S888 8:XS8:8S8%8 88XS8888X@8 X88888XSS8S8 X X8 88XS8 888S8888X8 8 8.SS8X8;88888SX@8%S8S8888 888X8 8 8%S88X 8 
@@SSSX8 S888 8S8@XXS8 8 888 8 88%S8 X8%8  @S8S888X8 X@XXX8@888S88.888 8SS @.8XSXX8 8888%X8S8 8 8 8:S888@@8 @X8S888X8X88@S8S88S888888@SSS8XS@@88@%SXS8888S888.S@ 8 888X8 8 888 8 8%8 888X@@8S8@ 8S8 8 8 8 88888 8 88 X8S8@8 8 888888X8%S88S8 SX8XX8 8 %8X8888@888@X88X888X 8S8@88 888@X88S 8 8 8 8;8:8 @8XS 8
@@888XX8 X8 8;8%8 8SS8X8%8 888 8X88XSSSS8SS8 8 X8 S88SS@8S8@8 8 X8S888@8 8 8S8 8 88 8SX8SS8S@XS88;8 @ 88888 8 8 888S8@88888888888X88X8@:8888888X88888888XS@8S888;t88 88888 8;8@8;8 8SX@888 888888888888 8S8 8X888S@8 88@8 S 888 8 S@88S8 8 8 88@S@88@ XS 8 8 8.8%8 8S888S8 @S8 88 88S8;@8%S%88SS88 X88 @8%8 
@@S 88 X88 888 8 8 8 @ S8 8X8@8 8;XX88X888 8S @ S8XXSX8 888X88@8S%8X8X8 88@XX 8 8S88%@SS8SX8S8 8SXS8:8S@XX88 8 8S@X888@X888@XS888888SS8@X@XX88XSSSS8@X888X88@8888X88@tX8%@8S8SX8X%88888888888S888888@8888@888888X8X88 8SS8S8t8SSX8X8 X@88 S 8 8 8 88 8 8 88@8 8@8SXXXSSSS%8 8 8 88%SSS8 8 8 8S8%8%8X8 8%X88S
@@@8 88XS8 SXS888 888 8 S8:X%8 888 8 8 S8S8:8XS8:S8SX8S8S8 8S8SX8XSXS8%S88 8X888 8 8@S8 8X8 @@8;8 8 X8@ 8@88XX8 8XX8S@S:@@88S@88@88X88XS88888@8888S8888@S88S@8X@X@88X@X@:.8@@8 88X8888888888X8888888888%8888%@8888888888@SX88S8S@@8 8%8S@8S888 X88 @8 888S8S88XX 8S8SXX8 888 8 8 88 8 8%88 8.S 8;XS8 888 X@8
@@X@8SX8 88 8 8 8.X8 88@ @8 8 8 8 888 8 S888 8%88SS8SSX 8 8 8 8%X8 8 X8X8 8 8 8 888S8 X888 8X8 XS88XS8%888 @8X88 8S@S88@XX@88@@XX8X;88888@88S88XX8888S8XX8S888@S8888@S8@XXX8SX8 8 8S88@888888888888888@8888@888888888888X8@88 XX@8@8@8 8SXS88 8 X88 88%@X8%8 88X8 8 8 888 8 888 8SX88@8@%8XS88XX88888XX @S8X
@@8XX8 8S88SX8.888XX8 8 8 SX8 X8;XS8%88XS88 X8888X88@8%88S%8S8 8SSS @ SS88@888:@@@8S 8%8 S8 8 8 8 8 X 8X8 8.S8%X8 8 8S@88888XSS888X888S88@@X8888@S8888S8888888S8S8X @@@8SXSS8S@88@ @ 8S8@8@888X88888X8888X8888@88888888@8888888XS@@X@88 8 8 S8 8 S88%888@ 8 8 8@88 8X8S8 8 8 8S88@S88%8S8 8 888X 8 8:8 8 8 8
@@XXSS888 @8 8XXXS8S88 8 8%88@ S8 8 8 8 8 888888@8888S88888X8888888 S8888SSX8 8 8.@88:888 XS888 8% 8 8 8 @88 S@SS8X8 8S@X@8t8888@8888SX888888X@SS888@X8S888@8888@@X@XSXSXX8 8X8S8@8 8 88S88@S%888@888888@888@8888888888888888888888@8SX8 8 8SX888%XX8%X8 8 8 8X8 88S8%X@888X8 8 8.8 8@ 8 8:8SX8 8;8.888 SS8 
@@XXX88@ 8.X8X8 8S@8XX8 888 8 8 S8 8888888888888888888888X888888888888S8 @8XXX 8 8SX@8X@ 8S8 8 88@SS888 8S888 8S8S8S@@SXXX8SX@8S8X88SS8XS8888XS8@88SSS@@S8X%:@SSX8SSXX8 8S88;8 8%8 8 8%8S8 @8 8 88888@88888888@8@8@8@8@88888X88888888XX88 88@%88 8X8SXSXX8 88%X@8S88 8X8S88XX8 888 8X8 888@88 8 %8 8X888 8;8
@@8XX%X8 S8 SX@8:8 8 8 88@ 8 88@ X888X88888888888888888888888888888888888X8@8 888 888SX8 SS88888 8S8SX 8 8X8@888X888@8@S8%8S@SSX88tS88@88888SSS888S8S8X88@8@88 8%XSXXSS8:8 8XXX 8 888 8 8 8 8SX88@@@888@8@888.@@888@8888888888888888888 SS8 X8 8X 8X88S8 888X8S@X8SX8 8 8%@8%888S8 SS88S8@8 X8X8%S%X8S8SX 8 
@@XX8S8 8 S8S8 S8 88@ S 8 888 8 X8X8888888888888888X888888888888888888888888@8X8 S 8S8%8888X8X88S 888X888 8X8S88@8SXXXSSX8 8 8S8@8S8X@88.%8888888888%@%8@X@88 8 8 8 8 88X 8%8S8S 8 8 8 S 8 8 8 8 XXXX8@X88@88888888@8888888@8@88888888@@8S888 @S8SS8 @@ 88@@8 8S8@8S8888;8 888 SS8888SS8%888 88X8S8 X8 8 8 @
@@X8.8 S 888 S8 @8 8 8 8 8 8 8888X8888888888X888888888888X888888888888X88888888S88 XXX8 S888XXX88@@@8 8%S8 8 8 8888 8 8 8 8XS@8 8 8 8S8SX@S@888@S@8t8@@SXXXSS@ 8 8t8:8 8 8 8 X 8 S8 88@ 8 S 888 8 8 8 XXSS@8@88@88888.@88@8888888@88888888@%8 S8 8S88S8 XX 8 S 8X888S88 XX888 8 888SS8SX8X8@8 8SSX@8S88@@X8 
@@XX8 888 8 8:88 XS8 S88888 88888888888X888@8888888@8@8888888888@8@888888888X888888@8SX8 8 88S8.8 8S8888 8%X8 8X8@@8 888;8%8S8 8 8 8 X 8%8%88X@X88888@8X@XX8 8 88X88SSSXS8888%8:8 8@ 8 8 8@@@%8t8%8X8@;@;8 8t 88888888888@888.888@8@88888S8888 X8;8 X8 8 8%%8%8 8X@X8 @8 8 8 888 8 8 8 8 8X888@8 @ S8S8@8 8S
@@8S%X88X8 SX8888S88@ X8 88888X8SXS@@X@8S88XX@@X 8@8888@88888@8@8@88@888@888888S888S888 8.8%X@SX 8 8S8X@88XS88%@@XS%8 8:X8@888S8@ X 8 8 8 8S@8X88888888888888 8 8 S8X8 8S8@88888888t88%88X8X@X@X@X8XS8@S@X88@888S@X@@XX@888888888888@8X88888888%8X 8 8 8888 8  8 X8SS8 XS88888 8 8 8 S8 X 8X8X888;8 88XXX8.8
@@XX888S8 8%8 8SSS@8 8 X@8@8 XSXXX8 8 8 8S8@SXX8SXXX8S8888 @8888X8888X888@8888@88888888S88S8 8 8 888@88 8SX8 88SSX8 8 88%8X8 88888 888.8X8 8S88888@8@88888888S888888S88.8S8@88888@@X8@@888X88XXSS@S@8XX@@@8@@88@@SXXXXXXX@@X@88888@8@88@888X888XXX888X8 8 SXS8 S8 X8%X8 8 @ 8 888 888 X8 8 8X@@@@8 8 @8 8 8X
@@X8 X8@X88X 8 8 8SX8 @S@XSS8S88@8 S 8 X%8SSXXSS8 8 @88 8@@888@@888888@88@8888888@8888@888888S88XX8S8%8SS8 8S8S8 8 888 S8@8 888SS88 8 8S8 8X8888@8@88 @88888@88888888888 @88t8%8S88XX@@@SS888888888888S8888S8@88@@SXXXX8 8XXS8S8@8888@8@88888888@8.8 8.8t8S88888 8S88X%8:8 888 8 8 8 8 8 8X8SXX8%@8%8SSS88X8
@@SS88@8@8 8 88X8 8 8X@8 8S8 XS8 S88SS8S8SXX8 8 S8@8S8%@SX8@@X@@8888@888 @88@8@88888@88888888S8@8XXS88 8S88;8X888 8 @@X8XX 8S8%8S8 8 888S888888888@888888888888888888SXX8 8 @888:%888888S8XX8S8S8S8S888888S8X888@8XX8 8 8 8%8 8 8S8X88@8@88@888888SS8 X88@8 8 S8X88 88 %8 SS8 8 888 X 888 8 8 8 8 S8 8 8 8S8
@@8SXXXS88@X8X8%88:8X8 XS@88888 8SX88 S8@S8SS88@S8 X8X8 8SXXSXS@@@888@8@8888@88@888888@88888@8888888XX8:8 8X 8X888X8S8%X8S8 8 8 8%X88X888888X888888 88@8@8888888888 XXXSX8 8X@8S@SS@:@8X;8SS888XS8888X8@S88X8SS888@SS888 8 8 8@8 8 8S@X888888888888X 8S8@8%@@8S8%@X8 X8 88 8.S8888 8%8:8 8t8 8 8 8 X8 888 8 
@@XX8 8 S8X8 X 8 8@ 8%8 8S8 S@888@ @88X8%X888 8 X 8S8SS8 8 8S88 88@8@88888@88@8@@@8@88888888888X88888888 8S8 S8X8X@X8 8 8 8X88888888@888888@88@88@888 8888@8@88@@SS8S8 8S8888 8 8 8 8X8.%88888888888S8XS;88888X8@88XS8888S8%8X8 8 8 8 8 8888@8@88888X 8 @ 8X8%XX8@8 8 X8 8 S888 8SS88888 S888 888 8 S 8XXS 8
@@X8SS @%X88S88 8 8% 888 8:8%8@8S@8S8.8 8 8SX8 8 8 8@8 XSSSX8%@8S88 88XX888888@88@88@88 @8888888888888888@88888@888SX88888888X8X@8888888888888@8@8@8888888@8@XXXXXSX%8 S8%8X@8 8%8 8 8 8SX8;888@@X888X8X8XXS88888888 SX8S8 8:8 8.8SXX8X8%8@8888888888X 8 8 @88S8 8XS88 8%S8 S888 8X8X8 8 8:8 888 888X888S8SS
@@XS8%888 X88S8XS888 8 8  8 8 8 8 SSS8S8;8 8 X8t88@X8 8 8S8 S8 8 8 8SXXXXS@8@8@88@888888888@888888888888888888888X@888888@@888S8888888888888X888@888@88@8SXXXX@XX8 8S888XX@8 XS88XS88 8 8SXX@S8SS8888X888@88X88888888X8SX%888%XSX88X8S8 8 @@@X88@88888X 8888SSX@8@8 8S8 888S8S@88 8 8 888 8 8888 X8 8 8 X%8X
@@8SSX88 8X8 8S8 88 8 88@S%888 8 8 8 8 X8 S 8 S8 8 8:XS888 8 8 X8 8 8S8@S8 8X88@88888X88888@88888888888888888X8888888X8888888@88888888888888888X88888888SXXX8 8%8 888 88S8XX8 8 8 8 XXX8X8 8 888SX88888S@88888@8XS888 888%88.8S8 8 8@8 X 8SSXS@88888888888 8888%X888:SS8 @ 88@X8SX8 8 88 888:8 X8 S888 8 8 X
@@XX8S8SXS88SXXS8SX888 8 8 8SX8 S 888 8 X8 88X @8 8 8 8 8 X88.8 XSSSX8X@SX@8SX8X@8@8@888@888888888@8@88@88888888888S@888888X8888X88@88@888 @88.@8888@XXSXX8 8SSSSS88 @S@8.8 SS 8 8 8%8%8SX8 8S@888S8888X8SS88888S8SS8X@8@8 8@@X 8 8S8.8S8 8S8@S8X888888888X8X 8X8SX@8 8 888 8 8%@SSS88 XS8S88XX 88S8S8 8888X
@@X8 8SX8 888X8 S8 88X8 888 8 X8S888 88@ SSS8.8 XSS888%8X8S@@8 8 8888S88%8S@8 XX88888.8888@8X8.8@8@88 888@8@88888888888888@888S888@8@888.888@8888@XXXXX8 8 888S8888S@@8 8X 8 8 8@ 888 888 XSXSX@@8X8X8S88888888S888X88XXX@8X8%8S8888 88@ S 888X8XS88888@888S8S88XX8SS8 8 8 8 X 8 8%@ X8S88@S8S8 8S88888S8X8S
@@SS8 8S88X@SX%8 SX@8 XS8 X%S8 SXX8888%@@8SX8888S8S8 %8X8 8SS%888 S%8S8 8:8 8X8 88XX@S888@888888888@88888@88@8@8888888@88X88888888@88888888@88@X@XX@XSSS8 8S8 888:888XS8S8 X888 S888 8S8 8S8 8 8 8@8SS888XXX88S88XXX88 8S8@8@888%8S8@8XX8S8%8X8S@X@888888 @X@8 @8 88XS@88X8t8S8 888 888 SXS8S 8SS8S8X888 8 X
@@88 8 8 S8 8 8.8 8 S8 888S888%888S8 8X8 S8S8X88888@8 SX88 8 888 88888 XS8 8 8 8 XXXS8@S8888@@88@88@888 88@8@88@888 X88888888888@888@8X88888S8SXX8SS8 8 888 88%@X8 8.8 SSX8 S@@8 88X8 8 8;S 88@ @ 8888SX88888888@SS88;% 8@8S8X8@8 8S@@8 888 XXX8%8%XX@8888@@@X8 X8%X8X888X@8 S 8 8 8 8 8 8 88SS8SS8%8X8 8 8S
@@SSX888%8 8 S 888 888%S8 8 8 8 X8X88 888 S8%8X8X88XX8 8 SS888XX8t8@8@8 8 X 888 8 8 8 8 8S8X88.888888@8888@88@8@8.888888@8888@8X8@@88888@XSS8 88%88%X8 8 8 8 8@S8 8 X 8S8 S8S8 S8%8 X8 888X8 8 8 88@S8t88X8@@@@8888X88SX 8 @S8X@88 8X8 8 8 8 8XXS@8 XX8888@8S8 8SX8 8 8 88  8 888.888SS 888 XX8 8 SSXX@8 XSX
@@X8SS8 888X8S8S8 8 8 @SX888 88@ SXX@8S@@8 8X88;8 X8SX8:8 8 8 8 8X 8X888 8 888 S 8 8 S 8 X 8S@S8888888X8@88888@888@88@8.88888@88888888@XXX8 @8 @8888 X88@ X 8S8 88 8%8:S 8.X888S8SS8 XS8S8 8SXX 8 88@X@88@888S88XXS8S8X88:88 @8S@88 8 X88 8 8 8 8 S@8 88X8@S8 8 8SS8X8 8 888 888XSS8 8888@ 8 88@@8 8 8 XX88X
@@8.8 S8X8X8%@88@8 88@.8 8SX8 8.8%8S8 8S8 8S8 @X 8 8XX 8 888.8X8S8XX8X@@888@8 8 888 8 8 8S8 8@SX@X8888@88@8888@8888@888888@8X888888XXSXX@SS8 88S8@8 8%8 S8 888 8S8X@8 8S888S8 X8X8 S8S888 8S8%8%8X8SSSX8S88@888@S88@@8XS88S8@8 8S888X8%8 XSXX8 8;8 8 8XX8@8SSX 8 8 @ X8 8888SS8 8 8:888.8 8 8S8SSS8 8:8 8 X8
@XXXS8 SX@8%8X8S8 8%8 888 8 8S 8 888.SS8SXS S8 8 8 X88XS8888@8 X8 8S@8S8X88888S8X8 888X8 88@X8@SXXXX8X@888888 888@888.@8888888@X8X8@SXXXS8 8X8S8 8 8 X88 S%88 88@S8%888X88 8.8 8XX8 X888 888 X88@8X@88888XS8888888@88%S@S8@ 8 XX8S8S8 8 8 8S888 8 8 8 8 X8 8888XX888888888 X8@8@@8:X8XX8S8 88X 8%88@ 8 888 8
@@88S@888%X8XSS8;888 8 8;8 88@S 8 8:8 888S88S8%S8:8 X88888 8 88S%SX8 XSSS 8X8%X8 8SS8S@88 8 8%8%XX8 XS%S888.88888888@8888.@XX8SSX8SX8 8S@S8:8X888@XS8%8 8%8 X8@8 @ 8S8X8 X8 S88;8 X8%8 S8 8 8S8 @ 888S88S8S888@X@888@%X@8S8SS88X%@SX%8 S 888 8 888 888 8 8XXSX8X8 8 X8X8SS8 888@8;8 S8 8 X8 XX8 8 XX88@%8 8 
@@SX8%8888X8S8 8XS8 888 888SX 8 X8SS8 S8%8S8 S8 8X @8 8 8 888 88S8SX8 8S8SX@ 8 S8.8 X88X 8 X8XS8 8 8 SS888S888@8X8888@X8X88SXSXXSS8 8 S888 888@8@8S88@@8:888S8 SX8 SX@XS8SS8 88X 8:S8:8 8 S8:8 8S8 @88@@88888S8S88@@@8S8SX 8 @8S8 8XX%8 8 8:XS8 @ 88X 8 8 8 8.X8 8;8SSS%8%X8 X 8 8;88SS 8 S88XSS88S8 XX8 S 8
@@XX@8%8 8 8@88S8SS8 @ 8 8:X88 8 S8 S8% @X888 S8 8 88XS8 8 8 @%S8 8 S SS88X8S%88 888 X8 88@ 8SXS888 8%X%8888@8@8X8888888888SXXX8 8 888S@%8%8 X@@XS8 8S8 8S8@888S8 8 8S8  8 888 8% 8 @8 8 8 88 888 8X@SS88888X88X88X8888XX88 8 XXS8 8 888 888S8 8:8 8 888 8 888XX8SXX8 8 S8 S8S8 8 X888 888S8S8 8 SX88S8 8S8 
@@8@8 8 8 8X8 @X%8S8888SS88S@8S 8 S8888@@8S888 88S8SX8S@8 S 88@ X888 8S8 XX@8 X8S8 S8 8 X8.X8@8 8SS8 8  t@X8X8X@@8X@S888@888X8 8S 8 8 8SSS8 8 8 8 %8:888@8S8S888@@8@ XS8 8888 8 8%S@ @8 888 SS88X8.888S8888X8XXX8888888%8 8X 8%8SS888 88@8 SS888@XX8 S8 888 8 8 X888@8%88@8%X8 88@ 8X@8 8 8X8X8%8S8 S8S8SX88
@@S8.888SSX8 8 8%X8888888SS8 8%888 X8 8@8%S8XX8;8 88XS8SX8 8 8 8 88 888 8 8XS8 X888 X888 SXS88SX 8S888S 8888SSS88XS8888888XX8S8 8 S8SXS888S888 8 8 88@8X8 8@8S8X8%8 8%88888XX8 S 88S8 @8 8 8 888X8@8X8888XSS88888S88%X@ 8S8%8 888 8S88 8SS8 8 8@8 888 88%8 8 8 8 S8@8%S88 X8 S%88S@@X888@8@8X8%S88@8S8 S8 8X
@@SS8S8 8S8SX8 S8 X @XX@888@8 X88 8 X8 XXXXS8SSX @SX8 888S8 888 8S@8 8:@X8 8 S8 8 S8 88 8 8 888 8:8 888 St8X888888t8S88888888X 88@ X8S8 X888XS@8888 X@%8 8@8@XXXXX@8 8 8 SX8S@8 888SS8XX88@88 8 8:888S88XS888SSX88@@.SX8;8X8 8 8 88@XX8 8 SS 8 S 8 @X88 8 888 S 8 X8%@8X 8 S8 8 SXXS8X8X8 @XX@8 8S8%@@8 SX%8
@@88S8 8 8;8 8 S 8 @X8S8 @8 XSX88XX8S@8 8 8 S8888 8 88 8888888.X 8S88 8 8 8;8 88.8 88 88@88@S8 8 S88@8 @ 8St8@S@888888XSX888X8@X8 8 S8 88 XS8@8@8SS8S8 8888S8X8 8X8 8 88@ 8 8 S%88 8 8%8S8X888:888888888S.@XS8S88@@8@X8%8S8 888 8 8 8 X888 8 S8S888SXS8 S8 8 8 888 S@8S8SS8 88S8%8 8 XS8 8X8X8 8 8:8X8 8 8 X
@@SSXX8 S 8 88@88888X 8S8 8 8 8:8 8 8 SX8 S8 8 X8%X8 X8S8X8S@X8 88@ 8@888SS888S8@X8 88X8S88%X 8 8 8 8 8 8@88SSS8XS@88888888@8888X%@8S%888X8 @8%X 8 S8S8X8X88S@%8 8 888 8 888 8 8 SSXSX8 XS8X@X88888XX888S88888SS888;S8 @XSS8.8 S 8 S @8S8 88@ XS@8 8 88@ XS8888S8 8S@S8 8S88S8X888SX8 8 S 8 8 8 S 8 8 88888 
@@X8S8 8 888 8 8888@S888 888 888 8 88@%88@ SS8 888 S8%X8SXS8S8 8 8 8S8 S8S8.@X8X8 S8SS888 8@X8 888 X@8%@XS88S8888S8S@XS888S8@88888 88SX8S8 8 X8S8.8 88S8S8SSSSS888SX8 888 8 S 888 8 @ X8 8 8 88X88SSX88@S8SX8888888XSS8XXX88SX8%888 888 8 X8 8 @ SS8 S8 8 888 8%X8:8 8 X@8 X8S8 88S88XS888888@X88XS88@X8X888
@@8 8 S 88@ X 8:8X@%8X@ 8 8 88@ S 8 8 X88S88888 8S8 S8 888 SSSXX88S8@S8SS8 888S%X88 8@8 8S8%8 8;X 8X8%@XX8Xt@S88S8X8S8S888@8S@8888: X8SSSSS88S@8t888S8 S@SXX8 8 X8X8SS @ 8 8 8 8 8 88X SX8 S:t@8@SSS8X8S888888S8@X8XXXX8 888@8:8 8:8 8 888 X888 8 888 888X SX8 @ 8@@8 8S8.88 8%8 SX%88X 8 8888XS@8S88%XS8X@@
@XS888 8 8 8%888 8 8 X88.8 8 8 8 888 8S8 X 8S8 8 8888S8X8@8 8S8 X8S88XS8SS8@8X8S8 8SSXX8 8 SSS88 8 8tXX8 8SX.8XS88XS88888S88888SX@S88X8 @S8 S8 X@X8SSS8%8 8 888 8.X8@8SS8888@ 888X8S8 8 8X%;S888S888888XSS88@S8S88 8S8 88S8 88SXX 888 8 8 8 88 888%8 888S8X8%8 X8S8S8888 @SS8@8 8S8 X88SX8 8.8 8 S8 8@S8%X8@
@@S8S8 SS88X8 8 8 888 88SS%S888:8 8;8;8S@88.@@888S@%8 X8S@@8:X 8%X8 8 8 8S8 XX@8S@X8 8S8888S8S8 888 8 8 8.8 8;8X8888@S88@88888XS8X8888%8 888 S8 888XSSS88XX888 88@S8SX8 888XX8X8S8 8X88;;8%8@S8S88X@X8X8.888SSS88@8 8 888%88t8 8%8 8 S 888 8 88@8SSX888 8%888X8 SXX8S8XX8XXS8 SS8888S 8888SS8 8S888S8 8 XSS8
@@8:8S8 8 @ SSX8t8 8:8 888888X%8 888 8888 88S8SX%8 XS@SS88XS8 88@S8XS888 @88S8 SX8SS888S8 S88@ S%8 888;88888SX.@8X88888888@X888S88@8888888X@XX88S8X88 888@888 888S@ 8 SX8888 8888;@8%t8%88888SS8888S8888888X8X88X8%8 8 8 8 8X@8 88@.8 8.8 8S888%X8 8.8 X 8S8 88X%8 X8 8 888%8888%8%@8SSSSXSSXS88@8 8X%X8 8 X
@@@8@8 888 8%8 S888 888 X88888 @8 8 8S8 8S8t8@8 8;8 8 8 888 S8 8 8X8S88%8X8 @@8 @S8 S8 S @SX8 8 8;S88 8 8 8%XXX@88XXX88X88888@S8S888XS@8@88S88.88X8S88:8 8 8 X888S8 S888S88@ X%t88SXX8X8@@X8SS88S@S8X88S@8X8888XXS8 888X8S8 8S88 8 S 888 888 SS8SS8SX 8 8 8 8 8 8%8 8S%8SX8S8.X8 S8 XX88@8S8 8 @ 88%8S8 88@ 
@8 8 8888 888 8 S8 8 8 8S8 8 X8 X8 8 8 8 X88%88888XS 88XX888 XX8 S8 8 8X888@8SS8SXX8 SX88 8 S888 8 8%SX8.8 8S8SXXSX8@888S@S8S@888X8SSS8X8888tS88888S%8%88@8 8888X8S8X@888t8@X8X8X@88@X8SSSSS8SXXSS888@S8888@88@X@SS888S8%XXS%8 88 8 8 8 8 888S8SX8%88@X888 888 888S8 8 @8 8 88S88%X88X88 SX88.8 8 88888XXX 8
@@8 8 888@X@SX 8 88 8 888 8 8.S8%S X8 8 8 X88@8X8S8S8;8 8X888X88XSX88XX8 @88X8 S8S8@8X8 8  8S88SX888 @ S8 S 8 8 8S.88S8X8X:8@XX88SS8S88@S888@S88@888@@%8@888888X8888888@88888XX@888SS888888888SS88S@S88888XXXX8 8%8 8 @ 8S8 8 @%888S8X@8 8S8@8X8 XXS8X8%X 888 8 8 8.XX8SSX8 8.8.X88 88888%8SX8 88XS8S8@@8S8 
@XS88@S8X8 8%8 88S8XXS8 SSS%88 X8888 8888XS8 @S8 8%X88@8 8X@@%@8 8 8%@X @S8S8 8 S8S@88%XS8 X8 X8%8S@8:8 X8S8;8 8 8 88888X88SSS8SX8@8@S8X8S888@@8888X8@XX@88888888888888@@8@SSS88S8SS8SXX8@88SSS8SSS8SS888:@X8S88 888 8 8 888;8;8%88888X8XX8S@XSX8S8%X8%8%8;8S@ 888 8S8 8 88@ 888 X88X8 8 8 8 888SXX@XSSS%888
@@8 8 8 8 X 888 S@88XS88S8 8 X8X@S%S 8 8X@8 8 8 8t8X8X@88XS8S8SX8 88@X8SX8 888X8 888X 8SX888X8 8@888XS 8 8 S8 8 8 8 8X;8@SSS8X8SS8@S8:8888X888X8X888S88888888@X888@888S88888888S8888S888888SS8XXSS.888X S@XX@8S88 8 S 888 8 8:8@8@8S@8 8888@8 8SS8%8 8X 8 8 8 88@ 888.X8888 8 8;8 @8 S@8 S8888 8 8X8@S8 8 8 
@XS8 8 888%8 8 8%8 XS8.8@8SX8 S8S8S8S88;8 SS88X S8 8 8 8X8SXXS8S@8 8 8 8%88@8SSS8 X8X8 8S8 XSX8X8 X8S8 8 8 8;888 8 8S8 8888X8XS8S888@888X88@@X8888@S8SX8S8S888S@8S@8S8S8S8X888@8S888SXX8@SS8X8X8S8SS888@XSXSS@8 8 S8 8 8 8 S 8X8X8%8 @8 8:8 S8 8SX8S8S8S8X88.8X8 8 8 8 8 8.88 88 8S@8%888 %888SS888X@S888 8%
@@8;8 8X88888 888 8 888%8 8S888S8@8%8 8X 8%8 8S@ S8 S 8 8X8S8 S8 X8 8 S@8 X8 8 SS8XXXS8 88888X 8:8 XS888 88%S88 8X8 XS8S@S88X88@8888SX8S8888@8SXXS8X8888X8888SSS8@8S888888888X8888@S8S8@SS88@X888;8@@@XS@XX8 8 88@ S888 88@ 888 888X8 8 8@X8S@8 8@8.SX 8X8 88%8 888 8 88@ 8S888X@ 8S88@8 8S@SSX88X 8 8 8 8 8
@@@8 S 8X8S8888XX XSX8 8 8;8 8888 S%X8X8SS8 8 8;8 X8%8 88X @ 8:X8%SS88X8 8 @8 8%8 8 8 S8X8 888% 8 8 8 8.8 %88SX8S8S8S8 8 8X8 888S8@SS88XSX8888XS888@SS88XX88SS8XX@88X8S8X888@@X88S8X8888888888;@XX8SXX@SX8 8 888XX@ X8 8 8 8 8 8X8S8X%8888S88XX8%@X8 8SS8 8 8888 8 88@ 8 S 8 S8X8 S888 8SS8SX8S 8 8 888.888;
@8 X88 X8 8S8XX888 @ 8 88 88X @888 8 SS@8 S888 8.8 8 S8S8S8S88@ X888S%8 8 888888 88@:88 8%8S8 8 8 888@:888SXX8 8 X888S8X8 8 8S888t88X8888888@X8X8@S8@8888888S8888888XS88888XSS888888S88888%:8@XX8SSXX8 8S88 8 8 8S 8 S%S8 888 8 8@8S88X 8 8 88%X8@8 88@%88 8S8X888XS8 8 8 88@%X8 8 X88SS8 8S8%8 8 8888 8 8 @
@@8 888 8%S8 8 X@8SS8.8 8XX8 8X8S8SS8S8 S8 88 X 8:88@S8 X8%S8%X88SS8 8 8 888 8SX8 8:XS88%8 8 888888 8 8 8;8 8 8 8S8 8 @ XSX8 8@8 8X@88.S8@@SX8X888S8S88XX88S:8@XS888@88@@SS888@@X88S8t88@XXXXXSXSXX8 8 S8S8X 8 8 8 X88@ 88 8 88@@8@8@8S8 8 8XX8SSX@8 8 8SX888 8S8 8 88@8.8 8.8 8 88X8 8 8 X8X8.88@X8 8@S8 8 
@XX8 8S8.8 SS@8S8 8 8XS8 8 8 8 8%S8 S8:8 888@8S8 X8@X888%88 88 8S8 8SS888 8 8 8 S8:8 XS8SX8 88X 8 X8 888SX 88888 8S88 X8 8 S8@8S@X8S8 8@S@88%8888S8888S8S8888S88SX888888S88X888X888XXX@XXX8 8XXXXX8SX88SX8%8SSSS%88 X8 8 S 888S@8X888X8 888 8 8 8S8S@8 %8 8%@8 8 8t8X8 8@@8 S88 8 8SX8 88@ SX8888 8%8%8 88 8
@@88S8X8XX8 @ S@88X8S8 88888888.8 X8 @8 888X8S888 8888SX8 88 8 SSS888 88 8 8 S @8%S @88S8 S8S8%X @SS8.8 8S8:8 8 8 8 8S%8888%8XSX8 88%8S8X8S@S@@88888:8t8XXXSX88888SS;;88;88888XSXXX@XXXX8 @8@SX8 8 X8.88 8888 888 S8 S8 8 8 8 8S@XXXX@88 8 8 8 8 @88%888S8 8S@8 888SX@8@8 X8SS8@@8X8 XS8 8S8X8X888XS8 S8 S%X
@@%8X8 8888%S8S8@8.S8 8SS8888S8S 8 88 XS8SXX@8S888%@888SX8 88@888888@8XX888:8%888%8 S888@@8S8 8 8 8 8XX888.8X8:X 8 88@S8 888 8 8 8 8SX@X8@SSXX8%X@@@S@ @X8SSXXXX8SSXXS8SX8S@XXX8 8SXSXX8 8 8%8 8% 8 88:88S8 8  8 88@8 8888888S@8S8 8 8XX8 888 88XX8@8 X8 X8 8S888SX88XX8 8 88888 88S8 8 888 8 X8@8 888 @8S8 
@8 8 88 8XS8 8 8 88 888@ S 88888 X8 8S8S%8%8 X8X@@8 8X88SX8S8 @XSSX8 X8 8%SS888X@S88 S8S8 X8 888.88@S8 8SX8S8:8%888 8.S 8 8;8 8 888 XX8@8SXX8 XXXX8S@S8S8 @X@XSXS8 8S8 8 XXXX8 8SSXX8 8 8 8S8X88@%S8 88 XS88X888@88  @88%8 88888X88.8 8S@8S8 S 8 8X888 S8%SX8S8SX8SXX8 XX88 @8XXXX8 SS888X8 S8 S8%8 8 8 XX@8
@@8 8%8888SX8 88XS88 8SX888 @8SX8 8%S8 8 SS@8S@8S8 8 8S@8%S8S8S8 8 X@SSSX8S8 8 8 8:88SX8 8S88X@ 8 8 8 888XS8SXXS88 X88%888 XS88@ 8 8 8 8:88 88X8 8%XSXS8:8 8 8@SSS8 8 8 8 8 8 8 8 8 S8 88@X8S888 8 88 88888SXS888SS8 8888S8 X8SX8 8@XX8S8 S@8S8 8 8X888 S8S888.8 @8 8 8 8 S8 XX8X8 8 888 888 8 8  S 8 X8 @ S
@XX888X8SX8S8888 8 8888%SXX8 X8 S888S8 8 8S8 8 8 88 @@8S@8S@8@S8S @ 88888X888@8@88@88@8 X8%SS8S888 888.8%8SX8S888S8X8 888 8 8 8 888 888 8 @8 8@88 8 8 8%X88 8S88 8 8 8 S 8 8 S 888 888 S8SXS8X8XS88 88 8@X@888S 8XX @S8S8X88SS8SS8X8S8.88@X8 8 888 8X888%@8 88SX8SS8X8:8:8 888X88888X%S88 8 88@:8%8 888S8 8 
@@8S8 8 8S@888X 8 8S8X88XXS8SXX88@@ 8 88@:X 8 8 8 888X 8S@8@8XX 8 88 @X 8X8@8X8SS8 @8SS8 888@8888SX8S@8%@S8SS8X8888 888 %88888 8 8 8 8.X @SS8%8%88 X 888@8 8 8XX8 888S8 888 8 88@ 8 8 8 SX88 8S8X@ 8 88 8S8 8S8%888@@8 8S8 88%S8%S8 X 8 8 X 888%8 8.8S@@@SS8 8X8:8 8888S8 8 8888X8@8S8%8 8;8 8:88@88SS8%S888
@@SXX8 88@SX8 8 888@ 8%88SX 8 8S88 8;8 8t8S888%8X8%S8XX 8X@8 8 8 8 S8X8SSSS8;8X8 S8 X8 X8 X8X8@8.8%X@XS8 8 8S8 S88.8 8@8 8S88 88@ 888 8 8 888S88S88 8t8 8 888 8 X888S88@ 8 S 888 888 S88S8 XX8 8 8 88888 8 88888 @8@8;8 8 8 X8 8 8 8S888:8S8S8 XXS88XSXS8 888 XSX 8 X88XS8%8SX@ 8 8:X@8 X88 88@S88888SS8 88 
@8%8 8 8XX8 XSX8X8@8XX8 @8 888 8 XS88@X 8 8 8:8X8 8 88S8;8S8@XX888X8 888 8 88S8 8 8%X88 X8 8 8 8888 88 XX8 S8 8S8@8 8S888@8%S8S8 8 8 88@:8%8 8 X8 X888S8 8SXSX @8S8 8S8@8S8 88@ 8 8 8S8 X 8 888 888:8X888 8S88XS8S@8%X88XS88S88@8 8 8 8:8 888 8S8 8X88 888%X 8 8S888 8%XS88 8 8 8SX8X888X8.8 8S@S@88%8SX8S@8
@X8 888 8 8888X 8 X 8S@8 8 88 8 8 8 @X8 8% 8 8 8S@X8 8 8X 8X8S8 8 88@X888S8 88 888.8X8 8 S888 @88 8S88XSS88%S8;8@8XS 8X8@8 8SS8X888X8S8 888 S @SX88S8 888 8S8 888 8888S@8888@8 8 888 8S@88 8S@SSS8 @@@@@88 8 88SS8SX8X8SS8 S8S8S88@888:888%8 888 8 8SX8S8 8 88@ X88 8 8 8 8SXS88 88S8%888SXSSX8S88 8 888S8 X
@XS8 8 888@8SSX8:8S@ 8S88.8 8 S8%S 8 X88.8S888@ 8 8 88XS8SS8 @88888SX8X@ 888SX8 8:8 8 S @%8XX8:XS8 8 SX8 88@ 8X88%8S8;888S@XX8@8:X8SX8XS8S@8S8;8SS8SX8 8 X 8 S 8 @@8 XX@88X8SXS8888 8 88S88X8 88888SSX8X@ 888SXX@X8 XSS888SSS8:8%8X88 XX8 X8 S8 888 8 SS8  8 8 8S8SXSS8888 8 8 S8 8 S8S@@8S8S8 8 8XS8SS8 S8 
@@88S88S8X8X8S8 X@8 8 8 8@8SS8 X8%888 88@ 8 88X8 888 8 X 8%@888S8 8 8 8%8@@@8 X8.@888 8 S8:8 8 8 S888S888 8:8X8 @8 8 8X888S88@@S8 S8X8S88@ XX88@8 X8S%S 8 88@ 8 8 XX8%8 S%8 8 8 8X@8 8SX8 88@8 88888 8 8S8 8%8 8S888 8 8XS8 8 8@8%8 88 8 88 888 88 8 8%88@SS88X8X88S8 8 X88 88@S8S8888@8 XX 8;XS8S8 88 88SS8
@@%8S@8@ 8SX 8 8X8S8X8S8S8 8888X 8t8%8.8 88XSXXS8 8SXS8 8 8 X@ 8%88@SSXXX8@@ @ 88 8X8888 88 8 88X8S8 @88.X 8 X88SS 888X8SS@X8S8@ 8 8 X8 8 8 8 @ S8 888X888 8 888 8 8 888S8 88888 8X@8 8 888%8 8.8X8 888 888 8 8 8X8@888@8 88 8X888X8 8S 8 8 8 S8 XXS S%88 8 X8%8X8 8:8 8X8 SS8 8 888 8 S8%8 S8 8%SS8SX8 888S
@8 8X8%8S888XSX8@ 8S@88X8 X88 XXS88 XX8t8 8 8 8 S888%888 S @S8 XS8SX8S888SX@8.8 8@@8 88 8 S888 8 8 X8S8@8 888%XSX8%88SXS8 8 %8X888XS8SS8.888X8:8 88 888 8SXX 8S8 S8 8 8 8 8S8@888 8SX8 8 @@8 888 8 8;8 8 8 8 888 8X8S8S888S8X@8S8%SS8:88XX%88X X8 88888S@8 8 XX 8 8%X8S8S888S88X8 8 X88 X888%S8 8 8 8 888S8X
@@8 8SX 8 S888X88@ 8S8X8.8X8 8 8%888SX@8 8 888%8 8888S8%8 888:8 88X SX 8S88SXX88X8X88 8 S888 S% 88@  8X888 8 8X8888 8@SSS8 8SS8 S8X8.8 88 88S 8 8 88X888 8 8 888 8888@%8 S 8 8X888 8 X8 8X8 8 8S888t8 888.888 8tXS8% S8S@ 8S8%@XS8 888 8X88S8 8 S8S8%X 8 88X8X8SSS88S8SX8 S8 8 888.88X @ SX88888SS 888 8X@%8
@XS888 8 8SX888 XX8;8 @ 8 8 S 88@X888X8 88@@@ 8 8X8X88 S8888 S88 8 8X8%S8 88SX 8888 88 8%%X 8 8 88S8 S8S8 8 8 8S8S88 8 8 SS8S8 8 8 8 X8 88:88 8 88S888@ 8 888S8 8t8 8 88@ 888 8X888 8 X8 8 8 8 8 8:8 888 8 8.X 8 8 8 888 8 8@8S8S88%8XX 8:8%8XX8 @S8 8 S8%8 888888%S8 8 S8 SS 8 @;XS8%8 8S8 X8X88X8S8 X 8S@S
@@8 8 888 888S88 8.@88 8 S 8 8 8 8X8@8XS88S8S8 88@ 8 X8X88@@S8.8X888@@8 8S@S8%888 8S88XX88XS 888 SS@8 X8%XS8S8:X 8%X8 888S888 8 888 8 S8 88 XS88 SXS@8%8 88888@X 8 8 8 8 8 8 X 8X8 8 8 X8 8888888.888%8 888 8 888 S88S888 8SXSS@8 8@S8%8 SS8X8 8 S8.88@ SS@8X8%S888SX8t8SX8 8 88;8 8.888 8S8 XX%8%X888 8 8 8
@XS8 8 8.8:XX8 8 S88X%8 8 88888 8.8X8SX8 8 8 X8 8 8 8 S8S88SX88 8%8S8%X8;8@8 8 XS8 8 88@888 8 8 8 8SS8 88888@XX8 S8 8%SX 8;8 8t8.8 88@ X8SX8 8 88@8888%88;8X888 888.888 888 8 8 8%8 8%8 X8S8%8X8 8 8;SXX 8 88@.8%88XX8S888 8 8X8.8 8 8 888S8@S888 X8%8 8 8 88888S8 8 S8 8 S 88S88 888%8 888S8 8SS8%8 SX8 XSS]]


--[[@@@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8
@888X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8
@@8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 
@XS8 8 @S8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
@@SXSX8%8@8SXXS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888.
@@8S8%X8X8%@XX@8X8X8 8 8S8%8.XS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.X
@@XSX8 S8 @8 8 X@88@8 X 8 888S88@.XS8:8S@888X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8%
@@X8:S8SS8SX888 8 8%X8S8 8%8 8S888S8S8 88SX8 888 8%888 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX8SX
@@X@8%X8XX8S88 8 8X8 XX88 8 X 8S888@8 8 @8SSS 8 8 S88.8S8SS@8 8X8SX88 8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 888 
@@8SS8 88SX8%8S 8S888S8 SS8888X8S8@8 X88 @8 8 X888 8%S@8X88 88@8 8 888X8 8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 8 8.@
@@XXXS8SS8 @8 8 888 SXX8S888:8 S8X@@8S8@8%88.8 S8 888X8@8 @8 8S@88@ @8 S88888%8t8 888 S 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 888 8 
@@X8SX888 8 8 SS8XX88@8 888 X 8S@8X8 8S8 8 8X 8 88.8 8 8:8 8 X8 8X@8S88 @ 8 SS88 8 8:8%888 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 8 8 8X8
@@XX8 8 X8 88@ 8X8S@SSS8XX 8 8 8%X8SSX8SXX8 8 88S8X 8 8 SX888 SXX8SS8S@8.8 8 8 X8 888 8 8.S 8 8 888 8S@ 8 888 8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 888:8X8 
@@8SSS88 8 XX 8:8 8 8%8.8 8 888 8 X8S@@8S8X88@ S@88@X888S8S@ 8S888X8 8 8SSX 888 X XXS888 8 88@ 8 8S888 888 8SS8@ 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 8 @X8 8
@@XXX@8X8 8 8 88X8S@8 8888 88@ S @%X8S8 8X888 8%8 8888S@8S8 8 888 8 X888888S88 8 8 8 88 X88 8 888 8 8 8 8 8 8S8.S 8%8:8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8X8@8 8 
@@X8 88 XSS888S88X8%X888 X8 8.8S888S@8SSX8S888@8 888 X8X88 888X@88 8S8 8 X88@8%S888 8S888X 8 888S888 888 S 888.8S8 888 888@8:X 8@8 888S88X8SSXSS88S888 8@8 8%8@8S@S888 %88X8:X 8@8 888S88X8SS8 888 S 8;8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@888888X8 8 X 8
@@8 8SX8S8 8SXXS8 S8%S888 88 888@8 8 X8S8 8X8X8@8S888 X8SX@@8 8S8SS 8:XX8%X8SX8 88 S 8 S88@X8.8 8 8 888 8 888 X8888 8 8X8S8 8S8 8 8X888S8 S888 @t.t;8;8XXSXX8S8%8S8X8t%8t8:X8@@@S88X@88S8 S8 S8.8@8S8SS@S88X@ 8 888 88888@8@8SXS88@8 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@@SXSX 8 8 
@XS8 8S88@8:8%8 8S8 88 XX8S88X888@%@8 XSSX 8 8X8 8S888 S8X8 888X 8 8 8 8 8SS8SS8SX888@8X%8X88SX888.8 8 888 8 8X8@8 8 8S8 8 8 88XS88@S88t88;888t8XX%XS8X8@8@888@8%8S@XX%S88S888888%8 88XX 8.S8 88@X 8t8 8 8 8 X 8 8 8 XS@88XSXXX8:@8@8 8:8 S888S8 8 8XX8 X8SX8X8S8 S8%8 8 8 8XX8 X8SX8X8S8 S8%8 8 8 8 88888X8
@@SS S8 8 8@88%8 X88S8@8XX8 8888S8S8 8 8S8S%XS8 X 8X888S@8 8S8X8 S8 888 8S8 S8SX8 X88@88 8 S8888XXSS888 8 X@8 8 8 8 8XX%8 888 XXS8 8888t8X888888@8888@8888@88@8888888888X88@888tS8@%8888@ 8 X8 X8S8 XS8:8 X88 888 X 8 8@8 8 8 888 8%X8 8 8%8 S@S8X8 8XX8S@8SX@X@@8 S8X8 888 8XX8S@8SX@X@@8 S8X8 888 8 8888@8
@@8888SS @X8%@88@S8@8SXX8 8 8 8 8 8 888:888S8 S8 8 8X8@8 8X 8 @@8 X8S8 88888 8S8 8%S88888 8 X8SX88S8SX88 8X8SXX8X888 8 8 888 8 8@%%888888X@88S@888SS88@X@88888888@S88S888@88X8X8X8@88888@X88XX8%X8;8S8S8 88X 8 8 8 88@ 8 888XSS8.8 8 X%S SS88S8%8S88 8SS8 XSX8 8 S8 88X@88 8 8 S@S8 8 8S8 8%8SX8S8 888 SS8X8
@@S%S8S8 S8 8 8S@8 8X8XSS88@ 8 8 888 8S8 8 X 8.88 S%8X@XXXX8 8X8@8 S8SSX8X8@8 888:8%X8X8:8%8 8 8 8X888X 8 8;8 8S8.XXS88 8 8 8@8%@%@88@SSSS8XSS8SS88X888S@8X8S8X@SS8XS8888@8SS88888888@8@8@888.X@XX8 88888S88@X88XS888@8 8X8@88 SSSS88 8 8%8 X8 888 SX8S8 8 8 8SS8 %8 8X8XX8X8:8 8 SS88X8 S 8 8 X888@X888X88S
@@X8XXXX@8X8@ S8 SX@8 8%8 8.888%S88 888 8;8%88@ S8S8 XXS8 888 8X@X8S8X8SX8X8 8 8;8 8 8 8@ 888 888S8 S8 888 XS88XXX8 8 S%S 8888@8888X88888XS88888S888S88@888S8X8S@S8S88X@SS8888888888888X8X88S8888@X S8888SS8X8:88@8@888XX8 8 8 888S8 8 888.8 888XS8S8;8 S 888 8S888X8@8 8X8888XS88S8%8SS8%8t8.8 8@8SS 888@8@
@@XX8@8SS8S8S8.S8 @ XXSS8 SS8SX8%8%S 8 X 888 8 8.X8888 8 8 8;8 8X8%@SS8 8 8 888 888 88XS8S 8 8 8 S 8S@8 8 8 88@8XS88.8 8S ;888XS@@S8SXX8888S88@X8S@SS8888SS88888X88888SS8888888X88S88@SSS88@@888@888 8 @S8 XSS888@8 8:8 8 8 888 88888 888 8 @%88@@ 888;8%8.8 88@ S8%88X888 @88S8XS8.8 8 SS88@8 8 XS8S8SX8@8 
@@8XX@%8SS8 S 8 S8;8 8S88@%888XX8 8S8 8 8 8 8 888@88888.X8888X8S@@8S8 SS 888X8 8%8 8 8 X 8 8 S888 8 8%X8.888S8 XS8.88 88@t8888SS888XS8X888S:8XX8X8S@X8S888S88XXS8888@X88888888X@@S@8X888888S88@S8888888SSS8%8 X8 8S@XXX8 8 8 8 8S8X8SS88 888:8 888@@8 X%88X 8 8 8 8 888X8 8 8:8 8S@8 88@S8%8SS888 888 8 8 @@
@@XXSSXX8S@8S88X S8 888 8 888 8X@8 888 888 888 8 8 8@@88S8X8@8%@8SSSX8 88@SXX 888 88@ 8 8 88X 88 888 8 888X X 8%8S8 888@@888@S888SXS8X888S8@S8888S8X88@S8S888SS88X@S888888X88@SS88888888X8X8SSSX@88S%88 8S8888SX8 8 8S8S@S S8 888 8 8X8 X 8 8 8 @8@8%X88888S%8 8 88XS8 @ 8 8 8 88@ @8 8 8S@SXS@8 8 8 8@8 8 8
@@XXX8X8 8SX888 8 X8 8 88XXX 8 8S@8 8 888 8 8 8 888 8 X 8;888%8SS8 8 S 8XS8S8SS8%8 8 S 888 8 8 88@8 888 8888S8 8X8 88888@@@88888@S8S888888S8SX888888888888SX8888@8SS8SXX8888XS888@SX8888X8888S@S8XSXX88%XX8.SS8 X8 8 X 8X8X8SS88 8 888 8 8 888 8 8 8@S%S8SX8 88 888 8:8S8 8S8X8 8 8 X8 8 8 8 8SS%88X8 8.X 8 
@@8X8 8;8 8S8 88888888888 8S8 8 8 X8;X@@SX%X 888;8 8 8 8 8X888S8 XS88%8 8 X8 8 8 888X88X8 8 8 8X8X88 8 @ X@888S8 S8t8888SSX88888S8888888XS88X8X;8@88@@@@XXXX8S@XX@8888888tt@88@@8888888X8SS888S88888X@8888@8%888%@8 8 8 8 8S8 8.X 8S888888888 8 888S8S8SX8XX8S8SX8SX 8 888:8S8SS 8 8 XSX8 888 8S8888%8;8 888
@@XSSS88 8 888@8 X8X8X8SX8 888 X88 S8S8 8%8 888 8 8t8:8;X 8@8@888S8 X88888X@8 8 88 888SX8XSSX8t888S8888@888 888 8S8X88@SS888S88S88@@S@88888 8@S@XXXXX@X@SXXSS8 8S8XS8SX@@XXS@88X8XX8@XSS8:888X8S8888888888tS8888888888 888 S88:8 888S8X8S8S8 888 8 8:S 8S@8SX8X8 8 8 888X%8 8 8S8 88@S8 XS8 X8X8 SX8 S8 8 8 
@@X8888X8X8S88S@8%X8 8 8 XS8SX8S8 8 XS8@@888 8 8 888XX 8%8 8X8S888@8S8 8XX8 X888 8 8X88 8 8 88@X8@8S8X8S8888@@ 8 XS8@88SX8@X8@S8888SS8S888XX8SXXXXXX8 8 8 @X8 8 XS8 8SXXXXX8SXSX88X8SS88888SSS88@XX@X8S888@8S8 8.88SX 8 8 8S8%SX8 8 8 8 8 8 8 8 8 S 8S8;8S@@XS888X88@SX@X8 888.X%8 8 8S888X8 88S8 8 8%SS888 
@@XSX8@X8%S8X@8XX8%@8 8;8 8 8 S88888 8X8S88.@88 888X8S88@ S 8 8X8@@@888 8XX8 88 888 8 8X@8 8 8 8X8@88S@X@8SXX8 88S8888S8@X8@88XS88888.@X88S8 @X8X8 8 8 8 8%8 X 8 8 8 8 8 8 X8 8S@SS@8X88S88S888XSS8S8X8S8S888S8 8S@88X8 888%S8S8SX 8 888 8 888S88@ 888 8@8 88X8X88@8 8 8 888SS88XSX8 S888X8 888 SSSS888 8SX8
@@8@8 8 888S8S@8SS8 XS88X888.8 @ 8X@8 @%8 88S888XX 8 8 8:8S8 XSXXX8@8X@8 8SX8SX8X@88 8S8 888SS8 8X8X@XSXX8 8S88t@8X8SSSX8SS88@8@S88X8@@XXSSS8SXXXS8 888 8 8 8 888 8tXS8 88XS88 8 8SX%X:@X8X888888888S8888888@8%X 8 X8%8888 8 S8S8 888 8 888 @ X@8 8 8 8 8.8 XSS8 8S%8XX8 S8 8 X8888S8%8 X8 X 8 8 88X888888 X
@@XSX8 8 S8 X8%88@S8 8 8 @ S8 88@ 8XX8 8 8SX8 8X88 XSSS88 88@X8 8 8 8X8 8 8 S8%X88X 8 8 8;8 8S888X 8 8S8 8SS8 St88888;88S888888S8XSX@XXXXXXS8 8S8S88@8 8%888S8 8S8 8888X88:8S@8 8 8 8%X8@8X8888XS88S88888S@88888 S8 888S8 S 8 8@ 8 8 8 8 8 X 8S8 8X8 888 8 8 8 8 X8X8S888 X8:8 X8 8 88:8S@8 8t@ 888 888X88XX
@@X8 8 88S88SX8 X8SX8S8 888 XS8 8 8X888 88@S88S8 8S8888X 8 8 888 8 8 X%888 8 888 8S8 888t88XX8X8 8 SXSSS8:8 S8S8@@X@@@88S88X@8888 XXX8 8%8 888 X 8X8X88@8S8 S%8 888 @8 8.8X 8%88888SS8%8 88S88S8S@S88888XS8X888X8 8 SS8S88%888S88S888:8X8%88%%8 8S88888 888 888 @SSXSS8S88 8@X8S@8 8%8X@8 8 88%X 8 8.88@SXSX
@@8 88@ XXSX8  8 8X8 S%8 8 8 88@ 8 8X888XX 8 @XS888 SX888X8 8X8888888%8 8 88@ @8XSS 88X%@%8X8.8@S 8%88X8 X@8 @@SSSS8@8@@8XS8X8@S8X8 8 8 888S8 8 8 888X8 @XS888@88@ 8S8888 8 S8S8S888 SSX8 88@S88S8S8X8XS8S8S8X@.S88@ 8;8 S8S8 8 8 8S88X8 8 88%S88@X8S8@888 8 8 8 8 8S8 8 X8 8S88XS8 8%8 8 S8 S88SS8S8 8 8 8 
@XS8 8 8 888@8 8 X8t8 8;S 88@S8 888 8S8@88 X8 8 8SX8X8S8%888.8X8S8SX 8 8 8 8.8XX8 8 X8 8S8 88@@888S8 8%S8S8:::SS8X8888888t8@@S88SSS8 8t8 8.X8 S888X@S8 8S8S%8 888 8 8SS8 8 8 S8 8S888 8 8S@S8X8S888@X888888888X8 8%88;8 8S8 S8 8 88@ XSS88@ X8SX8 8@8S8X888 S 888 888 S 888SX8 @8XS88@ 88@ 8S8.88 S888 8 888
@@SSX8888X8@8 88X 8@S888S8S8 8X8S8 8 88XSS88 8 888XS8X8888%88@8 8 8S888t8X8 8%8 SX88 SSX888X8 8 S8 SSS8 S8 Xt888X88888@8S8XS88;%XX88XSS8888XS@8 @S8 8 8%8%8 SS 8 888 8SX888:8SS8 8XX 8 8 8S8t8S8S:S@@XXXStSSXX;88@8 SSS888 8 XSS 8 X888@8SX8 888SX8%SXX@@@88 8 8 8 8 8 8 8 8 S8 8 8 8 8 8 8888XS88X88@8 SX8.
@@88888S8XSX88 8 8S8 SXS8;8 88XXXX88@X@8 888SS 88@8 X8@88S888@S8 8 8 8;88@S8%8%8%8 8S8888%8 88@8SS8S88@8 8%888@S88888X88SS8@S88XX8.@88 8 8S8 888XSX8X8S8S8 8 8 X888 S 8%88 8S8 X8 8S888 S 8X8@S8SXS8%@SX@SXS8SXX8SS8 8 88 88@S8 88@X@XX@@8 88.888 S8 8%X8X8 888 S%888 888:XX88 888 888 888 8 X88%XXSXX@8S8S@
@@S%S888%XX8S@8 8 X888X8 888SX8%8S88 8S8888 8 888XX8 88S@X 8.8%S S88@;8 8 888 8@8;888 8SS8X8S8 @8 S8S8 88 888@888X8SSX8888888SX8 @8 88@:8 888S888X8S8 8@8 S 888S8 XX8SS8SX8S8X8S88t8 8 8 8 8X8SX8 8 8%@XSXXXS8 8 8  88@S@8 8.S 88@ 8S8 8 X8 88X@ @S88%8 8 8888 8 8%8 8 8 8S8 8 8S8 X8 S @ 8 888SX8XXX8S@8 8 
@@X888S88SSS8S@8 8 S888%8S8%8 %8S@SS8 8S8 8 SS88S8X@8 X8%8%8@ 8 8 8%SS8 8%%8 8SX88X8 8X8%8XS8S8 8S8:XX8S88 88XX88S88S888S8SX8;SS8SX88888X8X8 8S8 8@8 8S8:8S8 8 @ 8 S 8 88XX8S888 8X 8 SX88@88SXSS8 8 8 8 XX8 8SX8X8 X8 8%88@8S8 8:XS88X@88 @ X8S8 8 8X8 888S%8S 888 888 S 8:SS88@ 8 S8S8t888 8S8 88S8 8 S8 8
@@XSSX8 88SSS8 88X888@S8@8 8t8 SX8 888 8 8 8 8%8X88S@8S8@ 8X@S@8.888%888 8 S8X8 8X8X8X8@8X8SX8XS 8;8 8 8 88S8SX@S8XS8@888S8S88SXXX8%X8X8SS8S@@SS8S@X8 8;8 888 8 8 8 88@ @8SSS8SX8X8S 8S8 8@8 8%8 8 S8 8 8 8 888 @ S888 %8X8SX8;888S8%8 8:8 S8%X8t8 8S8 88@X8 X8 8S88%8 8 888S888@8:8% 888%8 S 8 8 SX%8 8 X8 
@@8XXSX8%X8XSX8X8 X 88X88X@88@888S8S8SS 88888 8S8SX8SS8S8 S888X 8 8 X 8 88@S8SS8 8%8 8X8S@S8@8X8 S8 8 888S888888X88888S@S888S8XXX8:8 SSS@8X8S88%S88@@8.@XS8SS S88888@8 8%X8 8 8 S888S@8 8 X%8 8 88@ X8 S 888 8 88@ X8 8 88@8S88XX 8@888 8 8 S8 8@@8:888%8 @ 8 XSX8 8@88@888 888888X@8 XX%8 8 8 888SX888 8 X8
@@X8 8 88@X8@8 X 8 @ XXSX88@8 8.8 S8X8 8 8 8 888 8S@8SS8X8XXSSX88@ 8 8 8 8 8 8 S8 8 888X8S8X8 XX8 S8 88S 8@8SX88XS8888S888X888@8 8 X8 8 S8 S8 888 888S8 8%S888%88888XSX8S8 888 8S8 X8X88X8 888 88X 8 X8 88@ 8 8 8 8 S8S8%8S@8 88S8 8X8888888 S8S8 8X%8 8 8 8 8 @ S8%8X8S%X88.8 8 8@888 8 S8888@ 8 8 X8 S 8 X
@8 8 S8 88%SSS8 888 8S8 8 8 88 888S8 SS888888 8 X 8S@8X8 S8%8 8 XX8.8 XX88@X X8 X8 888S8 8X888@X88 X8S8S88888S@8888X8S888888@8@8XS8 S X8 8X8 8 888@8 @8 S8 8X8X888SX8 8 8;XS8 888 8 %8S8S88 8 8 8 X 8 S8X8 8888@ 88@ S8 8 8 88 8 8SS8S8888S@8 SX@8S8 S8 8 888 88@ SSS8S8S8 8X 8 8%@S 88S8 88@8 8 88XS888888S
@@8 888S@%XX8 %888888@@8 8 8S88XXS8 8 8 8@88X@ 8 8 8S@8%8 8 SS88%8S8 8 8 888SXX8S88S888 X 8X888S8 8S88S8 8X8SS88S@S88888SS888@@@8 X888S88.888X8 88SS8SS888 @88S8888 X888%8 8 8 8 X88 X8 8 8@@88888%888S8 8 X8 8 8 8 8 X8 S 8SX@X8:8 SXXX%@8S88S8 SS88 XSS 88S8 8 88@ 8@8888%8%88.8S88X8S8888 88X8 8.8 888X8@
@XX8 @ 8 8 888 8888X8@8%S8888 X8 8 88X88 8.@88 S888@8SXXS88@S8 X8S8;X8888X@ 8%8 8 8X8 X88S 8X888SS 8.88S8@888888S8SSX888@X8S8S8XS8 88@S8 8S8@8X8SX8XX88X8%8 S8%88SX8S8 SXS88888 8 888SS8 8X8S8X8S88@8 8 88@ SX8 %8 88@ X8 8 8%8 8XX8 8S8S8 8 XXX8 8 X8 88SS8 SS8888 8S8 8888 8 8@8888 S8S88 8S8%888888 88XSX
@@8;888 888 8 8 @8 8 8;8 8S888 X8X8;8X8 8 8SXS8 @ @ S8%8 8SS8 8 @X88 888S8 8.888 8 8 8 8;8 X8X8 8 888 S8S8S8888888S88888888X8888XS8S8 8SSX8%8S8 8 @8 888 X 8 X8%X8S@888S8 88%8 S 8%8.8SXX8888 8 8S8%88@88888 88@ 88 8 8 SS88SSS8S8 8 S8 88888%8 SS 8 S8 8 88@ 8 8%8X%888X8 XS88S8S8 @8 SXS88% XX8888X88 X88@
@@@X%8 8 8 8 888SS8 8 888 8X@ 8S8 @8 8 888888 88X8 8 8%88;8 X88@X8 88X8SX%8.888 888 888 8%8 888SX88X 8 S8SS88888@S888X8SS88888888SX%8 S8S8.XS8 X 8 8S8 XS88 8 S8 8X8S@X8S8 XS8 8 88 X@8X8X8S8@ 8 8 8S8 X8X8SXS8.8 S888 8S8 8S88XSX8 8S88@8X@ 8:8 8 X8 X888 8 88@.8 8%SS8@S8S8S 8 @@8 X8 8X8%8S8 %X 8 8 8 XX@
@8 8 S8 888S888 8 8% @X888@S@8:888 XSS8S8X8X88:8%88@SS8%8X@8S88 8X8 888@SXX8X8 8 8 8t8 888 8 X8X8 SXS88 88@8XXXSS.8@SSS8@888888@8S8 888S888S8X888S8:S 8 8 8@88SS888 8X8 @X8S888 8 S8X8 8 @88S88SXS88888 SXX8SX 8 8%8 S888 888 8S@88888S8888XX 8 888 8X8 8 8 S%8;8 88X88 8 8 S8 S8X8@8 SS 8@8S888S8%S8 888S8 
@@8 8 X8 8:8 8 8 88@%S8S8S88SX8%8 8S88@ XX@XS@8 8S8 8 88@8SX8 X8SS%8SX@8S8SX8S888 S 8 8t8 8%8 XSS8 8 8S8 88%888S888SS88888X88888888t X8S8SX8X8 888S8 8 88X88 88%8SX8 8 8XS8888 88@ S88S888X%8 88888%8SX8 8SS8 888 S88 XXS8 8 8 8:88SX 8S8 X8%888 8 888 8t8;8%8SSS8 8 SS8 88@:%@8S8X888 8%X8 8S@ 8:8 8 @8 8 8
@XS@ 8 X8;8 8;888S8 8%@88@%X8 8 88:888 8S8 8X8 8 888:8SX@S8S@8%X88S88@@ 8 8SSS8SX888X%88 888%8 8 8888 8X8SXS8888X8SSS8@SSS8888@@88S88XXXS8SS8X8 X8 %88888 XS8%SX%8S@8 S 8S8X888 8 8 S8S8 8 8 8 X8XX8 8SX8 8 S%88X8%8 8 8 88:888S8 8 8 S8 8 8 8XX8 X88 888 888:8 888 8 88@X@@8SS8 X8X888:8 888@8 X8 8 8 SS8  
@@8SX 8 S888 8 8.XX S8 S@S8 8%X8S88S888.8X8.@XS88 8 8S8%8 88%S8 888XSX@8 8SX8%%888X8888X8@XS@X8:8 8 88X8 8S8SX8XS88888S8S@8X8SS8S88@@S88S@88@@@8 S888 8XX8X8SXXX8%8S@8 8:8 8X8S@8 S8 8 8888 8S8 8SX 8 8 SS88S8 8SS8S@8 %8 88X8 8 88@.8 @8 8 8:8 888 X8@8 8%8 X8888S%S8.8%8S8 8SS@SS8X8 X88XX8S@8 X8 888S88@S
@@XX8888 X@S888:8S888X8SSSS888S88SS8S8@8S@88S8 8S8@8X8@8X8 8@ 888SSS8 8S8 8 888X@SSSS8@8X8888S8X 8t8SSXSX 8X8888X88@@888888SS8S8@8888S888@88@8888 %X 8 8SX8X8@S888 8 S888 8 X 8S88888X8S8S88.8X8 8S888 8 8 XX88X8SS8 X8 88 X8 8 8 8 8 8 @8 888 8:@8X8S@ 8 8 8 8X@S8888%X8 8;X888 8 8 @8 8S8 X8SS8%X8S8 @88 8
@@X8.8 S8 8 8XX8.8:88SX8 888 X@8 8  8X8XS8 SX 8 8S888@8S8S8S8SS8 8 8 888 88X X8SXX8888SS8 S@8888 S8 8 8S8XX8SS8%8S8%8X888@S8@8@SSX8S8S@S@888888888 .8@XX8SS8S8 8 S S8 X8 X 8 8 8 8@@88S8%8 88S8S888 8:XS8:8S8%8 88XS8888X@8 X88888XSS8S8 X X8 88XS8 888S8888X8 8 8.SS8X8;88888SX@8%S8S8888 888X8 8 8%S88X 8 
@@SSSX8 S888 8S8@XXS8 8 888 8 88%S8 X8%8  @S8S888X8 X@XXX8@888S88.888 8SS @.8XSXX8 8888%X8S8 8 8 8:S888@@8 @X8S888X8X88@S8S88S888888@SSS8XS@@88@%SXS8888S888.S@ 8 888X8 8 888 8 8%8 888X@@8S8@ 8S8 8 8 8 88888 8 88 X8S8@8 8 888888X8%S88S8 SX8XX8 8 %8X8888@888@X88X888X 8S8@88 888@X88S 8 8 8 8;8:8 @8XS 8
@@888XX8 X8 8;8%8 8SS8X8%8 888 8X88XSSSS8SS8 8 X8 S88SS@8S8@8 8 X8S888@8 8 8S8 8 88 8SX8SS8S@XS88;8 @ 88888 8 8 888S8@88888888888X88X8@:8888888X88888888XS@8S888;t88 88888 8;8@8;8 8SX@888 888888888888 8S8 8X888S@8 88@8 S 888 8 S@88S8 8 8 88@S@88@ XS 8 8 8.8%8 8S888S8 @S8 88 88S8;@8%S%88SS88 X88 @8%8 
@@S 88 X88 888 8 8 8 @ S8 8X8@8 8;XX88X888 8S @ S8XXSX8 888X88@8S%8X8X8 88@XX 8 8S88%@SS8SX8S8 8SXS8:8S@XX88 8 8S@X888@X888@XS888888SS8@X@XX88XSSSS8@X888X88@8888X88@tX8%@8S8SX8X%88888888888S888888@8888@888888X8X88 8SS8S8t8SSX8X8 X@88 S 8 8 8 88 8 8 88@8 8@8SXXXSSSS%8 8 8 88%SSS8 8 8 8S8%8%8X8 8%X88S
@@@8 88XS8 SXS888 888 8 S8:X%8 888 8 8 S8S8:8XS8:S8SX8S8S8 8S8SX8XSXS8%S88 8X888 8 8@S8 8X8 @@8;8 8 X8@ 8@88XX8 8XX8S@S:@@88S@88@88X88XS88888@8888S8888@S88S@8X@X@88X@X@:.8@@8 88X8888888888X8888888888%8888%@8888888888@SX88S8S@@8 8%8S@8S888 X88 @8 888S8S88XX 8S8SXX8 888 8 8 88 8 8%88 8.S 8;XS8 888 X@8
@@X@8SX8 88 8 8 8.X8 88@ @8 8 8 8 888 8 S888 8%88SS8SSX 8 8 8 8%X8 8 X8X8 8 8 8 888S8 X888 8X8 XS88XS8%888 @8X88 8S@S88@XX@88@@XX8X;88888@88S88XX8888S8XX8S888@S8888@S8@XXX8SX8 8 8S88@888888888888888@8888@888888888888X8@88 XX@8@8@8 8SXS88 8 X88 88%@X8%8 88X8 8 8 888 8 888 8SX88@8@%8XS88XX88888XX @S8X
@@8XX8 8S88SX8.888XX8 8 8 SX8 X8;XS8%88XS88 X8888X88@8%88S%8S8 8SSS @ SS88@888:@@@8S 8%8 S8 8 8 8 8 X 8X8 8.S8%X8 8 8S@88888XSS888X888S88@@X8888@S8888S8888888S8S8X @@@8SXSS8S@88@ @ 8S8@8@888X88888X8888X8888@88888888@8888888XS@@X@88 8 8 S8 8 S88%888@ 8 8 8@88 8X8S8 8 8 8S88@S88%8S8 8 888X 8 8:8 8 8 8
@@XXSS888 @8 8XXXS8S88 8 8%88@ S8 8 8 8 8 888888@8888S88888X8888888 S8888SSX8 8 8.@88:888 XS888 8% 8 8 8 @88 S@SS8X8 8S@X@8t8888@8888SX888888X@SS888@X8S888@8888@@X@XSXSXX8 8X8S8@8 8 88S88@S%888@888888@888@8888888888888888888888@8SX8 8 8SX888%XX8%X8 8 8 8X8 88S8%X@888X8 8 8.8 8@ 8 8:8SX8 8;8.888 SS8 
@@XXX88@ 8.X8X8 8S@8XX8 888 8 8 S8 8888888888888888888888X888888888888S8 @8XXX 8 8SX@8X@ 8S8 8 88@SS888 8S888 8S8S8S@@SXXX8SX@8S8X88SS8XS8888XS8@88SSS@@S8X%:@SSX8SSXX8 8S88;8 8%8 8 8%8S8 @8 8 88888@88888888@8@8@8@8@88888X88888888XX88 88@%88 8X8SXSXX8 88%X@8S88 8X8S88XX8 888 8X8 888@88 8 %8 8X888 8;8
@@8XX%X8 S8 SX@8:8 8 8 88@ 8 88@ X888X88888888888888888888888888888888888X8@8 888 888SX8 SS88888 8S8SX 8 8X8@888X888@8@S8%8S@SSX88tS88@88888SSS888S8S8X88@8@88 8%XSXXSS8:8 8XXX 8 888 8 8 8 8SX88@@@888@8@888.@@888@8888888888888888888 SS8 X8 8X 8X88S8 888X8S@X8SX8 8 8%@8%888S8 SS88S8@8 X8X8%S%X8S8SX 8 
@@XX8S8 8 S8S8 S8 88@ S 8 888 8 X8X8888888888888888X888888888888888888888888@8X8 S 8S8%8888X8X88S 888X888 8X8S88@8SXXXSSX8 8 8S8@8S8X@88.%8888888888%@%8@X@88 8 8 8 8 88X 8%8S8S 8 8 8 S 8 8 8 8 XXXX8@X88@88888888@8888888@8@88888888@@8S888 @S8SS8 @@ 88@@8 8S8@8S8888;8 888 SS8888SS8%888 88X8S8 X8 8 8 @
@@X8.8 S 888 S8 @8 8 8 8 8 8 8888X8888888888X888888888888X888888888888X88888888S88 XXX8 S888XXX88@@@8 8%S8 8 8 8888 8 8 8 8XS@8 8 8 8S8SX@S@888@S@8t8@@SXXXSS@ 8 8t8:8 8 8 8 X 8 S8 88@ 8 S 888 8 8 8 XXSS@8@88@88888.@88@8888888@88888888@%8 S8 8S88S8 XX 8 S 8X888S88 XX888 8 888SS8SX8X8@8 8SSX@8S88@@X8 
@@XX8 888 8 8:88 XS8 S88888 88888888888X888@8888888@8@8888888888@8@888888888X888888@8SX8 8 88S8.8 8S8888 8%X8 8X8@@8 888;8%8S8 8 8 8 X 8%8%88X@X88888@8X@XX8 8 88X88SSSXS8888%8:8 8@ 8 8 8@@@%8t8%8X8@;@;8 8t 88888888888@888.888@8@88888S8888 X8;8 X8 8 8%%8%8 8X@X8 @8 8 8 888 8 8 8 8 8X888@8 @ S8S8@8 8S
@@8S%X88X8 SX8888S88@ X8 88888X8SXS@@X@8S88XX@@X 8@8888@88888@8@8@88@888@888888S888S888 8.8%X@SX 8 8S8X@88XS88%@@XS%8 8:X8@888S8@ X 8 8 8 8S@8X88888888888888 8 8 S8X8 8S8@88888888t88%88X8X@X@X@X8XS8@S@X88@888S@X@@XX@888888888888@8X88888888%8X 8 8 8888 8  8 X8SS8 XS88888 8 8 8 S8 X 8X8X888;8 88XXX8.8
@@XX888S8 8%8 8SSS@8 8 X@8@8 XSXXX8 8 8 8S8@SXX8SXXX8S8888 @8888X8888X888@8888@88888888S88S8 8 8 888@88 8SX8 88SSX8 8 88%8X8 88888 888.8X8 8S88888@8@88888888S888888S88.8S8@88888@@X8@@888X88XXSS@S@8XX@@@8@@88@@SXXXXXXX@@X@88888@8@88@888X888XXX888X8 8 SXS8 S8 X8%X8 8 @ 8 888 888 X8 8 8X@@@@8 8 @8 8 8X
@@X8 X8@X88X 8 8 8SX8 @S@XSS8S88@8 S 8 X%8SSXXSS8 8 @88 8@@888@@888888@88@8888888@8888@888888S88XX8S8%8SS8 8S8S8 8 888 S8@8 888SS88 8 8S8 8X8888@8@88 @88888@88888888888 @88t8%8S88XX@@@SS888888888888S8888S8@88@@SXXXX8 8XXS8S8@8888@8@88888888@8.8 8.8t8S88888 8S88X%8:8 888 8 8 8 8 8 8X8SXX8%@8%8SSS88X8
@@SS88@8@8 8 88X8 8 8X@8 8S8 XS8 S88SS8S8SXX8 8 S8@8S8%@SX8@@X@@8888@888 @88@8@88888@88888888S8@8XXS88 8S88;8X888 8 @@X8XX 8S8%8S8 8 888S888888888@888888888888888888SXX8 8 @888:%888888S8XX8S8S8S8S888888S8X888@8XX8 8 8 8%8 8 8S8X88@8@88@888888SS8 X88@8 8 S8X88 88 %8 SS8 8 888 X 888 8 8 8 8 S8 8 8 8S8
@@8SXXXS88@X8X8%88:8X8 XS@88888 8SX88 S8@S8SS88@S8 X8X8 8SXXSXS@@@888@8@8888@88@888888@88888@8888888XX8:8 8X 8X888X8S8%X8S8 8 8 8%X88X888888X888888 88@8@8888888888 XXXSX8 8X@8S@SS@:@8X;8SS888XS8888X8@S88X8SS888@SS888 8 8 8@8 8 8S@X888888888888X 8S8@8%@@8S8%@X8 X8 88 8.S8888 8%8:8 8t8 8 8 8 X8 888 8 
@@XX8 8 S8X8 X 8 8@ 8%8 8S8 S@888@ @88X8%X888 8 X 8S8SS8 8 8S88 88@8@88888@88@8@@@8@88888888888X88888888 8S8 S8X8X@X8 8 8 8X88888888@888888@88@88@888 8888@8@88@@SS8S8 8S8888 8 8 8 8X8.%88888888888S8XS;88888X8@88XS8888S8%8X8 8 8 8 8 8888@8@88888X 8 @ 8X8%XX8@8 8 X8 8 S888 8SS88888 S888 888 8 S 8XXS 8
@@X8SS @%X88S88 8 8% 888 8:8%8@8S@8S8.8 8 8SX8 8 8 8@8 XSSSX8%@8S88 88XX888888@88@88@88 @8888888888888888@88888@888SX88888888X8X@8888888888888@8@8@8888888@8@XXXXXSX%8 S8%8X@8 8%8 8 8 8SX8;888@@X888X8X8XXS88888888 SX8S8 8:8 8.8SXX8X8%8@8888888888X 8 8 @88S8 8XS88 8%S8 S888 8X8X8 8 8:8 888 888X888S8SS
@@XS8%888 X88S8XS888 8 8  8 8 8 8 SSS8S8;8 8 X8t88@X8 8 8S8 S8 8 8 8SXXXXS@8@8@88@888888888@888888888888888888888X@888888@@888S8888888888888X888@888@88@8SXXXX@XX8 8S888XX@8 XS88XS88 8 8SXX@S8SS8888X888@88X88888888X8SX%888%XSX88X8S8 8 @@@X88@88888X 8888SSX@8@8 8S8 888S8S@88 8 8 888 8 8888 X8 8 8 X%8X
@@8SSX88 8X8 8S8 88 8 88@S%888 8 8 8 8 X8 S 8 S8 8 8:XS888 8 8 X8 8 8S8@S8 8X88@88888X88888@88888888888888888X8888888X8888888@88888888888888888X88888888SXXX8 8%8 888 88S8XX8 8 8 8 XXX8X8 8 888SX88888S@88888@8XS888 888%88.8S8 8 8@8 X 8SSXS@88888888888 8888%X888:SS8 @ 88@X8SX8 8 88 888:8 X8 S888 8 8 X
@@XX8S8SXS88SXXS8SX888 8 8 8SX8 S 888 8 X8 88X @8 8 8 8 8 X88.8 XSSSX8X@SX@8SX8X@8@8@888@888888888@8@88@88888888888S@888888X8888X88@88@888 @88.@8888@XXSXX8 8SSSSS88 @S@8.8 SS 8 8 8%8%8SX8 8S@888S8888X8SS88888S8SS8X@8@8 8@@X 8 8S8.8S8 8S8@S8X888888888X8X 8X8SX@8 8 888 8 8%@SSS88 XS8S88XX 88S8S8 8888X
@@X8 8SX8 888X8 S8 88X8 888 8 X8S888 88@ SSS8.8 XSS888%8X8S@@8 8 8888S88%8S@8 XX88888.8888@8X8.8@8@88 888@8@88888888888888@888S888@8@888.888@8888@XXXXX8 8 888S8888S@@8 8X 8 8 8@ 888 888 XSXSX@@8X8X8S88888888S888X88XXX@8X8%8S8888 88@ S 888X8XS88888@888S8S88XX8SS8 8 8 8 X 8 8%@ X8S88@S8S8 8S88888S8X8S
@@SS8 8S88X@SX%8 SX@8 XS8 X%S8 SXX8888%@@8SX8888S8S8 %8X8 8SS%888 S%8S8 8:8 8X8 88XX@S888@888888888@88888@88@8@8888888@88X88888888@88888888@88@X@XX@XSSS8 8S8 888:888XS8S8 X888 S888 8S8 8S8 8 8 8@8SS888XXX88S88XXX88 8S8@8@888%8S8@8XX8S8%8X8S@X@888888 @X@8 @8 88XS@88X8t8S8 888 888 SXS8S 8SS8S8X888 8 X
@@88 8 8 S8 8 8.8 8 S8 888S888%888S8 8X8 S8S8X88888@8 SX88 8 888 88888 XS8 8 8 8 XXXS8@S8888@@88@88@888 88@8@88@888 X88888888888@888@8X88888S8SXX8SS8 8 888 88%@X8 8.8 SSX8 S@@8 88X8 8 8;S 88@ @ 8888SX88888888@SS88;% 8@8S8X8@8 8S@@8 888 XXX8%8%XX@8888@@@X8 X8%X8X888X@8 S 8 8 8 8 8 8 88SS8SS8%8X8 8 8S
@@SSX888%8 8 S 888 888%S8 8 8 8 X8X88 888 S8%8X8X88XX8 8 SS888XX8t8@8@8 8 X 888 8 8 8 8 8S8X88.888888@8888@88@8@8.888888@8888@8X8@@88888@XSS8 88%88%X8 8 8 8 8@S8 8 X 8S8 S8S8 S8%8 X8 888X8 8 8 88@S8t88X8@@@@8888X88SX 8 @S8X@88 8X8 8 8 8 8XXS@8 XX8888@8S8 8SX8 8 8 88  8 888.888SS 888 XX8 8 SSXX@8 XSX
@@X8SS8 888X8S8S8 8 8 @SX888 88@ SXX@8S@@8 8X88;8 X8SX8:8 8 8 8 8X 8X888 8 888 S 8 8 S 8 X 8S@S8888888X8@88888@888@88@8.88888@88888888@XXX8 @8 @8888 X88@ X 8S8 88 8%8:S 8.X888S8SS8 XS8S8 8SXX 8 88@X@88@888S88XXS8S8X88:88 @8S@88 8 X88 8 8 8 8 S@8 88X8@S8 8 8SS8X8 8 888 888XSS8 8888@ 8 88@@8 8 8 XX88X
@@8.8 S8X8X8%@88@8 88@.8 8SX8 8.8%8S8 8S8 8S8 @X 8 8XX 8 888.8X8S8XX8X@@888@8 8 888 8 8 8S8 8@SX@X8888@88@8888@8888@888888@8X888888XXSXX@SS8 88S8@8 8%8 S8 888 8S8X@8 8S888S8 X8X8 S8S888 8S8%8%8X8SSSX8S88@888@S88@@8XS88S8@8 8S888X8%8 XSXX8 8;8 8 8XX8@8SSX 8 8 @ X8 8888SS8 8 8:888.8 8 8S8SSS8 8:8 8 X8
@XXXS8 SX@8%8X8S8 8%8 888 8 8S 8 888.SS8SXS S8 8 8 X88XS8888@8 X8 8S@8S8X88888S8X8 888X8 88@X8@SXXXX8X@888888 888@888.@8888888@X8X8@SXXXS8 8X8S8 8 8 X88 S%88 88@S8%888X88 8.8 8XX8 X888 888 X88@8X@88888XS8888888@88%S@S8@ 8 XX8S8S8 8 8 8S888 8 8 8 8 X8 8888XX888888888 X8@8@@8:X8XX8S8 88X 8%88@ 8 888 8
@@88S@888%X8XSS8;888 8 8;8 88@S 8 8:8 888S88S8%S8:8 X88888 8 88S%SX8 XSSS 8X8%X8 8SS8S@88 8 8%8%XX8 XS%S888.88888888@8888.@XX8SSX8SX8 8S@S8:8X888@XS8%8 8%8 X8@8 @ 8S8X8 X8 S88;8 X8%8 S8 8 8S8 @ 888S88S8S888@X@888@%X@8S8SS88X%@SX%8 S 888 8 888 888 8 8XXSX8X8 8 X8X8SS8 888@8;8 S8 8 X8 XX8 8 XX88@%8 8 
@@SX8%8888X8S8 8XS8 888 888SX 8 X8SS8 S8%8S8 S8 8X @8 8 8 888 88S8SX8 8S8SX@ 8 S8.8 X88X 8 X8XS8 8 8 SS888S888@8X8888@X8X88SXSXXSS8 8 S888 888@8@8S88@@8:888S8 SX8 SX@XS8SS8 88X 8:S8:8 8 S8:8 8S8 @88@@88888S8S88@@@8S8SX 8 @8S8 8XX%8 8 8:XS8 @ 88X 8 8 8 8.X8 8;8SSS%8%X8 X 8 8;88SS 8 S88XSS88S8 XX8 S 8
@@XX@8%8 8 8@88S8SS8 @ 8 8:X88 8 S8 S8% @X888 S8 8 88XS8 8 8 @%S8 8 S SS88X8S%88 888 X8 88@ 8SXS888 8%X%8888@8@8X8888888888SXXX8 8 888S@%8%8 X@@XS8 8S8 8S8@888S8 8 8S8  8 888 8% 8 @8 8 8 88 888 8X@SS88888X88X88X8888XX88 8 XXS8 8 888 888S8 8:8 8 888 8 888XX8SXX8 8 S8 S8S8 8 X888 888S8S8 8 SX88S8 8S8 
@@8@8 8 8 8X8 @X%8S8888SS88S@8S 8 S8888@@8S888 88S8SX8S@8 S 88@ X888 8S8 XX@8 X8S8 S8 8 X8.X8@8 8SS8 8  t@X8X8X@@8X@S888@888X8 8S 8 8 8SSS8 8 8 8 %8:888@8S8S888@@8@ XS8 8888 8 8%S@ @8 888 SS88X8.888S8888X8XXX8888888%8 8X 8%8SS888 88@8 SS888@XX8 S8 888 8 8 X888@8%88@8%X8 88@ 8X@8 8 8X8X8%8S8 S8S8SX88
@@S8.888SSX8 8 8%X8888888SS8 8%888 X8 8@8%S8XX8;8 88XS8SX8 8 8 8 88 888 8 8XS8 X888 X888 SXS88SX 8S888S 8888SSS88XS8888888XX8S8 8 S8SXS888S888 8 8 88@8X8 8@8S8X8%8 8%88888XX8 S 88S8 @8 8 8 888X8@8X8888XSS88888S88%X@ 8S8%8 888 8S88 8SS8 8 8@8 888 88%8 8 8 8 S8@8%S88 X8 S%88S@@X888@8@8X8%S88@8S8 S8 8X
@@SS8S8 8S8SX8 S8 X @XX@888@8 X88 8 X8 XXXXS8SSX @SX8 888S8 888 8S@8 8:@X8 8 S8 8 S8 88 8 8 888 8:8 888 St8X888888t8S88888888X 88@ X8S8 X888XS@8888 X@%8 8@8@XXXXX@8 8 8 SX8S@8 888SS8XX88@88 8 8:888S88XS888SSX88@@.SX8;8X8 8 8 88@XX8 8 SS 8 S 8 @X88 8 888 S 8 X8%@8X 8 S8 8 SXXS8X8X8 @XX@8 8S8%@@8 SX%8
@@88S8 8 8;8 8 S 8 @X8S8 @8 XSX88XX8S@8 8 8 S8888 8 88 8888888.X 8S88 8 8 8;8 88.8 88 88@88@S8 8 S88@8 @ 8St8@S@888888XSX888X8@X8 8 S8 88 XS8@8@8SS8S8 8888S8X8 8X8 8 88@ 8 8 S%88 8 8%8S8X888:888888888S.@XS8S88@@8@X8%8S8 888 8 8 8 X888 8 S8S888SXS8 S8 8 8 888 S@8S8SS8 88S8%8 8 XS8 8X8X8 8 8:8X8 8 8 X
@@SSXX8 S 8 88@88888X 8S8 8 8 8:8 8 8 SX8 S8 8 X8%X8 X8S8X8S@X8 88@ 8@888SS888S8@X8 88X8S88%X 8 8 8 8 8 8@88SSS8XS@88888888@8888X%@8S%888X8 @8%X 8 S8S8X8X88S@%8 8 888 8 888 8 8 SSXSX8 XS8X@X88888XX888S88888SS888;S8 @XSS8.8 S 8 S @8S8 88@ XS@8 8 88@ XS8888S8 8S@S8 8S88S8X888SX8 8 S 8 8 8 S 8 8 88888 
@@X8S8 8 888 8 8888@S888 888 888 8 88@%88@ SS8 888 S8%X8SXS8S8 8 8 8S8 S8S8.@X8X8 S8SS888 8@X8 888 X@8%@XS88S8888S8S@XS888S8@88888 88SX8S8 8 X8S8.8 88S8S8SSSSS888SX8 888 8 S 888 8 @ X8 8 8 88X88SSX88@S8SX8888888XSS8XXX88SX8%888 888 8 X8 8 @ SS8 S8 8 888 8%X8:8 8 X@8 X8S8 88S88XS888888@X88XS88@X8X888
@@8 8 S 88@ X 8:8X@%8X@ 8 8 88@ S 8 8 X88S88888 8S8 S8 888 SSSXX88S8@S8SS8 888S%X88 8@8 8S8%8 8;X 8X8%@XX8Xt@S88S8X8S8S888@8S@8888: X8SSSSS88S@8t888S8 S@SXX8 8 X8X8SS @ 8 8 8 8 8 88X SX8 S:t@8@SSS8X8S888888S8@X8XXXX8 888@8:8 8:8 8 888 X888 8 888 888X SX8 @ 8@@8 8S8.88 8%8 SX%88X 8 8888XS@8S88%XS8X@@
@XS888 8 8 8%888 8 8 X88.8 8 8 8 888 8S8 X 8S8 8 8888S8X8@8 8S8 X8S88XS8SS8@8X8S8 8SSXX8 8 SSS88 8 8tXX8 8SX.8XS88XS88888S88888SX@S88X8 @S8 S8 X@X8SSS8%8 8 888 8.X8@8SS8888@ 888X8S8 8 8X%;S888S888888XSS88@S8S88 8S8 88S8 88SXX 888 8 8 8 88 888%8 888S8X8%8 X8S8S8888 @SS8@8 8S8 X88SX8 8.8 8 S8 8@S8%X8@
@@S8S8 SS88X8 8 8 888 88SS%S888:8 8;8;8S@88.@@888S@%8 X8S@@8:X 8%X8 8 8 8S8 XX@8S@X8 8S8888S8S8 888 8 8 8.8 8;8X8888@S88@88888XS8X8888%8 888 S8 888XSSS88XX888 88@S8SX8 888XX8X8S8 8X88;;8%8@S8S88X@X8X8.888SSS88@8 8 888%88t8 8%8 8 S 888 8 88@8SSX888 8%888X8 SXX8S8XX8XXS8 SS8888S 8888SS8 8S888S8 8 XSS8
@@8:8S8 8 @ SSX8t8 8:8 888888X%8 888 8888 88S8SX%8 XS@SS88XS8 88@S8XS888 @88S8 SX8SS888S8 S88@ S%8 888;88888SX.@8X88888888@X888S88@8888888X@XX88S8X88 888@888 888S@ 8 SX8888 8888;@8%t8%88888SS8888S8888888X8X88X8%8 8 8 8 8X@8 88@.8 8.8 8S888%X8 8.8 X 8S8 88X%8 X8 8 888%8888%8%@8SSSSXSSXS88@8 8X%X8 8 X
@@@8@8 888 8%8 S888 888 X88888 @8 8 8S8 8S8t8@8 8;8 8 8 888 S8 8 8X8S88%8X8 @@8 @S8 S8 S @SX8 8 8;S88 8 8 8%XXX@88XXX88X88888@S8S888XS@8@88S88.88X8S88:8 8 8 X888S8 S888S88@ X%t88SXX8X8@@X8SS88S@S8X88S@8X8888XXS8 888X8S8 8S88 8 S 888 888 SS8SS8SX 8 8 8 8 8 8%8 8S%8SX8S8.X8 S8 XX88@8S8 8 @ 88%8S8 88@ 
@8 8 8888 888 8 S8 8 8 8S8 8 X8 X8 8 8 8 X88%88888XS 88XX888 XX8 S8 8 8X888@8SS8SXX8 SX88 8 S888 8 8%SX8.8 8S8SXXSX8@888S@S8S@888X8SSS8X8888tS88888S%8%88@8 8888X8S8X@888t8@X8X8X@88@X8SSSSS8SXXSS888@S8888@88@X@SS888S8%XXS%8 88 8 8 8 8 888S8SX8%88@X888 888 888S8 8 @8 8 88S88%X88X88 SX88.8 8 88888XXX 8
@@8 8 888@X@SX 8 88 8 888 8 8.S8%S X8 8 8 X88@8X8S8S8;8 8X888X88XSX88XX8 @88X8 S8S8@8X8 8  8S88SX888 @ S8 S 8 8 8S.88S8X8X:8@XX88SS8S88@S888@S88@888@@%8@888888X8888888@88888XX@888SS888888888SS88S@S88888XXXX8 8%8 8 @ 8S8 8 @%888S8X@8 8S8@8X8 XXS8X8%X 888 8 8 8.XX8SSX8 8.8.X88 88888%8SX8 88XS8S8@@8S8 
@XS88@S8X8 8%8 88S8XXS8 SSS%88 X8888 8888XS8 @S8 8%X88@8 8X@@%@8 8 8%@X @S8S8 8 S8S@88%XS8 X8 X8%8S@8:8 X8S8;8 8 8 88888X88SSS8SX8@8@S8X8S888@@8888X8@XX@88888888888888@@8@SSS88S8SS8SXX8@88SSS8SSS8SS888:@X8S88 888 8 8 888;8;8%88888X8XX8S@XSX8S8%X8%8%8;8S@ 888 8S8 8 88@ 888 X88X8 8 8 8 888SXX@XSSS%888
@@8 8 8 8 X 888 S@88XS88S8 8 X8X@S%S 8 8X@8 8 8 8t8X8X@88XS8S8SX8 88@X8SX8 888X8 888X 8SX888X8 8@888XS 8 8 S8 8 8 8 8X;8@SSS8X8SS8@S8:8888X888X8X888S88888888@X888@888S88888888S8888S888888SS8XXSS.888X S@XX@8S88 8 S 888 8 8:8@8@8S@8 8888@8 8SS8%8 8X 8 8 8 88@ 888.X8888 8 8;8 @8 S@8 S8888 8 8X8@S8 8 8 
@XS8 8 888%8 8 8%8 XS8.8@8SX8 S8S8S8S88;8 SS88X S8 8 8 8X8SXXS8S@8 8 8 8%88@8SSS8 X8X8 8S8 XSX8X8 X8S8 8 8 8;888 8 8S8 8888X8XS8S888@888X88@@X8888@S8SX8S8S888S@8S@8S8S8S8X888@8S888SXX8@SS8X8X8S8SS888@XSXSS@8 8 S8 8 8 8 S 8X8X8%8 @8 8:8 S8 8SX8S8S8S8X88.8X8 8 8 8 8 8.88 88 8S@8%888 %888SS888X@S888 8%
@@8;8 8X88888 888 8 888%8 8S888S8@8%8 8X 8%8 8S@ S8 S 8 8X8S8 S8 X8 8 S@8 X8 8 SS8XXXS8 88888X 8:8 XS888 88%S88 8X8 XS8S@S88X88@8888SX8S8888@8SXXS8X8888X8888SSS8@8S888888888X8888@S8S8@SS88@X888;8@@@XS@XX8 8 88@ S888 88@ 888 888X8 8 8@X8S@8 8@8.SX 8X8 88%8 888 8 88@ 8S888X@ 8S88@8 8S@SSX88X 8 8 8 8 8
@@@8 S 8X8S8888XX XSX8 8 8;8 8888 S%X8X8SS8 8 8;8 X8%8 88X @ 8:X8%SS88X8 8 @8 8%8 8 8 S8X8 888% 8 8 8 8.8 %88SX8S8S8S8 8 8X8 888S8@SS88XSX8888XS888@SS88XX88SS8XX@88X8S8X888@@X88S8X8888888888;@XX8SXX@SX8 8 888XX@ X8 8 8 8 8 8X8S8X%8888S88XX8%@X8 8SS8 8 8888 8 88@ 8 S 8 S8X8 S888 8SS8SX8S 8 8 888.888;
@8 X88 X8 8S8XX888 @ 8 88 88X @888 8 SS@8 S888 8.8 8 S8S8S8S88@ X888S%8 8 888888 88@:88 8%8S8 8 8 888@:888SXX8 8 X888S8X8 8 8S888t88X8888888@X8X8@S8@8888888S8888888XS88888XSS888888S88888%:8@XX8SSXX8 8S88 8 8 8S 8 S%S8 888 8 8@8S88X 8 8 88%X8@8 88@%88 8S8X888XS8 8 8 88@%X8 8 X88SS8 8S8%8 8 8888 8 8 @
@@8 888 8%S8 8 X@8SS8.8 8XX8 8X8S8SS8S8 S8 88 X 8:88@S8 X8%S8%X88SS8 8 8 888 8SX8 8:XS88%8 8 888888 8 8 8;8 8 8 8S8 8 @ XSX8 8@8 8X@88.S8@@SX8X888S8S88XX88S:8@XS888@88@@SS888@@X88S8t88@XXXXXSXSXX8 8 S8S8X 8 8 8 X88@ 88 8 88@@8@8@8S8 8 8XX8SSX@8 8 8SX888 8S8 8 88@8.8 8.8 8 88X8 8 8 X8X8.88@X8 8@S8 8 
@XX8 8S8.8 SS@8S8 8 8XS8 8 8 8 8%S8 S8:8 888@8S8 X8@X888%88 88 8S8 8SS888 8 8 8 S8:8 XS8SX8 88X 8 X8 888SX 88888 8S88 X8 8 S8@8S@X8S8 8@S@88%8888S8888S8S8888S88SX888888S88X888X888XXX@XXX8 8XXXXX8SX88SX8%8SSSS%88 X8 8 S 888S@8X888X8 888 8 8 8S8S@8 %8 8%@8 8 8t8X8 8@@8 S88 8 8SX8 88@ SX8888 8%8%8 88 8
@@88S8X8XX8 @ S@88X8S8 88888888.8 X8 @8 888X8S888 8888SX8 88 8 SSS888 88 8 8 S @8%S @88S8 S8S8%X @SS8.8 8S8:8 8 8 8 8S%8888%8XSX8 88%8S8X8S@S@@88888:8t8XXXSX88888SS;;88;88888XSXXX@XXXX8 @8@SX8 8 X8.88 8888 888 S8 S8 8 8 8 8S@XXXX@88 8 8 8 8 @88%888S8 8S@8 888SX@8@8 X8SS8@@8X8 XS8 8S8X8X888XS8 S8 S%X
@@%8X8 8888%S8S8@8.S8 8SS8888S8S 8 88 XS8SXX@8S888%@888SX8 88@888888@8XX888:8%888%8 S888@@8S8 8 8 8 8XX888.8X8:X 8 88@S8 888 8 8 8 8SX@X8@SSXX8%X@@@S@ @X8SSXXXX8SSXXS8SX8S@XXX8 8SXSXX8 8 8%8 8% 8 88:88S8 8  8 88@8 8888888S@8S8 8 8XX8 888 88XX8@8 X8 X8 8S888SX88XX8 8 88888 88S8 8 888 8 X8@8 888 @8S8 
@8 8 88 8XS8 8 8 88 888@ S 88888 X8 8S8S%8%8 X8X@@8 8X88SX8S8 @XSSX8 X8 8%SS888X@S88 S8S8 X8 888.88@S8 8SX8S8:8%888 8.S 8 8;8 8 888 XX8@8SXX8 XXXX8S@S8S8 @X@XSXS8 8S8 8 XXXX8 8SSXX8 8 8 8S8X88@%S8 88 XS88X888@88  @88%8 88888X88.8 8S@8S8 S 8 8X888 S8%SX8S8SX8SXX8 XX88 @8XXXX8 SS888X8 S8 S8%8 8 8 XX@8
@@8 8%8888SX8 88XS88 8SX888 @8SX8 8%S8 8 SS@8S@8S8 8 8S@8%S8S8S8 8 X@SSSX8S8 8 8 8:88SX8 8S88X@ 8 8 8 888XS8SXXS88 X88%888 XS88@ 8 8 8 8:88 88X8 8%XSXS8:8 8 8@SSS8 8 8 8 8 8 8 8 8 S8 88@X8S888 8 88 88888SXS888SS8 8888S8 X8SX8 8@XX8S8 S@8S8 8 8X888 S8S888.8 @8 8 8 8 S8 XX8X8 8 888 888 8 8  S 8 X8 @ S
@XX888X8SX8S8888 8 8888%SXX8 X8 S888S8 8 8S8 8 8 88 @@8S@8S@8@S8S @ 88888X888@8@88@88@8 X8%SS8S888 888.8%8SX8S888S8X8 888 8 8 8 888 888 8 @8 8@88 8 8 8%X88 8S88 8 8 8 S 8 8 S 888 888 S8SXS8X8XS88 88 8@X@888S 8XX @S8S8X88SS8SS8X8S8.88@X8 8 888 8X888%@8 88SX8SS8X8:8:8 888X88888X%S88 8 88@:8%8 888S8 8 
@@8S8 8 8S@888X 8 8S8X88XXS8SXX88@@ 8 88@:X 8 8 8 888X 8S@8@8XX 8 88 @X 8X8@8X8SS8 @8SS8 888@8888SX8S@8%@S8SS8X8888 888 %88888 8 8 8 8.X @SS8%8%88 X 888@8 8 8XX8 888S8 888 8 88@ 8 8 8 SX88 8S8X@ 8 88 8S8 8S8%888@@8 8S8 88%S8%S8 X 8 8 X 888%8 8.8S@@@SS8 8X8:8 8888S8 8 8888X8@8S8%8 8;8 8:88@88SS8%S888
@@SXX8 88@SX8 8 888@ 8%88SX 8 8S88 8;8 8t8S888%8X8%S8XX 8X@8 8 8 8 S8X8SSSS8;8X8 S8 X8 X8 X8X8@8.8%X@XS8 8 8S8 S88.8 8@8 8S88 88@ 888 8 8 888S88S88 8t8 8 888 8 X888S88@ 8 S 888 888 S88S8 XX8 8 8 88888 8 88888 @8@8;8 8 8 X8 8 8 8S888:8S8S8 XXS88XSXS8 888 XSX 8 X88XS8%8SX@ 8 8:X@8 X88 88@S88888SS8 88 
@8%8 8 8XX8 XSX8X8@8XX8 @8 888 8 XS88@X 8 8 8:8X8 8 88S8;8S8@XX888X8 888 8 88S8 8 8%X88 X8 8 8 8888 88 XX8 S8 8S8@8 8S888@8%S8S8 8 8 88@:8%8 8 X8 X888S8 8SXSX @8S8 8S8@8S8 88@ 8 8 8S8 X 8 888 888:8X888 8S88XS8S@8%X88XS88S88@8 8 8 8:8 888 8S8 8X88 888%X 8 8S888 8%XS88 8 8 8SX8X888X8.8 8S@S@88%8SX8S@8
@X8 888 8 8888X 8 X 8S@8 8 88 8 8 8 @X8 8% 8 8 8S@X8 8 8X 8X8S8 8 88@X888S8 88 888.8X8 8 S888 @88 8S88XSS88%S8;8@8XS 8X8@8 8SS8X888X8S8 888 S @SX88S8 888 8S8 888 8888S@8888@8 8 888 8S@88 8S@SSS8 @@@@@88 8 88SS8SX8X8SS8 S8S8S88@888:888%8 888 8 8SX8S8 8 88@ X88 8 8 8 8SXS88 88S8%888SXSSX8S88 8 888S8 X
@XS8 8 888@8SSX8:8S@ 8S88.8 8 S8%S 8 X88.8S888@ 8 8 88XS8SS8 @88888SX8X@ 888SX8 8:8 8 S @%8XX8:XS8 8 SX8 88@ 8X88%8S8;888S@XX8@8:X8SX8XS8S@8S8;8SS8SX8 8 X 8 S 8 @@8 XX@88X8SXS8888 8 88S88X8 88888SSX8X@ 888SXX@X8 XSS888SSS8:8%8X88 XX8 X8 S8 888 8 SS8  8 8 8S8SXSS8888 8 8 S8 8 S8S@@8S8S8 8 8XS8SS8 S8 
@@88S88S8X8X8S8 X@8 8 8 8@8SS8 X8%888 88@ 8 88X8 888 8 X 8%@888S8 8 8 8%8@@@8 X8.@888 8 S8:8 8 8 S888S888 8:8X8 @8 8 8X888S88@@S8 S8X8S88@ XX88@8 X8S%S 8 88@ 8 8 XX8%8 S%8 8 8 8X@8 8SX8 88@8 88888 8 8S8 8%8 8S888 8 8XS8 8 8@8%8 88 8 88 888 88 8 8%88@SS88X8X88S8 8 X88 88@S8S8888@8 XX 8;XS8S8 88 88SS8
@@%8S@8@ 8SX 8 8X8S8X8S8S8 8888X 8t8%8.8 88XSXXS8 8SXS8 8 8 X@ 8%88@SSXXX8@@ @ 88 8X8888 88 8 88X8S8 @88.X 8 X88SS 888X8SS@X8S8@ 8 8 X8 8 8 8 @ S8 888X888 8 888 8 8 888S8 88888 8X@8 8 888%8 8.8X8 888 888 8 8 8X8@888@8 88 8X888X8 8S 8 8 8 S8 XXS S%88 8 X8%8X8 8:8 8X8 SS8 8 888 8 S8%8 S8 8%SS8SX8 888S
@8 8X8%8S888XSX8@ 8S@88X8 X88 XXS88 XX8t8 8 8 8 S888%888 S @S8 XS8SX8S888SX@8.8 8@@8 88 8 S888 8 8 X8S8@8 888%XSX8%88SXS8 8 %8X888XS8SS8.888X8:8 88 888 8SXX 8S8 S8 8 8 8 8S8@888 8SX8 8 @@8 888 8 8;8 8 8 8 888 8X8S8S888S8X@8S8%SS8:88XX%88X X8 88888S@8 8 XX 8 8%X8S8S888S88X8 8 X88 X888%S8 8 8 8 888S8X
@@8 8SX 8 S888X88@ 8S8X8.8X8 8 8%888SX@8 8 888%8 8888S8%8 888:8 88X SX 8S88SXX88X8X88 8 S888 S% 88@  8X888 8 8X8888 8@SSS8 8SS8 S8X8.8 88 88S 8 8 88X888 8 8 888 8888@%8 S 8 8X888 8 X8 8X8 8 8S888t8 888.888 8tXS8% S8S@ 8S8%@XS8 888 8X88S8 8 S8S8%X 8 88X8X8SSS88S8SX8 S8 8 888.88X @ SX88888SS 888 8X@%8
@XS888 8 8SX888 XX8;8 @ 8 8 S 88@X888X8 88@@@ 8 8X8X88 S8888 S88 8 8X8%S8 88SX 8888 88 8%%X 8 8 88S8 S8S8 8 8 8S8S88 8 8 SS8S8 8 8 8 X8 88:88 8 88S888@ 8 888S8 8t8 8 88@ 888 8X888 8 X8 8 8 8 8 8:8 888 8 8.X 8 8 8 888 8 8@8S8S88%8XX 8:8%8XX8 @S8 8 S8%8 888888%S8 8 S8 SS 8 @;XS8%8 8S8 X8X88X8S8 X 8S@S
@@8 8 888 888S88 8.@88 8 S 8 8 8 8X8@8XS88S8S8 88@ 8 X8X88@@S8.8X888@@8 8S@S8%888 8S88XX88XS 888 SS@8 X8%XS8S8:X 8%X8 888S888 8 888 8 S8 88 XS88 SXS@8%8 88888@X 8 8 8 8 8 8 X 8X8 8 8 X8 8888888.888%8 888 8 888 S88S888 8SXSS@8 8@S8%8 SS8X8 8 S8.88@ SS@8X8%S888SX8t8SX8 8 88;8 8.888 8S8 XX%8%X888 8 8 8
@XS8 8 8.8:XX8 8 S88X%8 8 88888 8.8X8SX8 8 8 X8 8 8 8 S8S88SX88 8%8S8%X8;8@8 8 XS8 8 88@888 8 8 8 8SS8 88888@XX8 S8 8%SX 8;8 8t8.8 88@ X8SX8 8 88@8888%88;8X888 888.888 888 8 8 8%8 8%8 X8S8%8X8 8 8;SXX 8 88@.8%88XX8S888 8 8X8.8 8 8 888S8@S888 X8%8 8 8 88888S8 8 S8 8 S 88S88 888%8 888S8 8SS8%8 SX8 XSS]]

--[[@@@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8
@888X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8
@@8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 
@XS8 8 @S8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
@@SXSX8%8@8SXXS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888.
@@8S8%X8X8%@XX@8X8X8 8 8S8%8.XS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.X
@@XSX8 S8 @8 8 X@88@8 X 8 888S88@.XS8:8S@888X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8%
@@X8:S8SS8SX888 8 8%X8S8 8%8 8S888S8S8 88SX8 888 8%888 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX8SX
@@X@8%X8XX8S88 8 8X8 XX88 8 X 8S888@8 8 @8SSS 8 8 S88.8S8SS@8 8X8SX88 8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 888 
@@8SS8 88SX8%8S 8S888S8 SS8888X8S8@8 X88 @8 8 X888 8%S@8X88 88@8 8 888X8 8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 8 8.@
@@XXXS8SS8 @8 8 888 SXX8S888:8 S8X@@8S8@8%88.8 S8 888X8@8 @8 8S@88@ @8 S88888%8t8 888 S 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 888 8 
@@X8SX888 8 8 SS8XX88@8 888 X 8S@8X8 8S8 8 8X 8 88.8 8 8:8 8 X8 8X@8S88 @ 8 SS88 8 8:8%888 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 8 8 8X8
@@XX8 8 X8 88@ 8X8S@SSS8XX 8 8 8%X8SSX8SXX8 8 88S8X 8 8 SX888 SXX8SS8S@8.8 8 8 X8 888 8 8.S 8 8 888 8S@ 8 888 8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 888:8X8 
@@8SSS88 8 XX 8:8 8 8%8.8 8 888 8 X8S@@8S8X88@ S@88@X888S8S@ 8S888X8 8 8SSX 888 X XXS888 8 88@ 8 8S888 888 8SS8@ 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 8 @X8 8
@@XXX@8X8 8 8 88X8S@8 8888 88@ S @%X8S8 8X888 8%8 8888S@8S8 8 888 8 X888888S88 8 8 8 88 X88 8 888 8 8 8 8 8 8S8.S 8%8:8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8X8@8 8 
@@X8 88 XSS888S88X8%X888 X8 8.8S888S@8SSX8S888@8 888 X8X88 888X@88 8S8 8 X88@8%S888 8S888X 8 888S888 888 S 888.8S8 888 888@8:X 8@8 888S88X8SSXSS88S888 8@8 8%8@8S@S888 %88X8:X 8@8 888S88X8SS8 888 S 8;8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@888888X8 8 X 8
@@8 8SX8S8 8SXXS8 S8%S888 88 888@8 8 X8S8 8X8X8@8S888 X8SX@@8 8S8SS 8:XX8%X8SX8 88 S 8 S88@X8.8 8 8 888 8 888 X8888 8 8X8S8 8S8 8 8X888S8 S888 @t.t;8;8XXSXX8S8%8S8X8t%8t8:X8@@@S88X@88S8 S8 S8.8@8S8SS@S88X@ 8 888 88888@8@8SXS88@8 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@@SXSX 8 8 
@XS8 8S88@8:8%8 8S8 88 XX8S88X888@%@8 XSSX 8 8X8 8S888 S8X8 888X 8 8 8 8 8SS8SS8SX888@8X%8X88SX888.8 8 888 8 8X8@8 8 8S8 8 8 88XS88@S88t88;888t8XX%XS8X8@8@888@8%8S@XX%S88S888888%8 88XX 8.S8 88@X 8t8 8 8 8 X 8 8 8 XS@88XSXXX8:@8@8 8:8 S888S8 8 8XX8 X8SX8X8S8 S8%8 8 8 8XX8 X8SX8X8S8 S8%8 8 8 8 88888X8
@@SS S8 8 8@88%8 X88S8@8XX8 8888S8S8 8 8S8S%XS8 X 8X888S@8 8S8X8 S8 888 8S8 S8SX8 X88@88 8 S8888XXSS888 8 X@8 8 8 8 8XX%8 888 XXS8 8888t8X888888@8888@8888@88@8888888888X88@888tS8@%8888@ 8 X8 X8S8 XS8:8 X88 888 X 8 8@8 8 8 888 8%X8 8 8%8 S@S8X8 8XX8S@8SX@X@@8 S8X8 888 8XX8S@8SX@X@@8 S8X8 888 8 8888@8
@@8888SS @X8%@88@S8@8SXX8 8 8 8 8 8 888:888S8 S8 8 8X8@8 8X 8 @@8 X8S8 88888 8S8 8%S88888 8 X8SX88S8SX88 8X8SXX8X888 8 8 888 8 8@%%888888X@88S@888SS88@X@88888888@S88S888@88X8X8X8@88888@X88XX8%X8;8S8S8 88X 8 8 8 88@ 8 888XSS8.8 8 X%S SS88S8%8S88 8SS8 XSX8 8 S8 88X@88 8 8 S@S8 8 8S8 8%8SX8S8 888 SS8X8
@@S%S8S8 S8 8 8S@8 8X8XSS88@ 8 8 888 8S8 8 X 8.88 S%8X@XXXX8 8X8@8 S8SSX8X8@8 888:8%X8X8:8%8 8 8 8X888X 8 8;8 8S8.XXS88 8 8 8@8%@%@88@SSSS8XSS8SS88X888S@8X8S8X@SS8XS8888@8SS88888888@8@8@888.X@XX8 88888S88@X88XS888@8 8X8@88 SSSS88 8 8%8 X8 888 SX8S8 8 8 8SS8 %8 8X8XX8X8:8 8 SS88X8 S 8 8 X888@X888X88S
@@X8XXXX@8X8@ S8 SX@8 8%8 8.888%S88 888 8;8%88@ S8S8 XXS8 888 8X@X8S8X8SX8X8 8 8;8 8 8 8@ 888 888S8 S8 888 XS88XXX8 8 S%S 8888@8888X88888XS88888S888S88@888S8X8S@S8S88X@SS8888888888888X8X88S8888@X S8888SS8X8:88@8@888XX8 8 8 888S8 8 888.8 888XS8S8;8 S 888 8S888X8@8 8X8888XS88S8%8SS8%8t8.8 8@8SS 888@8@
@@XX8@8SS8S8S8.S8 @ XXSS8 SS8SX8%8%S 8 X 888 8 8.X8888 8 8 8;8 8X8%@SS8 8 8 888 888 88XS8S 8 8 8 S 8S@8 8 8 88@8XS88.8 8S ;888XS@@S8SXX8888S88@X8S@SS8888SS88888X88888SS8888888X88S88@SSS88@@888@888 8 @S8 XSS888@8 8:8 8 8 888 88888 888 8 @%88@@ 888;8%8.8 88@ S8%88X888 @88S8XS8.8 8 SS88@8 8 XS8S8SX8@8 
@@8XX@%8SS8 S 8 S8;8 8S88@%888XX8 8S8 8 8 8 8 888@88888.X8888X8S@@8S8 SS 888X8 8%8 8 8 X 8 8 S888 8 8%X8.888S8 XS8.88 88@t8888SS888XS8X888S:8XX8X8S@X8S888S88XXS8888@X88888888X@@S@8X888888S88@S8888888SSS8%8 X8 8S@XXX8 8 8 8 8S8X8SS88 888:8 888@@8 X%88X 8 8 8 8 888X8 8 8:8 8S@8 88@S8%8SS888 888 8 8 @@
@@XXSSXX8S@8S88X S8 888 8 888 8X@8 888 888 888 8 8 8@@88S8X8@8%@8SSSX8 88@SXX 888 88@ 8 8 88X 88 888 8 888X X 8%8S8 888@@888@S888SXS8X888S8@S8888S8X88@S8S888SS88X@S888888X88@SS88888888X8X8SSSX@88S%88 8S8888SX8 8 8S8S@S S8 888 8 8X8 X 8 8 8 @8@8%X88888S%8 8 88XS8 @ 8 8 8 88@ @8 8 8S@SXS@8 8 8 8@8 8 8
@@XXX8X8 8SX888 8 X8 8 88XXX 8 8S@8 8 888 8 8 8 888 8 X 8;888%8SS8 8 S 8XS8S8SS8%8 8 S 888 8 8 88@8 888 8888S8 8X8 88888@@@88888@S8S888888S8SX888888888888SX8888@8SS8SXX8888XS888@SX8888X8888S@S8XSXX88%XX8.SS8 X8 8 X 8X8X8SS88 8 888 8 8 888 8 8 8@S%S8SX8 88 888 8:8S8 8S8X8 8 8 X8 8 8 8 8SS%88X8 8.X 8 
@@8X8 8;8 8S8 88888888888 8S8 8 8 X8;X@@SX%X 888;8 8 8 8 8X888S8 XS88%8 8 X8 8 8 888X88X8 8 8 8X8X88 8 @ X@888S8 S8t8888SSX88888S8888888XS88X8X;8@88@@@@XXXX8S@XX@8888888tt@88@@8888888X8SS888S88888X@8888@8%888%@8 8 8 8 8S8 8.X 8S888888888 8 888S8S8SX8XX8S8SX8SX 8 888:8S8SS 8 8 XSX8 888 8S8888%8;8 888
@@XSSS88 8 888@8 X8X8X8SX8 888 X88 S8S8 8%8 888 8 8t8:8;X 8@8@888S8 X88888X@8 8 88 888SX8XSSX8t888S8888@888 888 8S8X88@SS888S88S88@@S@88888 8@S@XXXXX@X@SXXSS8 8S8XS8SX@@XXS@88X8XX8@XSS8:888X8S8888888888tS8888888888 888 S88:8 888S8X8S8S8 888 8 8:S 8S@8SX8X8 8 8 888X%8 8 8S8 88@S8 XS8 X8X8 SX8 S8 8 8 
@@X8888X8X8S88S@8%X8 8 8 XS8SX8S8 8 XS8@@888 8 8 888XX 8%8 8X8S888@8S8 8XX8 X888 8 8X88 8 8 88@X8@8S8X8S8888@@ 8 XS8@88SX8@X8@S8888SS8S888XX8SXXXXXX8 8 8 @X8 8 XS8 8SXXXXX8SXSX88X8SS88888SSS88@XX@X8S888@8S8 8.88SX 8 8 8S8%SX8 8 8 8 8 8 8 8 8 S 8S8;8S@@XS888X88@SX@X8 888.X%8 8 8S888X8 88S8 8 8%SS888 
@@XSX8@X8%S8X@8XX8%@8 8;8 8 8 S88888 8X8S88.@88 888X8S88@ S 8 8X8@@@888 8XX8 88 888 8 8X@8 8 8 8X8@88S@X@8SXX8 88S8888S8@X8@88XS88888.@X88S8 @X8X8 8 8 8 8%8 X 8 8 8 8 8 8 X8 8S@SS@8X88S88S888XSS8S8X8S8S888S8 8S@88X8 888%S8S8SX 8 888 8 888S88@ 888 8@8 88X8X88@8 8 8 888SS88XSX8 S888X8 888 SSSS888 8SX8
@@8@8 8 888S8S@8SS8 XS88X888.8 @ 8X@8 @%8 88S888XX 8 8 8:8S8 XSXXX8@8X@8 8SX8SX8X@88 8S8 888SS8 8X8X@XSXX8 8S88t@8X8SSSX8SS88@8@S88X8@@XXSSS8SXXXS8 888 8 8 8 888 8tXS8 88XS88 8 8SX%X:@X8X888888888S8888888@8%X 8 X8%8888 8 S8S8 888 8 888 @ X@8 8 8 8 8.8 XSS8 8S%8XX8 S8 8 X8888S8%8 X8 X 8 8 88X888888 X
@@XSX8 8 S8 X8%88@S8 8 8 @ S8 88@ 8XX8 8 8SX8 8X88 XSSS88 88@X8 8 8 8X8 8 8 S8%X88X 8 8 8;8 8S888X 8 8S8 8SS8 St88888;88S888888S8XSX@XXXXXXS8 8S8S88@8 8%888S8 8S8 8888X88:8S@8 8 8 8%X8@8X8888XS88S88888S@88888 S8 888S8 S 8 8@ 8 8 8 8 8 X 8S8 8X8 888 8 8 8 8 X8X8S888 X8:8 X8 8 88:8S@8 8t@ 888 888X88XX
@@X8 8 88S88SX8 X8SX8S8 888 XS8 8 8X888 88@S88S8 8S8888X 8 8 888 8 8 X%888 8 888 8S8 888t88XX8X8 8 SXSSS8:8 S8S8@@X@@@88S88X@8888 XXX8 8%8 888 X 8X8X88@8S8 S%8 888 @8 8.8X 8%88888SS8%8 88S88S8S@S88888XS8X888X8 8 SS8S88%888S88S888:8X8%88%%8 8S88888 888 888 @SSXSS8S88 8@X8S@8 8%8X@8 8 88%X 8 8.88@SXSX
@@8 88@ XXSX8  8 8X8 S%8 8 8 88@ 8 8X888XX 8 @XS888 SX888X8 8X8888888%8 8 88@ @8XSS 88X%@%8X8.8@S 8%88X8 X@8 @@SSSS8@8@@8XS8X8@S8X8 8 8 888S8 8 8 888X8 @XS888@88@ 8S8888 8 S8S8S888 SSX8 88@S88S8S8X8XS8S8S8X@.S88@ 8;8 S8S8 8 8 8S88X8 8 88%S88@X8S8@888 8 8 8 8 8S8 8 X8 8S88XS8 8%8 8 S8 S88SS8S8 8 8 8 
@XS8 8 8 888@8 8 X8t8 8;S 88@S8 888 8S8@88 X8 8 8SX8X8S8%888.8X8S8SX 8 8 8 8.8XX8 8 X8 8S8 88@@888S8 8%S8S8:::SS8X8888888t8@@S88SSS8 8t8 8.X8 S888X@S8 8S8S%8 888 8 8SS8 8 8 S8 8S888 8 8S@S8X8S888@X888888888X8 8%88;8 8S8 S8 8 88@ XSS88@ X8SX8 8@8S8X888 S 888 888 S 888SX8 @8XS88@ 88@ 8S8.88 S888 8 888
@@SSX8888X8@8 88X 8@S888S8S8 8X8S8 8 88XSS88 8 888XS8X8888%88@8 8 8S888t8X8 8%8 SX88 SSX888X8 8 S8 SSS8 S8 Xt888X88888@8S8XS88;%XX88XSS8888XS@8 @S8 8 8%8%8 SS 8 888 8SX888:8SS8 8XX 8 8 8S8t8S8S:S@@XXXStSSXX;88@8 SSS888 8 XSS 8 X888@8SX8 888SX8%SXX@@@88 8 8 8 8 8 8 8 8 S8 8 8 8 8 8 8888XS88X88@8 SX8.
@@88888S8XSX88 8 8S8 SXS8;8 88XXXX88@X@8 888SS 88@8 X8@88S888@S8 8 8 8;88@S8%8%8%8 8S8888%8 88@8SS8S88@8 8%888@S88888X88SS8@S88XX8.@88 8 8S8 888XSX8X8S8S8 8 8 X888 S 8%88 8S8 X8 8S888 S 8X8@S8SXS8%@SX@SXS8SXX8SS8 8 88 88@S8 88@X@XX@@8 88.888 S8 8%X8X8 888 S%888 888:XX88 888 888 888 8 X88%XXSXX@8S8S@
@@S%S888%XX8S@8 8 X888X8 888SX8%8S88 8S8888 8 888XX8 88S@X 8.8%S S88@;8 8 888 8@8;888 8SS8X8S8 @8 S8S8 88 888@888X8SSX8888888SX8 @8 88@:8 888S888X8S8 8@8 S 888S8 XX8SS8SX8S8X8S88t8 8 8 8 8X8SX8 8 8%@XSXXXS8 8 8  88@S@8 8.S 88@ 8S8 8 X8 88X@ @S88%8 8 8888 8 8%8 8 8 8S8 8 8S8 X8 S @ 8 888SX8XXX8S@8 8 
@@X888S88SSS8S@8 8 S888%8S8%8 %8S@SS8 8S8 8 SS88S8X@8 X8%8%8@ 8 8 8%SS8 8%%8 8SX88X8 8X8%8XS8S8 8S8:XX8S88 88XX88S88S888S8SX8;SS8SX88888X8X8 8S8 8@8 8S8:8S8 8 @ 8 S 8 88XX8S888 8X 8 SX88@88SXSS8 8 8 8 XX8 8SX8X8 X8 8%88@8S8 8:XS88X@88 @ X8S8 8 8X8 888S%8S 888 888 S 8:SS88@ 8 S8S8t888 8S8 88S8 8 S8 8
@@XSSX8 88SSS8 88X888@S8@8 8t8 SX8 888 8 8 8 8%8X88S@8S8@ 8X@S@8.888%888 8 S8X8 8X8X8X8@8X8SX8XS 8;8 8 8 88S8SX@S8XS8@888S8S88SXXX8%X8X8SS8S@@SS8S@X8 8;8 888 8 8 8 88@ @8SSS8SX8X8S 8S8 8@8 8%8 8 S8 8 8 8 888 @ S888 %8X8SX8;888S8%8 8:8 S8%X8t8 8S8 88@X8 X8 8S88%8 8 888S888@8:8% 888%8 S 8 8 SX%8 8 X8 
@@8XXSX8%X8XSX8X8 X 88X88X@88@888S8S8SS 88888 8S8SX8SS8S8 S888X 8 8 X 8 88@S8SS8 8%8 8X8S@S8@8X8 S8 8 888S888888X88888S@S888S8XXX8:8 SSS@8X8S88%S88@@8.@XS8SS S88888@8 8%X8 8 8 S888S@8 8 X%8 8 88@ X8 S 888 8 88@ X8 8 88@8S88XX 8@888 8 8 S8 8@@8:888%8 @ 8 XSX8 8@88@888 888888X@8 XX%8 8 8 888SX888 8 X8
@@X8 8 88@X8@8 X 8 @ XXSX88@8 8.8 S8X8 8 8 8 888 8S@8SS8X8XXSSX88@ 8 8 8 8 8 8 S8 8 888X8S8X8 XX8 S8 88S 8@8SX88XS8888S888X888@8 8 X8 8 S8 S8 888 888S8 8%S888%88888XSX8S8 888 8S8 X8X88X8 888 88X 8 X8 88@ 8 8 8 8 S8S8%8S@8 88S8 8X8888888 S8S8 8X%8 8 8 8 8 @ S8%8X8S%X88.8 8 8@888 8 S8888@ 8 8 X8 S 8 X
@8 8 S8 88%SSS8 888 8S8 8 8 88 888S8 SS888888 8 X 8S@8X8 S8%8 8 XX8.8 XX88@X X8 X8 888S8 8X888@X88 X8S8S88888S@8888X8S888888@8@8XS8 S X8 8X8 8 888@8 @8 S8 8X8X888SX8 8 8;XS8 888 8 %8S8S88 8 8 8 X 8 S8X8 8888@ 88@ S8 8 8 88 8 8SS8S8888S@8 SX@8S8 S8 8 888 88@ SSS8S8S8 8X 8 8%@S 88S8 88@8 8 88XS888888S
@@8 888S@%XX8 %888888@@8 8 8S88XXS8 8 8 8@88X@ 8 8 8S@8%8 8 SS88%8S8 8 8 888SXX8S88S888 X 8X888S8 8S88S8 8X8SS88S@S88888SS888@@@8 X888S88.888X8 88SS8SS888 @88S8888 X888%8 8 8 8 X88 X8 8 8@@88888%888S8 8 X8 8 8 8 8 X8 S 8SX@X8:8 SXXX%@8S88S8 SS88 XSS 88S8 8 88@ 8@8888%8%88.8S88X8S8888 88X8 8.8 888X8@
@XX8 @ 8 8 888 8888X8@8%S8888 X8 8 88X88 8.@88 S888@8SXXS88@S8 X8S8;X8888X@ 8%8 8 8X8 X88S 8X888SS 8.88S8@888888S8SSX888@X8S8S8XS8 88@S8 8S8@8X8SX8XX88X8%8 S8%88SX8S8 SXS88888 8 888SS8 8X8S8X8S88@8 8 88@ SX8 %8 88@ X8 8 8%8 8XX8 8S8S8 8 XXX8 8 X8 88SS8 SS8888 8S8 8888 8 8@8888 S8S88 8S8%888888 88XSX
@@8;888 888 8 8 @8 8 8;8 8S888 X8X8;8X8 8 8SXS8 @ @ S8%8 8SS8 8 @X88 888S8 8.888 8 8 8 8;8 X8X8 8 888 S8S8S8888888S88888888X8888XS8S8 8SSX8%8S8 8 @8 888 X 8 X8%X8S@888S8 88%8 S 8%8.8SXX8888 8 8S8%88@88888 88@ 88 8 8 SS88SSS8S8 8 S8 88888%8 SS 8 S8 8 88@ 8 8%8X%888X8 XS88S8S8 @8 SXS88% XX8888X88 X88@
@@@X%8 8 8 8 888SS8 8 888 8X@ 8S8 @8 8 888888 88X8 8 8%88;8 X88@X8 88X8SX%8.888 888 888 8%8 888SX88X 8 S8SS88888@S888X8SS88888888SX%8 S8S8.XS8 X 8 8S8 XS88 8 S8 8X8S@X8S8 XS8 8 88 X@8X8X8S8@ 8 8 8S8 X8X8SXS8.8 S888 8S8 8S88XSX8 8S88@8X@ 8:8 8 X8 X888 8 88@.8 8%SS8@S8S8S 8 @@8 X8 8X8%8S8 %X 8 8 8 XX@
@8 8 S8 888S888 8 8% @X888@S@8:888 XSS8S8X8X88:8%88@SS8%8X@8S88 8X8 888@SXX8X8 8 8 8t8 888 8 X8X8 SXS88 88@8XXXSS.8@SSS8@888888@8S8 888S888S8X888S8:S 8 8 8@88SS888 8X8 @X8S888 8 S8X8 8 @88S88SXS88888 SXX8SX 8 8%8 S888 888 8S@88888S8888XX 8 888 8X8 8 8 S%8;8 88X88 8 8 S8 S8X8@8 SS 8@8S888S8%S8 888S8 
@@8 8 X8 8:8 8 8 88@%S8S8S88SX8%8 8S88@ XX@XS@8 8S8 8 88@8SX8 X8SS%8SX@8S8SX8S888 S 8 8t8 8%8 XSS8 8 8S8 88%888S888SS88888X88888888t X8S8SX8X8 888S8 8 88X88 88%8SX8 8 8XS8888 88@ S88S888X%8 88888%8SX8 8SS8 888 S88 XXS8 8 8 8:88SX 8S8 X8%888 8 888 8t8;8%8SSS8 8 SS8 88@:%@8S8X888 8%X8 8S@ 8:8 8 @8 8 8
@XS@ 8 X8;8 8;888S8 8%@88@%X8 8 88:888 8S8 8X8 8 888:8SX@S8S@8%X88S88@@ 8 8SSS8SX888X%88 888%8 8 8888 8X8SXS8888X8SSS8@SSS8888@@88S88XXXS8SS8X8 X8 %88888 XS8%SX%8S@8 S 8S8X888 8 8 S8S8 8 8 8 X8XX8 8SX8 8 S%88X8%8 8 8 88:888S8 8 8 S8 8 8 8XX8 X88 888 888:8 888 8 88@X@@8SS8 X8X888:8 888@8 X8 8 8 SS8  
@@8SX 8 S888 8 8.XX S8 S@S8 8%X8S88S888.8X8.@XS88 8 8S8%8 88%S8 888XSX@8 8SX8%%888X8888X8@XS@X8:8 8 88X8 8S8SX8XS88888S8S@8X8SS8S88@@S88S@88@@@8 S888 8XX8X8SXXX8%8S@8 8:8 8X8S@8 S8 8 8888 8S8 8SX 8 8 SS88S8 8SS8S@8 %8 88X8 8 88@.8 @8 8 8:8 888 X8@8 8%8 X8888S%S8.8%8S8 8SS@SS8X8 X88XX8S@8 X8 888S88@S
@@XX8888 X@S888:8S888X8SSSS888S88SS8S8@8S@88S8 8S8@8X8@8X8 8@ 888SSS8 8S8 8 888X@SSSS8@8X8888S8X 8t8SSXSX 8X8888X88@@888888SS8S8@8888S888@88@8888 %X 8 8SX8X8@S888 8 S888 8 X 8S88888X8S8S88.8X8 8S888 8 8 XX88X8SS8 X8 88 X8 8 8 8 8 8 @8 888 8:@8X8S@ 8 8 8 8X@S8888%X8 8;X888 8 8 @8 8S8 X8SS8%X8S8 @88 8
@@X8.8 S8 8 8XX8.8:88SX8 888 X@8 8  8X8XS8 SX 8 8S888@8S8S8S8SS8 8 8 888 88X X8SXX8888SS8 S@8888 S8 8 8S8XX8SS8%8S8%8X888@S8@8@SSX8S8S@S@888888888 .8@XX8SS8S8 8 S S8 X8 X 8 8 8 8@@88S8%8 88S8S888 8:XS8:8S8%8 88XS8888X@8 X88888XSS8S8 X X8 88XS8 888S8888X8 8 8.SS8X8;88888SX@8%S8S8888 888X8 8 8%S88X 8 
@@SSSX8 S888 8S8@XXS8 8 888 8 88%S8 X8%8  @S8S888X8 X@XXX8@888S88.888 8SS @.8XSXX8 8888%X8S8 8 8 8:S888@@8 @X8S888X8X88@S8S88S888888@SSS8XS@@88@%SXS8888S888.S@ 8 888X8 8 888 8 8%8 888X@@8S8@ 8S8 8 8 8 88888 8 88 X8S8@8 8 888888X8%S88S8 SX8XX8 8 %8X8888@888@X88X888X 8S8@88 888@X88S 8 8 8 8;8:8 @8XS 8
@@888XX8 X8 8;8%8 8SS8X8%8 888 8X88XSSSS8SS8 8 X8 S88SS@8S8@8 8 X8S888@8 8 8S8 8 88 8SX8SS8S@XS88;8 @ 88888 8 8 888S8@88888888888X88X8@:8888888X88888888XS@8S888;t88 88888 8;8@8;8 8SX@888 888888888888 8S8 8X888S@8 88@8 S 888 8 S@88S8 8 8 88@S@88@ XS 8 8 8.8%8 8S888S8 @S8 88 88S8;@8%S%88SS88 X88 @8%8 
@@S 88 X88 888 8 8 8 @ S8 8X8@8 8;XX88X888 8S @ S8XXSX8 888X88@8S%8X8X8 88@XX 8 8S88%@SS8SX8S8 8SXS8:8S@XX88 8 8S@X888@X888@XS888888SS8@X@XX88XSSSS8@X888X88@8888X88@tX8%@8S8SX8X%88888888888S888888@8888@888888X8X88 8SS8S8t8SSX8X8 X@88 S 8 8 8 88 8 8 88@8 8@8SXXXSSSS%8 8 8 88%SSS8 8 8 8S8%8%8X8 8%X88S
@@@8 88XS8 SXS888 888 8 S8:X%8 888 8 8 S8S8:8XS8:S8SX8S8S8 8S8SX8XSXS8%S88 8X888 8 8@S8 8X8 @@8;8 8 X8@ 8@88XX8 8XX8S@S:@@88S@88@88X88XS88888@8888S8888@S88S@8X@X@88X@X@:.8@@8 88X8888888888X8888888888%8888%@8888888888@SX88S8S@@8 8%8S@8S888 X88 @8 888S8S88XX 8S8SXX8 888 8 8 88 8 8%88 8.S 8;XS8 888 X@8
@@X@8SX8 88 8 8 8.X8 88@ @8 8 8 8 888 8 S888 8%88SS8SSX 8 8 8 8%X8 8 X8X8 8 8 8 888S8 X888 8X8 XS88XS8%888 @8X88 8S@S88@XX@88@@XX8X;88888@88S88XX8888S8XX8S888@S8888@S8@XXX8SX8 8 8S88@888888888888888@8888@888888888888X8@88 XX@8@8@8 8SXS88 8 X88 88%@X8%8 88X8 8 8 888 8 888 8SX88@8@%8XS88XX88888XX @S8X
@@8XX8 8S88SX8.888XX8 8 8 SX8 X8;XS8%88XS88 X8888X88@8%88S%8S8 8SSS @ SS88@888:@@@8S 8%8 S8 8 8 8 8 X 8X8 8.S8%X8 8 8S@88888XSS888X888S88@@X8888@S8888S8888888S8S8X @@@8SXSS8S@88@ @ 8S8@8@888X88888X8888X8888@88888888@8888888XS@@X@88 8 8 S8 8 S88%888@ 8 8 8@88 8X8S8 8 8 8S88@S88%8S8 8 888X 8 8:8 8 8 8
@@XXSS888 @8 8XXXS8S88 8 8%88@ S8 8 8 8 8 888888@8888S88888X8888888 S8888SSX8 8 8.@88:888 XS888 8% 8 8 8 @88 S@SS8X8 8S@X@8t8888@8888SX888888X@SS888@X8S888@8888@@X@XSXSXX8 8X8S8@8 8 88S88@S%888@888888@888@8888888888888888888888@8SX8 8 8SX888%XX8%X8 8 8 8X8 88S8%X@888X8 8 8.8 8@ 8 8:8SX8 8;8.888 SS8 
@@XXX88@ 8.X8X8 8S@8XX8 888 8 8 S8 8888888888888888888888X888888888888S8 @8XXX 8 8SX@8X@ 8S8 8 88@SS888 8S888 8S8S8S@@SXXX8SX@8S8X88SS8XS8888XS8@88SSS@@S8X%:@SSX8SSXX8 8S88;8 8%8 8 8%8S8 @8 8 88888@88888888@8@8@8@8@88888X88888888XX88 88@%88 8X8SXSXX8 88%X@8S88 8X8S88XX8 888 8X8 888@88 8 %8 8X888 8;8
@@8XX%X8 S8 SX@8:8 8 8 88@ 8 88@ X888X88888888888888888888888888888888888X8@8 888 888SX8 SS88888 8S8SX 8 8X8@888X888@8@S8%8S@SSX88tS88@88888SSS888S8S8X88@8@88 8%XSXXSS8:8 8XXX 8 888 8 8 8 8SX88@@@888@8@888.@@888@8888888888888888888 SS8 X8 8X 8X88S8 888X8S@X8SX8 8 8%@8%888S8 SS88S8@8 X8X8%S%X8S8SX 8 
@@XX8S8 8 S8S8 S8 88@ S 8 888 8 X8X8888888888888888X888888888888888888888888@8X8 S 8S8%8888X8X88S 888X888 8X8S88@8SXXXSSX8 8 8S8@8S8X@88.%8888888888%@%8@X@88 8 8 8 8 88X 8%8S8S 8 8 8 S 8 8 8 8 XXXX8@X88@88888888@8888888@8@88888888@@8S888 @S8SS8 @@ 88@@8 8S8@8S8888;8 888 SS8888SS8%888 88X8S8 X8 8 8 @
@@X8.8 S 888 S8 @8 8 8 8 8 8 8888X8888888888X888888888888X888888888888X88888888S88 XXX8 S888XXX88@@@8 8%S8 8 8 8888 8 8 8 8XS@8 8 8 8S8SX@S@888@S@8t8@@SXXXSS@ 8 8t8:8 8 8 8 X 8 S8 88@ 8 S 888 8 8 8 XXSS@8@88@88888.@88@8888888@88888888@%8 S8 8S88S8 XX 8 S 8X888S88 XX888 8 888SS8SX8X8@8 8SSX@8S88@@X8 
@@XX8 888 8 8:88 XS8 S88888 88888888888X888@8888888@8@8888888888@8@888888888X888888@8SX8 8 88S8.8 8S8888 8%X8 8X8@@8 888;8%8S8 8 8 8 X 8%8%88X@X88888@8X@XX8 8 88X88SSSXS8888%8:8 8@ 8 8 8@@@%8t8%8X8@;@;8 8t 88888888888@888.888@8@88888S8888 X8;8 X8 8 8%%8%8 8X@X8 @8 8 8 888 8 8 8 8 8X888@8 @ S8S8@8 8S
@@8S%X88X8 SX8888S88@ X8 88888X8SXS@@X@8S88XX@@X 8@8888@88888@8@8@88@888@888888S888S888 8.8%X@SX 8 8S8X@88XS88%@@XS%8 8:X8@888S8@ X 8 8 8 8S@8X88888888888888 8 8 S8X8 8S8@88888888t88%88X8X@X@X@X8XS8@S@X88@888S@X@@XX@888888888888@8X88888888%8X 8 8 8888 8  8 X8SS8 XS88888 8 8 8 S8 X 8X8X888;8 88XXX8.8
@@XX888S8 8%8 8SSS@8 8 X@8@8 XSXXX8 8 8 8S8@SXX8SXXX8S8888 @8888X8888X888@8888@88888888S88S8 8 8 888@88 8SX8 88SSX8 8 88%8X8 88888 888.8X8 8S88888@8@88888888S888888S88.8S8@88888@@X8@@888X88XXSS@S@8XX@@@8@@88@@SXXXXXXX@@X@88888@8@88@888X888XXX888X8 8 SXS8 S8 X8%X8 8 @ 8 888 888 X8 8 8X@@@@8 8 @8 8 8X
@@X8 X8@X88X 8 8 8SX8 @S@XSS8S88@8 S 8 X%8SSXXSS8 8 @88 8@@888@@888888@88@8888888@8888@888888S88XX8S8%8SS8 8S8S8 8 888 S8@8 888SS88 8 8S8 8X8888@8@88 @88888@88888888888 @88t8%8S88XX@@@SS888888888888S8888S8@88@@SXXXX8 8XXS8S8@8888@8@88888888@8.8 8.8t8S88888 8S88X%8:8 888 8 8 8 8 8 8X8SXX8%@8%8SSS88X8
@@SS88@8@8 8 88X8 8 8X@8 8S8 XS8 S88SS8S8SXX8 8 S8@8S8%@SX8@@X@@8888@888 @88@8@88888@88888888S8@8XXS88 8S88;8X888 8 @@X8XX 8S8%8S8 8 888S888888888@888888888888888888SXX8 8 @888:%888888S8XX8S8S8S8S888888S8X888@8XX8 8 8 8%8 8 8S8X88@8@88@888888SS8 X88@8 8 S8X88 88 %8 SS8 8 888 X 888 8 8 8 8 S8 8 8 8S8
@@8SXXXS88@X8X8%88:8X8 XS@88888 8SX88 S8@S8SS88@S8 X8X8 8SXXSXS@@@888@8@8888@88@888888@88888@8888888XX8:8 8X 8X888X8S8%X8S8 8 8 8%X88X888888X888888 88@8@8888888888 XXXSX8 8X@8S@SS@:@8X;8SS888XS8888X8@S88X8SS888@SS888 8 8 8@8 8 8S@X888888888888X 8S8@8%@@8S8%@X8 X8 88 8.S8888 8%8:8 8t8 8 8 8 X8 888 8 
@@XX8 8 S8X8 X 8 8@ 8%8 8S8 S@888@ @88X8%X888 8 X 8S8SS8 8 8S88 88@8@88888@88@8@@@8@88888888888X88888888 8S8 S8X8X@X8 8 8 8X88888888@888888@88@88@888 8888@8@88@@SS8S8 8S8888 8 8 8 8X8.%88888888888S8XS;88888X8@88XS8888S8%8X8 8 8 8 8 8888@8@88888X 8 @ 8X8%XX8@8 8 X8 8 S888 8SS88888 S888 888 8 S 8XXS 8
@@X8SS @%X88S88 8 8% 888 8:8%8@8S@8S8.8 8 8SX8 8 8 8@8 XSSSX8%@8S88 88XX888888@88@88@88 @8888888888888888@88888@888SX88888888X8X@8888888888888@8@8@8888888@8@XXXXXSX%8 S8%8X@8 8%8 8 8 8SX8;888@@X888X8X8XXS88888888 SX8S8 8:8 8.8SXX8X8%8@8888888888X 8 8 @88S8 8XS88 8%S8 S888 8X8X8 8 8:8 888 888X888S8SS
@@XS8%888 X88S8XS888 8 8  8 8 8 8 SSS8S8;8 8 X8t88@X8 8 8S8 S8 8 8 8SXXXXS@8@8@88@888888888@888888888888888888888X@888888@@888S8888888888888X888@888@88@8SXXXX@XX8 8S888XX@8 XS88XS88 8 8SXX@S8SS8888X888@88X88888888X8SX%888%XSX88X8S8 8 @@@X88@88888X 8888SSX@8@8 8S8 888S8S@88 8 8 888 8 8888 X8 8 8 X%8X
@@8SSX88 8X8 8S8 88 8 88@S%888 8 8 8 8 X8 S 8 S8 8 8:XS888 8 8 X8 8 8S8@S8 8X88@88888X88888@88888888888888888X8888888X8888888@88888888888888888X88888888SXXX8 8%8 888 88S8XX8 8 8 8 XXX8X8 8 888SX88888S@88888@8XS888 888%88.8S8 8 8@8 X 8SSXS@88888888888 8888%X888:SS8 @ 88@X8SX8 8 88 888:8 X8 S888 8 8 X
@@XX8S8SXS88SXXS8SX888 8 8 8SX8 S 888 8 X8 88X @8 8 8 8 8 X88.8 XSSSX8X@SX@8SX8X@8@8@888@888888888@8@88@88888888888S@888888X8888X88@88@888 @88.@8888@XXSXX8 8SSSSS88 @S@8.8 SS 8 8 8%8%8SX8 8S@888S8888X8SS88888S8SS8X@8@8 8@@X 8 8S8.8S8 8S8@S8X888888888X8X 8X8SX@8 8 888 8 8%@SSS88 XS8S88XX 88S8S8 8888X
@@X8 8SX8 888X8 S8 88X8 888 8 X8S888 88@ SSS8.8 XSS888%8X8S@@8 8 8888S88%8S@8 XX88888.8888@8X8.8@8@88 888@8@88888888888888@888S888@8@888.888@8888@XXXXX8 8 888S8888S@@8 8X 8 8 8@ 888 888 XSXSX@@8X8X8S88888888S888X88XXX@8X8%8S8888 88@ S 888X8XS88888@888S8S88XX8SS8 8 8 8 X 8 8%@ X8S88@S8S8 8S88888S8X8S
@@SS8 8S88X@SX%8 SX@8 XS8 X%S8 SXX8888%@@8SX8888S8S8 %8X8 8SS%888 S%8S8 8:8 8X8 88XX@S888@888888888@88888@88@8@8888888@88X88888888@88888888@88@X@XX@XSSS8 8S8 888:888XS8S8 X888 S888 8S8 8S8 8 8 8@8SS888XXX88S88XXX88 8S8@8@888%8S8@8XX8S8%8X8S@X@888888 @X@8 @8 88XS@88X8t8S8 888 888 SXS8S 8SS8S8X888 8 X
@@88 8 8 S8 8 8.8 8 S8 888S888%888S8 8X8 S8S8X88888@8 SX88 8 888 88888 XS8 8 8 8 XXXS8@S8888@@88@88@888 88@8@88@888 X88888888888@888@8X88888S8SXX8SS8 8 888 88%@X8 8.8 SSX8 S@@8 88X8 8 8;S 88@ @ 8888SX88888888@SS88;% 8@8S8X8@8 8S@@8 888 XXX8%8%XX@8888@@@X8 X8%X8X888X@8 S 8 8 8 8 8 8 88SS8SS8%8X8 8 8S
@@SSX888%8 8 S 888 888%S8 8 8 8 X8X88 888 S8%8X8X88XX8 8 SS888XX8t8@8@8 8 X 888 8 8 8 8 8S8X88.888888@8888@88@8@8.888888@8888@8X8@@88888@XSS8 88%88%X8 8 8 8 8@S8 8 X 8S8 S8S8 S8%8 X8 888X8 8 8 88@S8t88X8@@@@8888X88SX 8 @S8X@88 8X8 8 8 8 8XXS@8 XX8888@8S8 8SX8 8 8 88  8 888.888SS 888 XX8 8 SSXX@8 XSX
@@X8SS8 888X8S8S8 8 8 @SX888 88@ SXX@8S@@8 8X88;8 X8SX8:8 8 8 8 8X 8X888 8 888 S 8 8 S 8 X 8S@S8888888X8@88888@888@88@8.88888@88888888@XXX8 @8 @8888 X88@ X 8S8 88 8%8:S 8.X888S8SS8 XS8S8 8SXX 8 88@X@88@888S88XXS8S8X88:88 @8S@88 8 X88 8 8 8 8 S@8 88X8@S8 8 8SS8X8 8 888 888XSS8 8888@ 8 88@@8 8 8 XX88X
@@8.8 S8X8X8%@88@8 88@.8 8SX8 8.8%8S8 8S8 8S8 @X 8 8XX 8 888.8X8S8XX8X@@888@8 8 888 8 8 8S8 8@SX@X8888@88@8888@8888@888888@8X888888XXSXX@SS8 88S8@8 8%8 S8 888 8S8X@8 8S888S8 X8X8 S8S888 8S8%8%8X8SSSX8S88@888@S88@@8XS88S8@8 8S888X8%8 XSXX8 8;8 8 8XX8@8SSX 8 8 @ X8 8888SS8 8 8:888.8 8 8S8SSS8 8:8 8 X8
@XXXS8 SX@8%8X8S8 8%8 888 8 8S 8 888.SS8SXS S8 8 8 X88XS8888@8 X8 8S@8S8X88888S8X8 888X8 88@X8@SXXXX8X@888888 888@888.@8888888@X8X8@SXXXS8 8X8S8 8 8 X88 S%88 88@S8%888X88 8.8 8XX8 X888 888 X88@8X@88888XS8888888@88%S@S8@ 8 XX8S8S8 8 8 8S888 8 8 8 8 X8 8888XX888888888 X8@8@@8:X8XX8S8 88X 8%88@ 8 888 8
@@88S@888%X8XSS8;888 8 8;8 88@S 8 8:8 888S88S8%S8:8 X88888 8 88S%SX8 XSSS 8X8%X8 8SS8S@88 8 8%8%XX8 XS%S888.88888888@8888.@XX8SSX8SX8 8S@S8:8X888@XS8%8 8%8 X8@8 @ 8S8X8 X8 S88;8 X8%8 S8 8 8S8 @ 888S88S8S888@X@888@%X@8S8SS88X%@SX%8 S 888 8 888 888 8 8XXSX8X8 8 X8X8SS8 888@8;8 S8 8 X8 XX8 8 XX88@%8 8 
@@SX8%8888X8S8 8XS8 888 888SX 8 X8SS8 S8%8S8 S8 8X @8 8 8 888 88S8SX8 8S8SX@ 8 S8.8 X88X 8 X8XS8 8 8 SS888S888@8X8888@X8X88SXSXXSS8 8 S888 888@8@8S88@@8:888S8 SX8 SX@XS8SS8 88X 8:S8:8 8 S8:8 8S8 @88@@88888S8S88@@@8S8SX 8 @8S8 8XX%8 8 8:XS8 @ 88X 8 8 8 8.X8 8;8SSS%8%X8 X 8 8;88SS 8 S88XSS88S8 XX8 S 8
@@XX@8%8 8 8@88S8SS8 @ 8 8:X88 8 S8 S8% @X888 S8 8 88XS8 8 8 @%S8 8 S SS88X8S%88 888 X8 88@ 8SXS888 8%X%8888@8@8X8888888888SXXX8 8 888S@%8%8 X@@XS8 8S8 8S8@888S8 8 8S8  8 888 8% 8 @8 8 8 88 888 8X@SS88888X88X88X8888XX88 8 XXS8 8 888 888S8 8:8 8 888 8 888XX8SXX8 8 S8 S8S8 8 X888 888S8S8 8 SX88S8 8S8 
@@8@8 8 8 8X8 @X%8S8888SS88S@8S 8 S8888@@8S888 88S8SX8S@8 S 88@ X888 8S8 XX@8 X8S8 S8 8 X8.X8@8 8SS8 8  t@X8X8X@@8X@S888@888X8 8S 8 8 8SSS8 8 8 8 %8:888@8S8S888@@8@ XS8 8888 8 8%S@ @8 888 SS88X8.888S8888X8XXX8888888%8 8X 8%8SS888 88@8 SS888@XX8 S8 888 8 8 X888@8%88@8%X8 88@ 8X@8 8 8X8X8%8S8 S8S8SX88
@@S8.888SSX8 8 8%X8888888SS8 8%888 X8 8@8%S8XX8;8 88XS8SX8 8 8 8 88 888 8 8XS8 X888 X888 SXS88SX 8S888S 8888SSS88XS8888888XX8S8 8 S8SXS888S888 8 8 88@8X8 8@8S8X8%8 8%88888XX8 S 88S8 @8 8 8 888X8@8X8888XSS88888S88%X@ 8S8%8 888 8S88 8SS8 8 8@8 888 88%8 8 8 8 S8@8%S88 X8 S%88S@@X888@8@8X8%S88@8S8 S8 8X
@@SS8S8 8S8SX8 S8 X @XX@888@8 X88 8 X8 XXXXS8SSX @SX8 888S8 888 8S@8 8:@X8 8 S8 8 S8 88 8 8 888 8:8 888 St8X888888t8S88888888X 88@ X8S8 X888XS@8888 X@%8 8@8@XXXXX@8 8 8 SX8S@8 888SS8XX88@88 8 8:888S88XS888SSX88@@.SX8;8X8 8 8 88@XX8 8 SS 8 S 8 @X88 8 888 S 8 X8%@8X 8 S8 8 SXXS8X8X8 @XX@8 8S8%@@8 SX%8
@@88S8 8 8;8 8 S 8 @X8S8 @8 XSX88XX8S@8 8 8 S8888 8 88 8888888.X 8S88 8 8 8;8 88.8 88 88@88@S8 8 S88@8 @ 8St8@S@888888XSX888X8@X8 8 S8 88 XS8@8@8SS8S8 8888S8X8 8X8 8 88@ 8 8 S%88 8 8%8S8X888:888888888S.@XS8S88@@8@X8%8S8 888 8 8 8 X888 8 S8S888SXS8 S8 8 8 888 S@8S8SS8 88S8%8 8 XS8 8X8X8 8 8:8X8 8 8 X
@@SSXX8 S 8 88@88888X 8S8 8 8 8:8 8 8 SX8 S8 8 X8%X8 X8S8X8S@X8 88@ 8@888SS888S8@X8 88X8S88%X 8 8 8 8 8 8@88SSS8XS@88888888@8888X%@8S%888X8 @8%X 8 S8S8X8X88S@%8 8 888 8 888 8 8 SSXSX8 XS8X@X88888XX888S88888SS888;S8 @XSS8.8 S 8 S @8S8 88@ XS@8 8 88@ XS8888S8 8S@S8 8S88S8X888SX8 8 S 8 8 8 S 8 8 88888 
@@X8S8 8 888 8 8888@S888 888 888 8 88@%88@ SS8 888 S8%X8SXS8S8 8 8 8S8 S8S8.@X8X8 S8SS888 8@X8 888 X@8%@XS88S8888S8S@XS888S8@88888 88SX8S8 8 X8S8.8 88S8S8SSSSS888SX8 888 8 S 888 8 @ X8 8 8 88X88SSX88@S8SX8888888XSS8XXX88SX8%888 888 8 X8 8 @ SS8 S8 8 888 8%X8:8 8 X@8 X8S8 88S88XS888888@X88XS88@X8X888
@@8 8 S 88@ X 8:8X@%8X@ 8 8 88@ S 8 8 X88S88888 8S8 S8 888 SSSXX88S8@S8SS8 888S%X88 8@8 8S8%8 8;X 8X8%@XX8Xt@S88S8X8S8S888@8S@8888: X8SSSSS88S@8t888S8 S@SXX8 8 X8X8SS @ 8 8 8 8 8 88X SX8 S:t@8@SSS8X8S888888S8@X8XXXX8 888@8:8 8:8 8 888 X888 8 888 888X SX8 @ 8@@8 8S8.88 8%8 SX%88X 8 8888XS@8S88%XS8X@@
@XS888 8 8 8%888 8 8 X88.8 8 8 8 888 8S8 X 8S8 8 8888S8X8@8 8S8 X8S88XS8SS8@8X8S8 8SSXX8 8 SSS88 8 8tXX8 8SX.8XS88XS88888S88888SX@S88X8 @S8 S8 X@X8SSS8%8 8 888 8.X8@8SS8888@ 888X8S8 8 8X%;S888S888888XSS88@S8S88 8S8 88S8 88SXX 888 8 8 8 88 888%8 888S8X8%8 X8S8S8888 @SS8@8 8S8 X88SX8 8.8 8 S8 8@S8%X8@
@@S8S8 SS88X8 8 8 888 88SS%S888:8 8;8;8S@88.@@888S@%8 X8S@@8:X 8%X8 8 8 8S8 XX@8S@X8 8S8888S8S8 888 8 8 8.8 8;8X8888@S88@88888XS8X8888%8 888 S8 888XSSS88XX888 88@S8SX8 888XX8X8S8 8X88;;8%8@S8S88X@X8X8.888SSS88@8 8 888%88t8 8%8 8 S 888 8 88@8SSX888 8%888X8 SXX8S8XX8XXS8 SS8888S 8888SS8 8S888S8 8 XSS8
@@8:8S8 8 @ SSX8t8 8:8 888888X%8 888 8888 88S8SX%8 XS@SS88XS8 88@S8XS888 @88S8 SX8SS888S8 S88@ S%8 888;88888SX.@8X88888888@X888S88@8888888X@XX88S8X88 888@888 888S@ 8 SX8888 8888;@8%t8%88888SS8888S8888888X8X88X8%8 8 8 8 8X@8 88@.8 8.8 8S888%X8 8.8 X 8S8 88X%8 X8 8 888%8888%8%@8SSSSXSSXS88@8 8X%X8 8 X
@@@8@8 888 8%8 S888 888 X88888 @8 8 8S8 8S8t8@8 8;8 8 8 888 S8 8 8X8S88%8X8 @@8 @S8 S8 S @SX8 8 8;S88 8 8 8%XXX@88XXX88X88888@S8S888XS@8@88S88.88X8S88:8 8 8 X888S8 S888S88@ X%t88SXX8X8@@X8SS88S@S8X88S@8X8888XXS8 888X8S8 8S88 8 S 888 888 SS8SS8SX 8 8 8 8 8 8%8 8S%8SX8S8.X8 S8 XX88@8S8 8 @ 88%8S8 88@ 
@8 8 8888 888 8 S8 8 8 8S8 8 X8 X8 8 8 8 X88%88888XS 88XX888 XX8 S8 8 8X888@8SS8SXX8 SX88 8 S888 8 8%SX8.8 8S8SXXSX8@888S@S8S@888X8SSS8X8888tS88888S%8%88@8 8888X8S8X@888t8@X8X8X@88@X8SSSSS8SXXSS888@S8888@88@X@SS888S8%XXS%8 88 8 8 8 8 888S8SX8%88@X888 888 888S8 8 @8 8 88S88%X88X88 SX88.8 8 88888XXX 8
@@8 8 888@X@SX 8 88 8 888 8 8.S8%S X8 8 8 X88@8X8S8S8;8 8X888X88XSX88XX8 @88X8 S8S8@8X8 8  8S88SX888 @ S8 S 8 8 8S.88S8X8X:8@XX88SS8S88@S888@S88@888@@%8@888888X8888888@88888XX@888SS888888888SS88S@S88888XXXX8 8%8 8 @ 8S8 8 @%888S8X@8 8S8@8X8 XXS8X8%X 888 8 8 8.XX8SSX8 8.8.X88 88888%8SX8 88XS8S8@@8S8 
@XS88@S8X8 8%8 88S8XXS8 SSS%88 X8888 8888XS8 @S8 8%X88@8 8X@@%@8 8 8%@X @S8S8 8 S8S@88%XS8 X8 X8%8S@8:8 X8S8;8 8 8 88888X88SSS8SX8@8@S8X8S888@@8888X8@XX@88888888888888@@8@SSS88S8SS8SXX8@88SSS8SSS8SS888:@X8S88 888 8 8 888;8;8%88888X8XX8S@XSX8S8%X8%8%8;8S@ 888 8S8 8 88@ 888 X88X8 8 8 8 888SXX@XSSS%888
@@8 8 8 8 X 888 S@88XS88S8 8 X8X@S%S 8 8X@8 8 8 8t8X8X@88XS8S8SX8 88@X8SX8 888X8 888X 8SX888X8 8@888XS 8 8 S8 8 8 8 8X;8@SSS8X8SS8@S8:8888X888X8X888S88888888@X888@888S88888888S8888S888888SS8XXSS.888X S@XX@8S88 8 S 888 8 8:8@8@8S@8 8888@8 8SS8%8 8X 8 8 8 88@ 888.X8888 8 8;8 @8 S@8 S8888 8 8X8@S8 8 8 
@XS8 8 888%8 8 8%8 XS8.8@8SX8 S8S8S8S88;8 SS88X S8 8 8 8X8SXXS8S@8 8 8 8%88@8SSS8 X8X8 8S8 XSX8X8 X8S8 8 8 8;888 8 8S8 8888X8XS8S888@888X88@@X8888@S8SX8S8S888S@8S@8S8S8S8X888@8S888SXX8@SS8X8X8S8SS888@XSXSS@8 8 S8 8 8 8 S 8X8X8%8 @8 8:8 S8 8SX8S8S8S8X88.8X8 8 8 8 8 8.88 88 8S@8%888 %888SS888X@S888 8%
@@8;8 8X88888 888 8 888%8 8S888S8@8%8 8X 8%8 8S@ S8 S 8 8X8S8 S8 X8 8 S@8 X8 8 SS8XXXS8 88888X 8:8 XS888 88%S88 8X8 XS8S@S88X88@8888SX8S8888@8SXXS8X8888X8888SSS8@8S888888888X8888@S8S8@SS88@X888;8@@@XS@XX8 8 88@ S888 88@ 888 888X8 8 8@X8S@8 8@8.SX 8X8 88%8 888 8 88@ 8S888X@ 8S88@8 8S@SSX88X 8 8 8 8 8
@@@8 S 8X8S8888XX XSX8 8 8;8 8888 S%X8X8SS8 8 8;8 X8%8 88X @ 8:X8%SS88X8 8 @8 8%8 8 8 S8X8 888% 8 8 8 8.8 %88SX8S8S8S8 8 8X8 888S8@SS88XSX8888XS888@SS88XX88SS8XX@88X8S8X888@@X88S8X8888888888;@XX8SXX@SX8 8 888XX@ X8 8 8 8 8 8X8S8X%8888S88XX8%@X8 8SS8 8 8888 8 88@ 8 S 8 S8X8 S888 8SS8SX8S 8 8 888.888;
@8 X88 X8 8S8XX888 @ 8 88 88X @888 8 SS@8 S888 8.8 8 S8S8S8S88@ X888S%8 8 888888 88@:88 8%8S8 8 8 888@:888SXX8 8 X888S8X8 8 8S888t88X8888888@X8X8@S8@8888888S8888888XS88888XSS888888S88888%:8@XX8SSXX8 8S88 8 8 8S 8 S%S8 888 8 8@8S88X 8 8 88%X8@8 88@%88 8S8X888XS8 8 8 88@%X8 8 X88SS8 8S8%8 8 8888 8 8 @
@@8 888 8%S8 8 X@8SS8.8 8XX8 8X8S8SS8S8 S8 88 X 8:88@S8 X8%S8%X88SS8 8 8 888 8SX8 8:XS88%8 8 888888 8 8 8;8 8 8 8S8 8 @ XSX8 8@8 8X@88.S8@@SX8X888S8S88XX88S:8@XS888@88@@SS888@@X88S8t88@XXXXXSXSXX8 8 S8S8X 8 8 8 X88@ 88 8 88@@8@8@8S8 8 8XX8SSX@8 8 8SX888 8S8 8 88@8.8 8.8 8 88X8 8 8 X8X8.88@X8 8@S8 8 
@XX8 8S8.8 SS@8S8 8 8XS8 8 8 8 8%S8 S8:8 888@8S8 X8@X888%88 88 8S8 8SS888 8 8 8 S8:8 XS8SX8 88X 8 X8 888SX 88888 8S88 X8 8 S8@8S@X8S8 8@S@88%8888S8888S8S8888S88SX888888S88X888X888XXX@XXX8 8XXXXX8SX88SX8%8SSSS%88 X8 8 S 888S@8X888X8 888 8 8 8S8S@8 %8 8%@8 8 8t8X8 8@@8 S88 8 8SX8 88@ SX8888 8%8%8 88 8
@@88S8X8XX8 @ S@88X8S8 88888888.8 X8 @8 888X8S888 8888SX8 88 8 SSS888 88 8 8 S @8%S @88S8 S8S8%X @SS8.8 8S8:8 8 8 8 8S%8888%8XSX8 88%8S8X8S@S@@88888:8t8XXXSX88888SS;;88;88888XSXXX@XXXX8 @8@SX8 8 X8.88 8888 888 S8 S8 8 8 8 8S@XXXX@88 8 8 8 8 @88%888S8 8S@8 888SX@8@8 X8SS8@@8X8 XS8 8S8X8X888XS8 S8 S%X
@@%8X8 8888%S8S8@8.S8 8SS8888S8S 8 88 XS8SXX@8S888%@888SX8 88@888888@8XX888:8%888%8 S888@@8S8 8 8 8 8XX888.8X8:X 8 88@S8 888 8 8 8 8SX@X8@SSXX8%X@@@S@ @X8SSXXXX8SSXXS8SX8S@XXX8 8SXSXX8 8 8%8 8% 8 88:88S8 8  8 88@8 8888888S@8S8 8 8XX8 888 88XX8@8 X8 X8 8S888SX88XX8 8 88888 88S8 8 888 8 X8@8 888 @8S8 
@8 8 88 8XS8 8 8 88 888@ S 88888 X8 8S8S%8%8 X8X@@8 8X88SX8S8 @XSSX8 X8 8%SS888X@S88 S8S8 X8 888.88@S8 8SX8S8:8%888 8.S 8 8;8 8 888 XX8@8SXX8 XXXX8S@S8S8 @X@XSXS8 8S8 8 XXXX8 8SSXX8 8 8 8S8X88@%S8 88 XS88X888@88  @88%8 88888X88.8 8S@8S8 S 8 8X888 S8%SX8S8SX8SXX8 XX88 @8XXXX8 SS888X8 S8 S8%8 8 8 XX@8
@@8 8%8888SX8 88XS88 8SX888 @8SX8 8%S8 8 SS@8S@8S8 8 8S@8%S8S8S8 8 X@SSSX8S8 8 8 8:88SX8 8S88X@ 8 8 8 888XS8SXXS88 X88%888 XS88@ 8 8 8 8:88 88X8 8%XSXS8:8 8 8@SSS8 8 8 8 8 8 8 8 8 S8 88@X8S888 8 88 88888SXS888SS8 8888S8 X8SX8 8@XX8S8 S@8S8 8 8X888 S8S888.8 @8 8 8 8 S8 XX8X8 8 888 888 8 8  S 8 X8 @ S
@XX888X8SX8S8888 8 8888%SXX8 X8 S888S8 8 8S8 8 8 88 @@8S@8S@8@S8S @ 88888X888@8@88@88@8 X8%SS8S888 888.8%8SX8S888S8X8 888 8 8 8 888 888 8 @8 8@88 8 8 8%X88 8S88 8 8 8 S 8 8 S 888 888 S8SXS8X8XS88 88 8@X@888S 8XX @S8S8X88SS8SS8X8S8.88@X8 8 888 8X888%@8 88SX8SS8X8:8:8 888X88888X%S88 8 88@:8%8 888S8 8 
@@8S8 8 8S@888X 8 8S8X88XXS8SXX88@@ 8 88@:X 8 8 8 888X 8S@8@8XX 8 88 @X 8X8@8X8SS8 @8SS8 888@8888SX8S@8%@S8SS8X8888 888 %88888 8 8 8 8.X @SS8%8%88 X 888@8 8 8XX8 888S8 888 8 88@ 8 8 8 SX88 8S8X@ 8 88 8S8 8S8%888@@8 8S8 88%S8%S8 X 8 8 X 888%8 8.8S@@@SS8 8X8:8 8888S8 8 8888X8@8S8%8 8;8 8:88@88SS8%S888
@@SXX8 88@SX8 8 888@ 8%88SX 8 8S88 8;8 8t8S888%8X8%S8XX 8X@8 8 8 8 S8X8SSSS8;8X8 S8 X8 X8 X8X8@8.8%X@XS8 8 8S8 S88.8 8@8 8S88 88@ 888 8 8 888S88S88 8t8 8 888 8 X888S88@ 8 S 888 888 S88S8 XX8 8 8 88888 8 88888 @8@8;8 8 8 X8 8 8 8S888:8S8S8 XXS88XSXS8 888 XSX 8 X88XS8%8SX@ 8 8:X@8 X88 88@S88888SS8 88 
@8%8 8 8XX8 XSX8X8@8XX8 @8 888 8 XS88@X 8 8 8:8X8 8 88S8;8S8@XX888X8 888 8 88S8 8 8%X88 X8 8 8 8888 88 XX8 S8 8S8@8 8S888@8%S8S8 8 8 88@:8%8 8 X8 X888S8 8SXSX @8S8 8S8@8S8 88@ 8 8 8S8 X 8 888 888:8X888 8S88XS8S@8%X88XS88S88@8 8 8 8:8 888 8S8 8X88 888%X 8 8S888 8%XS88 8 8 8SX8X888X8.8 8S@S@88%8SX8S@8
@X8 888 8 8888X 8 X 8S@8 8 88 8 8 8 @X8 8% 8 8 8S@X8 8 8X 8X8S8 8 88@X888S8 88 888.8X8 8 S888 @88 8S88XSS88%S8;8@8XS 8X8@8 8SS8X888X8S8 888 S @SX88S8 888 8S8 888 8888S@8888@8 8 888 8S@88 8S@SSS8 @@@@@88 8 88SS8SX8X8SS8 S8S8S88@888:888%8 888 8 8SX8S8 8 88@ X88 8 8 8 8SXS88 88S8%888SXSSX8S88 8 888S8 X
@XS8 8 888@8SSX8:8S@ 8S88.8 8 S8%S 8 X88.8S888@ 8 8 88XS8SS8 @88888SX8X@ 888SX8 8:8 8 S @%8XX8:XS8 8 SX8 88@ 8X88%8S8;888S@XX8@8:X8SX8XS8S@8S8;8SS8SX8 8 X 8 S 8 @@8 XX@88X8SXS8888 8 88S88X8 88888SSX8X@ 888SXX@X8 XSS888SSS8:8%8X88 XX8 X8 S8 888 8 SS8  8 8 8S8SXSS8888 8 8 S8 8 S8S@@8S8S8 8 8XS8SS8 S8 
@@88S88S8X8X8S8 X@8 8 8 8@8SS8 X8%888 88@ 8 88X8 888 8 X 8%@888S8 8 8 8%8@@@8 X8.@888 8 S8:8 8 8 S888S888 8:8X8 @8 8 8X888S88@@S8 S8X8S88@ XX88@8 X8S%S 8 88@ 8 8 XX8%8 S%8 8 8 8X@8 8SX8 88@8 88888 8 8S8 8%8 8S888 8 8XS8 8 8@8%8 88 8 88 888 88 8 8%88@SS88X8X88S8 8 X88 88@S8S8888@8 XX 8;XS8S8 88 88SS8
@@%8S@8@ 8SX 8 8X8S8X8S8S8 8888X 8t8%8.8 88XSXXS8 8SXS8 8 8 X@ 8%88@SSXXX8@@ @ 88 8X8888 88 8 88X8S8 @88.X 8 X88SS 888X8SS@X8S8@ 8 8 X8 8 8 8 @ S8 888X888 8 888 8 8 888S8 88888 8X@8 8 888%8 8.8X8 888 888 8 8 8X8@888@8 88 8X888X8 8S 8 8 8 S8 XXS S%88 8 X8%8X8 8:8 8X8 SS8 8 888 8 S8%8 S8 8%SS8SX8 888S
@8 8X8%8S888XSX8@ 8S@88X8 X88 XXS88 XX8t8 8 8 8 S888%888 S @S8 XS8SX8S888SX@8.8 8@@8 88 8 S888 8 8 X8S8@8 888%XSX8%88SXS8 8 %8X888XS8SS8.888X8:8 88 888 8SXX 8S8 S8 8 8 8 8S8@888 8SX8 8 @@8 888 8 8;8 8 8 8 888 8X8S8S888S8X@8S8%SS8:88XX%88X X8 88888S@8 8 XX 8 8%X8S8S888S88X8 8 X88 X888%S8 8 8 8 888S8X
@@8 8SX 8 S888X88@ 8S8X8.8X8 8 8%888SX@8 8 888%8 8888S8%8 888:8 88X SX 8S88SXX88X8X88 8 S888 S% 88@  8X888 8 8X8888 8@SSS8 8SS8 S8X8.8 88 88S 8 8 88X888 8 8 888 8888@%8 S 8 8X888 8 X8 8X8 8 8S888t8 888.888 8tXS8% S8S@ 8S8%@XS8 888 8X88S8 8 S8S8%X 8 88X8X8SSS88S8SX8 S8 8 888.88X @ SX88888SS 888 8X@%8
@XS888 8 8SX888 XX8;8 @ 8 8 S 88@X888X8 88@@@ 8 8X8X88 S8888 S88 8 8X8%S8 88SX 8888 88 8%%X 8 8 88S8 S8S8 8 8 8S8S88 8 8 SS8S8 8 8 8 X8 88:88 8 88S888@ 8 888S8 8t8 8 88@ 888 8X888 8 X8 8 8 8 8 8:8 888 8 8.X 8 8 8 888 8 8@8S8S88%8XX 8:8%8XX8 @S8 8 S8%8 888888%S8 8 S8 SS 8 @;XS8%8 8S8 X8X88X8S8 X 8S@S
@@8 8 888 888S88 8.@88 8 S 8 8 8 8X8@8XS88S8S8 88@ 8 X8X88@@S8.8X888@@8 8S@S8%888 8S88XX88XS 888 SS@8 X8%XS8S8:X 8%X8 888S888 8 888 8 S8 88 XS88 SXS@8%8 88888@X 8 8 8 8 8 8 X 8X8 8 8 X8 8888888.888%8 888 8 888 S88S888 8SXSS@8 8@S8%8 SS8X8 8 S8.88@ SS@8X8%S888SX8t8SX8 8 88;8 8.888 8S8 XX%8%X888 8 8 8
@XS8 8 8.8:XX8 8 S88X%8 8 88888 8.8X8SX8 8 8 X8 8 8 8 S8S88SX88 8%8S8%X8;8@8 8 XS8 8 88@888 8 8 8 8SS8 88888@XX8 S8 8%SX 8;8 8t8.8 88@ X8SX8 8 88@8888%88;8X888 888.888 888 8 8 8%8 8%8 X8S8%8X8 8 8;SXX 8 88@.8%88XX8S888 8 8X8.8 8 8 888S8@S888 X8%8 8 8 88888S8 8 S8 8 S 88S88 888%8 888S8 8SS8%8 SX8 XSS]]


--[[@@@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8
@888X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8
@@8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 
@XS8 8 @S8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
@@SXSX8%8@8SXXS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888.
@@8S8%X8X8%@XX@8X8X8 8 8S8%8.XS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.X
@@XSX8 S8 @8 8 X@88@8 X 8 888S88@.XS8:8S@888X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8%
@@X8:S8SS8SX888 8 8%X8S8 8%8 8S888S8S8 88SX8 888 8%888 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX8SX
@@X@8%X8XX8S88 8 8X8 XX88 8 X 8S888@8 8 @8SSS 8 8 S88.8S8SS@8 8X8SX88 8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 888 
@@8SS8 88SX8%8S 8S888S8 SS8888X8S8@8 X88 @8 8 X888 8%S@8X88 88@8 8 888X8 8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 8 8.@
@@XXXS8SS8 @8 8 888 SXX8S888:8 S8X@@8S8@8%88.8 S8 888X8@8 @8 8S@88@ @8 S88888%8t8 888 S 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 888 8 
@@X8SX888 8 8 SS8XX88@8 888 X 8S@8X8 8S8 8 8X 8 88.8 8 8:8 8 X8 8X@8S88 @ 8 SS88 8 8:8%888 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 8 8 8X8
@@XX8 8 X8 88@ 8X8S@SSS8XX 8 8 8%X8SSX8SXX8 8 88S8X 8 8 SX888 SXX8SS8S@8.8 8 8 X8 888 8 8.S 8 8 888 8S@ 8 888 8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 888:8X8 
@@8SSS88 8 XX 8:8 8 8%8.8 8 888 8 X8S@@8S8X88@ S@88@X888S8S@ 8S888X8 8 8SSX 888 X XXS888 8 88@ 8 8S888 888 8SS8@ 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 8 @X8 8
@@XXX@8X8 8 8 88X8S@8 8888 88@ S @%X8S8 8X888 8%8 8888S@8S8 8 888 8 X888888S88 8 8 8 88 X88 8 888 8 8 8 8 8 8S8.S 8%8:8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8X8@8 8 
@@X8 88 XSS888S88X8%X888 X8 8.8S888S@8SSX8S888@8 888 X8X88 888X@88 8S8 8 X88@8%S888 8S888X 8 888S888 888 S 888.8S8 888 888@8:X 8@8 888S88X8SSXSS88S888 8@8 8%8@8S@S888 %88X8:X 8@8 888S88X8SS8 888 S 8;8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@888888X8 8 X 8
@@8 8SX8S8 8SXXS8 S8%S888 88 888@8 8 X8S8 8X8X8@8S888 X8SX@@8 8S8SS 8:XX8%X8SX8 88 S 8 S88@X8.8 8 8 888 8 888 X8888 8 8X8S8 8S8 8 8X888S8 S888 @t.t;8;8XXSXX8S8%8S8X8t%8t8:X8@@@S88X@88S8 S8 S8.8@8S8SS@S88X@ 8 888 88888@8@8SXS88@8 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@@SXSX 8 8 
@XS8 8S88@8:8%8 8S8 88 XX8S88X888@%@8 XSSX 8 8X8 8S888 S8X8 888X 8 8 8 8 8SS8SS8SX888@8X%8X88SX888.8 8 888 8 8X8@8 8 8S8 8 8 88XS88@S88t88;888t8XX%XS8X8@8@888@8%8S@XX%S88S888888%8 88XX 8.S8 88@X 8t8 8 8 8 X 8 8 8 XS@88XSXXX8:@8@8 8:8 S888S8 8 8XX8 X8SX8X8S8 S8%8 8 8 8XX8 X8SX8X8S8 S8%8 8 8 8 88888X8
@@SS S8 8 8@88%8 X88S8@8XX8 8888S8S8 8 8S8S%XS8 X 8X888S@8 8S8X8 S8 888 8S8 S8SX8 X88@88 8 S8888XXSS888 8 X@8 8 8 8 8XX%8 888 XXS8 8888t8X888888@8888@8888@88@8888888888X88@888tS8@%8888@ 8 X8 X8S8 XS8:8 X88 888 X 8 8@8 8 8 888 8%X8 8 8%8 S@S8X8 8XX8S@8SX@X@@8 S8X8 888 8XX8S@8SX@X@@8 S8X8 888 8 8888@8
@@8888SS @X8%@88@S8@8SXX8 8 8 8 8 8 888:888S8 S8 8 8X8@8 8X 8 @@8 X8S8 88888 8S8 8%S88888 8 X8SX88S8SX88 8X8SXX8X888 8 8 888 8 8@%%888888X@88S@888SS88@X@88888888@S88S888@88X8X8X8@88888@X88XX8%X8;8S8S8 88X 8 8 8 88@ 8 888XSS8.8 8 X%S SS88S8%8S88 8SS8 XSX8 8 S8 88X@88 8 8 S@S8 8 8S8 8%8SX8S8 888 SS8X8
@@S%S8S8 S8 8 8S@8 8X8XSS88@ 8 8 888 8S8 8 X 8.88 S%8X@XXXX8 8X8@8 S8SSX8X8@8 888:8%X8X8:8%8 8 8 8X888X 8 8;8 8S8.XXS88 8 8 8@8%@%@88@SSSS8XSS8SS88X888S@8X8S8X@SS8XS8888@8SS88888888@8@8@888.X@XX8 88888S88@X88XS888@8 8X8@88 SSSS88 8 8%8 X8 888 SX8S8 8 8 8SS8 %8 8X8XX8X8:8 8 SS88X8 S 8 8 X888@X888X88S
@@X8XXXX@8X8@ S8 SX@8 8%8 8.888%S88 888 8;8%88@ S8S8 XXS8 888 8X@X8S8X8SX8X8 8 8;8 8 8 8@ 888 888S8 S8 888 XS88XXX8 8 S%S 8888@8888X88888XS88888S888S88@888S8X8S@S8S88X@SS8888888888888X8X88S8888@X S8888SS8X8:88@8@888XX8 8 8 888S8 8 888.8 888XS8S8;8 S 888 8S888X8@8 8X8888XS88S8%8SS8%8t8.8 8@8SS 888@8@
@@XX8@8SS8S8S8.S8 @ XXSS8 SS8SX8%8%S 8 X 888 8 8.X8888 8 8 8;8 8X8%@SS8 8 8 888 888 88XS8S 8 8 8 S 8S@8 8 8 88@8XS88.8 8S ;888XS@@S8SXX8888S88@X8S@SS8888SS88888X88888SS8888888X88S88@SSS88@@888@888 8 @S8 XSS888@8 8:8 8 8 888 88888 888 8 @%88@@ 888;8%8.8 88@ S8%88X888 @88S8XS8.8 8 SS88@8 8 XS8S8SX8@8 
@@8XX@%8SS8 S 8 S8;8 8S88@%888XX8 8S8 8 8 8 8 888@88888.X8888X8S@@8S8 SS 888X8 8%8 8 8 X 8 8 S888 8 8%X8.888S8 XS8.88 88@t8888SS888XS8X888S:8XX8X8S@X8S888S88XXS8888@X88888888X@@S@8X888888S88@S8888888SSS8%8 X8 8S@XXX8 8 8 8 8S8X8SS88 888:8 888@@8 X%88X 8 8 8 8 888X8 8 8:8 8S@8 88@S8%8SS888 888 8 8 @@
@@XXSSXX8S@8S88X S8 888 8 888 8X@8 888 888 888 8 8 8@@88S8X8@8%@8SSSX8 88@SXX 888 88@ 8 8 88X 88 888 8 888X X 8%8S8 888@@888@S888SXS8X888S8@S8888S8X88@S8S888SS88X@S888888X88@SS88888888X8X8SSSX@88S%88 8S8888SX8 8 8S8S@S S8 888 8 8X8 X 8 8 8 @8@8%X88888S%8 8 88XS8 @ 8 8 8 88@ @8 8 8S@SXS@8 8 8 8@8 8 8
@@XXX8X8 8SX888 8 X8 8 88XXX 8 8S@8 8 888 8 8 8 888 8 X 8;888%8SS8 8 S 8XS8S8SS8%8 8 S 888 8 8 88@8 888 8888S8 8X8 88888@@@88888@S8S888888S8SX888888888888SX8888@8SS8SXX8888XS888@SX8888X8888S@S8XSXX88%XX8.SS8 X8 8 X 8X8X8SS88 8 888 8 8 888 8 8 8@S%S8SX8 88 888 8:8S8 8S8X8 8 8 X8 8 8 8 8SS%88X8 8.X 8 
@@8X8 8;8 8S8 88888888888 8S8 8 8 X8;X@@SX%X 888;8 8 8 8 8X888S8 XS88%8 8 X8 8 8 888X88X8 8 8 8X8X88 8 @ X@888S8 S8t8888SSX88888S8888888XS88X8X;8@88@@@@XXXX8S@XX@8888888tt@88@@8888888X8SS888S88888X@8888@8%888%@8 8 8 8 8S8 8.X 8S888888888 8 888S8S8SX8XX8S8SX8SX 8 888:8S8SS 8 8 XSX8 888 8S8888%8;8 888
@@XSSS88 8 888@8 X8X8X8SX8 888 X88 S8S8 8%8 888 8 8t8:8;X 8@8@888S8 X88888X@8 8 88 888SX8XSSX8t888S8888@888 888 8S8X88@SS888S88S88@@S@88888 8@S@XXXXX@X@SXXSS8 8S8XS8SX@@XXS@88X8XX8@XSS8:888X8S8888888888tS8888888888 888 S88:8 888S8X8S8S8 888 8 8:S 8S@8SX8X8 8 8 888X%8 8 8S8 88@S8 XS8 X8X8 SX8 S8 8 8 
@@X8888X8X8S88S@8%X8 8 8 XS8SX8S8 8 XS8@@888 8 8 888XX 8%8 8X8S888@8S8 8XX8 X888 8 8X88 8 8 88@X8@8S8X8S8888@@ 8 XS8@88SX8@X8@S8888SS8S888XX8SXXXXXX8 8 8 @X8 8 XS8 8SXXXXX8SXSX88X8SS88888SSS88@XX@X8S888@8S8 8.88SX 8 8 8S8%SX8 8 8 8 8 8 8 8 8 S 8S8;8S@@XS888X88@SX@X8 888.X%8 8 8S888X8 88S8 8 8%SS888 
@@XSX8@X8%S8X@8XX8%@8 8;8 8 8 S88888 8X8S88.@88 888X8S88@ S 8 8X8@@@888 8XX8 88 888 8 8X@8 8 8 8X8@88S@X@8SXX8 88S8888S8@X8@88XS88888.@X88S8 @X8X8 8 8 8 8%8 X 8 8 8 8 8 8 X8 8S@SS@8X88S88S888XSS8S8X8S8S888S8 8S@88X8 888%S8S8SX 8 888 8 888S88@ 888 8@8 88X8X88@8 8 8 888SS88XSX8 S888X8 888 SSSS888 8SX8
@@8@8 8 888S8S@8SS8 XS88X888.8 @ 8X@8 @%8 88S888XX 8 8 8:8S8 XSXXX8@8X@8 8SX8SX8X@88 8S8 888SS8 8X8X@XSXX8 8S88t@8X8SSSX8SS88@8@S88X8@@XXSSS8SXXXS8 888 8 8 8 888 8tXS8 88XS88 8 8SX%X:@X8X888888888S8888888@8%X 8 X8%8888 8 S8S8 888 8 888 @ X@8 8 8 8 8.8 XSS8 8S%8XX8 S8 8 X8888S8%8 X8 X 8 8 88X888888 X
@@XSX8 8 S8 X8%88@S8 8 8 @ S8 88@ 8XX8 8 8SX8 8X88 XSSS88 88@X8 8 8 8X8 8 8 S8%X88X 8 8 8;8 8S888X 8 8S8 8SS8 St88888;88S888888S8XSX@XXXXXXS8 8S8S88@8 8%888S8 8S8 8888X88:8S@8 8 8 8%X8@8X8888XS88S88888S@88888 S8 888S8 S 8 8@ 8 8 8 8 8 X 8S8 8X8 888 8 8 8 8 X8X8S888 X8:8 X8 8 88:8S@8 8t@ 888 888X88XX
@@X8 8 88S88SX8 X8SX8S8 888 XS8 8 8X888 88@S88S8 8S8888X 8 8 888 8 8 X%888 8 888 8S8 888t88XX8X8 8 SXSSS8:8 S8S8@@X@@@88S88X@8888 XXX8 8%8 888 X 8X8X88@8S8 S%8 888 @8 8.8X 8%88888SS8%8 88S88S8S@S88888XS8X888X8 8 SS8S88%888S88S888:8X8%88%%8 8S88888 888 888 @SSXSS8S88 8@X8S@8 8%8X@8 8 88%X 8 8.88@SXSX
@@8 88@ XXSX8  8 8X8 S%8 8 8 88@ 8 8X888XX 8 @XS888 SX888X8 8X8888888%8 8 88@ @8XSS 88X%@%8X8.8@S 8%88X8 X@8 @@SSSS8@8@@8XS8X8@S8X8 8 8 888S8 8 8 888X8 @XS888@88@ 8S8888 8 S8S8S888 SSX8 88@S88S8S8X8XS8S8S8X@.S88@ 8;8 S8S8 8 8 8S88X8 8 88%S88@X8S8@888 8 8 8 8 8S8 8 X8 8S88XS8 8%8 8 S8 S88SS8S8 8 8 8 
@XS8 8 8 888@8 8 X8t8 8;S 88@S8 888 8S8@88 X8 8 8SX8X8S8%888.8X8S8SX 8 8 8 8.8XX8 8 X8 8S8 88@@888S8 8%S8S8:::SS8X8888888t8@@S88SSS8 8t8 8.X8 S888X@S8 8S8S%8 888 8 8SS8 8 8 S8 8S888 8 8S@S8X8S888@X888888888X8 8%88;8 8S8 S8 8 88@ XSS88@ X8SX8 8@8S8X888 S 888 888 S 888SX8 @8XS88@ 88@ 8S8.88 S888 8 888
@@SSX8888X8@8 88X 8@S888S8S8 8X8S8 8 88XSS88 8 888XS8X8888%88@8 8 8S888t8X8 8%8 SX88 SSX888X8 8 S8 SSS8 S8 Xt888X88888@8S8XS88;%XX88XSS8888XS@8 @S8 8 8%8%8 SS 8 888 8SX888:8SS8 8XX 8 8 8S8t8S8S:S@@XXXStSSXX;88@8 SSS888 8 XSS 8 X888@8SX8 888SX8%SXX@@@88 8 8 8 8 8 8 8 8 S8 8 8 8 8 8 8888XS88X88@8 SX8.
@@88888S8XSX88 8 8S8 SXS8;8 88XXXX88@X@8 888SS 88@8 X8@88S888@S8 8 8 8;88@S8%8%8%8 8S8888%8 88@8SS8S88@8 8%888@S88888X88SS8@S88XX8.@88 8 8S8 888XSX8X8S8S8 8 8 X888 S 8%88 8S8 X8 8S888 S 8X8@S8SXS8%@SX@SXS8SXX8SS8 8 88 88@S8 88@X@XX@@8 88.888 S8 8%X8X8 888 S%888 888:XX88 888 888 888 8 X88%XXSXX@8S8S@
@@S%S888%XX8S@8 8 X888X8 888SX8%8S88 8S8888 8 888XX8 88S@X 8.8%S S88@;8 8 888 8@8;888 8SS8X8S8 @8 S8S8 88 888@888X8SSX8888888SX8 @8 88@:8 888S888X8S8 8@8 S 888S8 XX8SS8SX8S8X8S88t8 8 8 8 8X8SX8 8 8%@XSXXXS8 8 8  88@S@8 8.S 88@ 8S8 8 X8 88X@ @S88%8 8 8888 8 8%8 8 8 8S8 8 8S8 X8 S @ 8 888SX8XXX8S@8 8 
@@X888S88SSS8S@8 8 S888%8S8%8 %8S@SS8 8S8 8 SS88S8X@8 X8%8%8@ 8 8 8%SS8 8%%8 8SX88X8 8X8%8XS8S8 8S8:XX8S88 88XX88S88S888S8SX8;SS8SX88888X8X8 8S8 8@8 8S8:8S8 8 @ 8 S 8 88XX8S888 8X 8 SX88@88SXSS8 8 8 8 XX8 8SX8X8 X8 8%88@8S8 8:XS88X@88 @ X8S8 8 8X8 888S%8S 888 888 S 8:SS88@ 8 S8S8t888 8S8 88S8 8 S8 8
@@XSSX8 88SSS8 88X888@S8@8 8t8 SX8 888 8 8 8 8%8X88S@8S8@ 8X@S@8.888%888 8 S8X8 8X8X8X8@8X8SX8XS 8;8 8 8 88S8SX@S8XS8@888S8S88SXXX8%X8X8SS8S@@SS8S@X8 8;8 888 8 8 8 88@ @8SSS8SX8X8S 8S8 8@8 8%8 8 S8 8 8 8 888 @ S888 %8X8SX8;888S8%8 8:8 S8%X8t8 8S8 88@X8 X8 8S88%8 8 888S888@8:8% 888%8 S 8 8 SX%8 8 X8 
@@8XXSX8%X8XSX8X8 X 88X88X@88@888S8S8SS 88888 8S8SX8SS8S8 S888X 8 8 X 8 88@S8SS8 8%8 8X8S@S8@8X8 S8 8 888S888888X88888S@S888S8XXX8:8 SSS@8X8S88%S88@@8.@XS8SS S88888@8 8%X8 8 8 S888S@8 8 X%8 8 88@ X8 S 888 8 88@ X8 8 88@8S88XX 8@888 8 8 S8 8@@8:888%8 @ 8 XSX8 8@88@888 888888X@8 XX%8 8 8 888SX888 8 X8
@@X8 8 88@X8@8 X 8 @ XXSX88@8 8.8 S8X8 8 8 8 888 8S@8SS8X8XXSSX88@ 8 8 8 8 8 8 S8 8 888X8S8X8 XX8 S8 88S 8@8SX88XS8888S888X888@8 8 X8 8 S8 S8 888 888S8 8%S888%88888XSX8S8 888 8S8 X8X88X8 888 88X 8 X8 88@ 8 8 8 8 S8S8%8S@8 88S8 8X8888888 S8S8 8X%8 8 8 8 8 @ S8%8X8S%X88.8 8 8@888 8 S8888@ 8 8 X8 S 8 X
@8 8 S8 88%SSS8 888 8S8 8 8 88 888S8 SS888888 8 X 8S@8X8 S8%8 8 XX8.8 XX88@X X8 X8 888S8 8X888@X88 X8S8S88888S@8888X8S888888@8@8XS8 S X8 8X8 8 888@8 @8 S8 8X8X888SX8 8 8;XS8 888 8 %8S8S88 8 8 8 X 8 S8X8 8888@ 88@ S8 8 8 88 8 8SS8S8888S@8 SX@8S8 S8 8 888 88@ SSS8S8S8 8X 8 8%@S 88S8 88@8 8 88XS888888S
@@8 888S@%XX8 %888888@@8 8 8S88XXS8 8 8 8@88X@ 8 8 8S@8%8 8 SS88%8S8 8 8 888SXX8S88S888 X 8X888S8 8S88S8 8X8SS88S@S88888SS888@@@8 X888S88.888X8 88SS8SS888 @88S8888 X888%8 8 8 8 X88 X8 8 8@@88888%888S8 8 X8 8 8 8 8 X8 S 8SX@X8:8 SXXX%@8S88S8 SS88 XSS 88S8 8 88@ 8@8888%8%88.8S88X8S8888 88X8 8.8 888X8@
@XX8 @ 8 8 888 8888X8@8%S8888 X8 8 88X88 8.@88 S888@8SXXS88@S8 X8S8;X8888X@ 8%8 8 8X8 X88S 8X888SS 8.88S8@888888S8SSX888@X8S8S8XS8 88@S8 8S8@8X8SX8XX88X8%8 S8%88SX8S8 SXS88888 8 888SS8 8X8S8X8S88@8 8 88@ SX8 %8 88@ X8 8 8%8 8XX8 8S8S8 8 XXX8 8 X8 88SS8 SS8888 8S8 8888 8 8@8888 S8S88 8S8%888888 88XSX
@@8;888 888 8 8 @8 8 8;8 8S888 X8X8;8X8 8 8SXS8 @ @ S8%8 8SS8 8 @X88 888S8 8.888 8 8 8 8;8 X8X8 8 888 S8S8S8888888S88888888X8888XS8S8 8SSX8%8S8 8 @8 888 X 8 X8%X8S@888S8 88%8 S 8%8.8SXX8888 8 8S8%88@88888 88@ 88 8 8 SS88SSS8S8 8 S8 88888%8 SS 8 S8 8 88@ 8 8%8X%888X8 XS88S8S8 @8 SXS88% XX8888X88 X88@
@@@X%8 8 8 8 888SS8 8 888 8X@ 8S8 @8 8 888888 88X8 8 8%88;8 X88@X8 88X8SX%8.888 888 888 8%8 888SX88X 8 S8SS88888@S888X8SS88888888SX%8 S8S8.XS8 X 8 8S8 XS88 8 S8 8X8S@X8S8 XS8 8 88 X@8X8X8S8@ 8 8 8S8 X8X8SXS8.8 S888 8S8 8S88XSX8 8S88@8X@ 8:8 8 X8 X888 8 88@.8 8%SS8@S8S8S 8 @@8 X8 8X8%8S8 %X 8 8 8 XX@
@8 8 S8 888S888 8 8% @X888@S@8:888 XSS8S8X8X88:8%88@SS8%8X@8S88 8X8 888@SXX8X8 8 8 8t8 888 8 X8X8 SXS88 88@8XXXSS.8@SSS8@888888@8S8 888S888S8X888S8:S 8 8 8@88SS888 8X8 @X8S888 8 S8X8 8 @88S88SXS88888 SXX8SX 8 8%8 S888 888 8S@88888S8888XX 8 888 8X8 8 8 S%8;8 88X88 8 8 S8 S8X8@8 SS 8@8S888S8%S8 888S8 
@@8 8 X8 8:8 8 8 88@%S8S8S88SX8%8 8S88@ XX@XS@8 8S8 8 88@8SX8 X8SS%8SX@8S8SX8S888 S 8 8t8 8%8 XSS8 8 8S8 88%888S888SS88888X88888888t X8S8SX8X8 888S8 8 88X88 88%8SX8 8 8XS8888 88@ S88S888X%8 88888%8SX8 8SS8 888 S88 XXS8 8 8 8:88SX 8S8 X8%888 8 888 8t8;8%8SSS8 8 SS8 88@:%@8S8X888 8%X8 8S@ 8:8 8 @8 8 8
@XS@ 8 X8;8 8;888S8 8%@88@%X8 8 88:888 8S8 8X8 8 888:8SX@S8S@8%X88S88@@ 8 8SSS8SX888X%88 888%8 8 8888 8X8SXS8888X8SSS8@SSS8888@@88S88XXXS8SS8X8 X8 %88888 XS8%SX%8S@8 S 8S8X888 8 8 S8S8 8 8 8 X8XX8 8SX8 8 S%88X8%8 8 8 88:888S8 8 8 S8 8 8 8XX8 X88 888 888:8 888 8 88@X@@8SS8 X8X888:8 888@8 X8 8 8 SS8  
@@8SX 8 S888 8 8.XX S8 S@S8 8%X8S88S888.8X8.@XS88 8 8S8%8 88%S8 888XSX@8 8SX8%%888X8888X8@XS@X8:8 8 88X8 8S8SX8XS88888S8S@8X8SS8S88@@S88S@88@@@8 S888 8XX8X8SXXX8%8S@8 8:8 8X8S@8 S8 8 8888 8S8 8SX 8 8 SS88S8 8SS8S@8 %8 88X8 8 88@.8 @8 8 8:8 888 X8@8 8%8 X8888S%S8.8%8S8 8SS@SS8X8 X88XX8S@8 X8 888S88@S
@@XX8888 X@S888:8S888X8SSSS888S88SS8S8@8S@88S8 8S8@8X8@8X8 8@ 888SSS8 8S8 8 888X@SSSS8@8X8888S8X 8t8SSXSX 8X8888X88@@888888SS8S8@8888S888@88@8888 %X 8 8SX8X8@S888 8 S888 8 X 8S88888X8S8S88.8X8 8S888 8 8 XX88X8SS8 X8 88 X8 8 8 8 8 8 @8 888 8:@8X8S@ 8 8 8 8X@S8888%X8 8;X888 8 8 @8 8S8 X8SS8%X8S8 @88 8
@@X8.8 S8 8 8XX8.8:88SX8 888 X@8 8  8X8XS8 SX 8 8S888@8S8S8S8SS8 8 8 888 88X X8SXX8888SS8 S@8888 S8 8 8S8XX8SS8%8S8%8X888@S8@8@SSX8S8S@S@888888888 .8@XX8SS8S8 8 S S8 X8 X 8 8 8 8@@88S8%8 88S8S888 8:XS8:8S8%8 88XS8888X@8 X88888XSS8S8 X X8 88XS8 888S8888X8 8 8.SS8X8;88888SX@8%S8S8888 888X8 8 8%S88X 8 
@@SSSX8 S888 8S8@XXS8 8 888 8 88%S8 X8%8  @S8S888X8 X@XXX8@888S88.888 8SS @.8XSXX8 8888%X8S8 8 8 8:S888@@8 @X8S888X8X88@S8S88S888888@SSS8XS@@88@%SXS8888S888.S@ 8 888X8 8 888 8 8%8 888X@@8S8@ 8S8 8 8 8 88888 8 88 X8S8@8 8 888888X8%S88S8 SX8XX8 8 %8X8888@888@X88X888X 8S8@88 888@X88S 8 8 8 8;8:8 @8XS 8
@@888XX8 X8 8;8%8 8SS8X8%8 888 8X88XSSSS8SS8 8 X8 S88SS@8S8@8 8 X8S888@8 8 8S8 8 88 8SX8SS8S@XS88;8 @ 88888 8 8 888S8@88888888888X88X8@:8888888X88888888XS@8S888;t88 88888 8;8@8;8 8SX@888 888888888888 8S8 8X888S@8 88@8 S 888 8 S@88S8 8 8 88@S@88@ XS 8 8 8.8%8 8S888S8 @S8 88 88S8;@8%S%88SS88 X88 @8%8 
@@S 88 X88 888 8 8 8 @ S8 8X8@8 8;XX88X888 8S @ S8XXSX8 888X88@8S%8X8X8 88@XX 8 8S88%@SS8SX8S8 8SXS8:8S@XX88 8 8S@X888@X888@XS888888SS8@X@XX88XSSSS8@X888X88@8888X88@tX8%@8S8SX8X%88888888888S888888@8888@888888X8X88 8SS8S8t8SSX8X8 X@88 S 8 8 8 88 8 8 88@8 8@8SXXXSSSS%8 8 8 88%SSS8 8 8 8S8%8%8X8 8%X88S
@@@8 88XS8 SXS888 888 8 S8:X%8 888 8 8 S8S8:8XS8:S8SX8S8S8 8S8SX8XSXS8%S88 8X888 8 8@S8 8X8 @@8;8 8 X8@ 8@88XX8 8XX8S@S:@@88S@88@88X88XS88888@8888S8888@S88S@8X@X@88X@X@:.8@@8 88X8888888888X8888888888%8888%@8888888888@SX88S8S@@8 8%8S@8S888 X88 @8 888S8S88XX 8S8SXX8 888 8 8 88 8 8%88 8.S 8;XS8 888 X@8
@@X@8SX8 88 8 8 8.X8 88@ @8 8 8 8 888 8 S888 8%88SS8SSX 8 8 8 8%X8 8 X8X8 8 8 8 888S8 X888 8X8 XS88XS8%888 @8X88 8S@S88@XX@88@@XX8X;88888@88S88XX8888S8XX8S888@S8888@S8@XXX8SX8 8 8S88@888888888888888@8888@888888888888X8@88 XX@8@8@8 8SXS88 8 X88 88%@X8%8 88X8 8 8 888 8 888 8SX88@8@%8XS88XX88888XX @S8X
@@8XX8 8S88SX8.888XX8 8 8 SX8 X8;XS8%88XS88 X8888X88@8%88S%8S8 8SSS @ SS88@888:@@@8S 8%8 S8 8 8 8 8 X 8X8 8.S8%X8 8 8S@88888XSS888X888S88@@X8888@S8888S8888888S8S8X @@@8SXSS8S@88@ @ 8S8@8@888X88888X8888X8888@88888888@8888888XS@@X@88 8 8 S8 8 S88%888@ 8 8 8@88 8X8S8 8 8 8S88@S88%8S8 8 888X 8 8:8 8 8 8
@@XXSS888 @8 8XXXS8S88 8 8%88@ S8 8 8 8 8 888888@8888S88888X8888888 S8888SSX8 8 8.@88:888 XS888 8% 8 8 8 @88 S@SS8X8 8S@X@8t8888@8888SX888888X@SS888@X8S888@8888@@X@XSXSXX8 8X8S8@8 8 88S88@S%888@888888@888@8888888888888888888888@8SX8 8 8SX888%XX8%X8 8 8 8X8 88S8%X@888X8 8 8.8 8@ 8 8:8SX8 8;8.888 SS8 
@@XXX88@ 8.X8X8 8S@8XX8 888 8 8 S8 8888888888888888888888X888888888888S8 @8XXX 8 8SX@8X@ 8S8 8 88@SS888 8S888 8S8S8S@@SXXX8SX@8S8X88SS8XS8888XS8@88SSS@@S8X%:@SSX8SSXX8 8S88;8 8%8 8 8%8S8 @8 8 88888@88888888@8@8@8@8@88888X88888888XX88 88@%88 8X8SXSXX8 88%X@8S88 8X8S88XX8 888 8X8 888@88 8 %8 8X888 8;8
@@8XX%X8 S8 SX@8:8 8 8 88@ 8 88@ X888X88888888888888888888888888888888888X8@8 888 888SX8 SS88888 8S8SX 8 8X8@888X888@8@S8%8S@SSX88tS88@88888SSS888S8S8X88@8@88 8%XSXXSS8:8 8XXX 8 888 8 8 8 8SX88@@@888@8@888.@@888@8888888888888888888 SS8 X8 8X 8X88S8 888X8S@X8SX8 8 8%@8%888S8 SS88S8@8 X8X8%S%X8S8SX 8 
@@XX8S8 8 S8S8 S8 88@ S 8 888 8 X8X8888888888888888X888888888888888888888888@8X8 S 8S8%8888X8X88S 888X888 8X8S88@8SXXXSSX8 8 8S8@8S8X@88.%8888888888%@%8@X@88 8 8 8 8 88X 8%8S8S 8 8 8 S 8 8 8 8 XXXX8@X88@88888888@8888888@8@88888888@@8S888 @S8SS8 @@ 88@@8 8S8@8S8888;8 888 SS8888SS8%888 88X8S8 X8 8 8 @
@@X8.8 S 888 S8 @8 8 8 8 8 8 8888X8888888888X888888888888X888888888888X88888888S88 XXX8 S888XXX88@@@8 8%S8 8 8 8888 8 8 8 8XS@8 8 8 8S8SX@S@888@S@8t8@@SXXXSS@ 8 8t8:8 8 8 8 X 8 S8 88@ 8 S 888 8 8 8 XXSS@8@88@88888.@88@8888888@88888888@%8 S8 8S88S8 XX 8 S 8X888S88 XX888 8 888SS8SX8X8@8 8SSX@8S88@@X8 
@@XX8 888 8 8:88 XS8 S88888 88888888888X888@8888888@8@8888888888@8@888888888X888888@8SX8 8 88S8.8 8S8888 8%X8 8X8@@8 888;8%8S8 8 8 8 X 8%8%88X@X88888@8X@XX8 8 88X88SSSXS8888%8:8 8@ 8 8 8@@@%8t8%8X8@;@;8 8t 88888888888@888.888@8@88888S8888 X8;8 X8 8 8%%8%8 8X@X8 @8 8 8 888 8 8 8 8 8X888@8 @ S8S8@8 8S
@@8S%X88X8 SX8888S88@ X8 88888X8SXS@@X@8S88XX@@X 8@8888@88888@8@8@88@888@888888S888S888 8.8%X@SX 8 8S8X@88XS88%@@XS%8 8:X8@888S8@ X 8 8 8 8S@8X88888888888888 8 8 S8X8 8S8@88888888t88%88X8X@X@X@X8XS8@S@X88@888S@X@@XX@888888888888@8X88888888%8X 8 8 8888 8  8 X8SS8 XS88888 8 8 8 S8 X 8X8X888;8 88XXX8.8
@@XX888S8 8%8 8SSS@8 8 X@8@8 XSXXX8 8 8 8S8@SXX8SXXX8S8888 @8888X8888X888@8888@88888888S88S8 8 8 888@88 8SX8 88SSX8 8 88%8X8 88888 888.8X8 8S88888@8@88888888S888888S88.8S8@88888@@X8@@888X88XXSS@S@8XX@@@8@@88@@SXXXXXXX@@X@88888@8@88@888X888XXX888X8 8 SXS8 S8 X8%X8 8 @ 8 888 888 X8 8 8X@@@@8 8 @8 8 8X
@@X8 X8@X88X 8 8 8SX8 @S@XSS8S88@8 S 8 X%8SSXXSS8 8 @88 8@@888@@888888@88@8888888@8888@888888S88XX8S8%8SS8 8S8S8 8 888 S8@8 888SS88 8 8S8 8X8888@8@88 @88888@88888888888 @88t8%8S88XX@@@SS888888888888S8888S8@88@@SXXXX8 8XXS8S8@8888@8@88888888@8.8 8.8t8S88888 8S88X%8:8 888 8 8 8 8 8 8X8SXX8%@8%8SSS88X8
@@SS88@8@8 8 88X8 8 8X@8 8S8 XS8 S88SS8S8SXX8 8 S8@8S8%@SX8@@X@@8888@888 @88@8@88888@88888888S8@8XXS88 8S88;8X888 8 @@X8XX 8S8%8S8 8 888S888888888@888888888888888888SXX8 8 @888:%888888S8XX8S8S8S8S888888S8X888@8XX8 8 8 8%8 8 8S8X88@8@88@888888SS8 X88@8 8 S8X88 88 %8 SS8 8 888 X 888 8 8 8 8 S8 8 8 8S8
@@8SXXXS88@X8X8%88:8X8 XS@88888 8SX88 S8@S8SS88@S8 X8X8 8SXXSXS@@@888@8@8888@88@888888@88888@8888888XX8:8 8X 8X888X8S8%X8S8 8 8 8%X88X888888X888888 88@8@8888888888 XXXSX8 8X@8S@SS@:@8X;8SS888XS8888X8@S88X8SS888@SS888 8 8 8@8 8 8S@X888888888888X 8S8@8%@@8S8%@X8 X8 88 8.S8888 8%8:8 8t8 8 8 8 X8 888 8 
@@XX8 8 S8X8 X 8 8@ 8%8 8S8 S@888@ @88X8%X888 8 X 8S8SS8 8 8S88 88@8@88888@88@8@@@8@88888888888X88888888 8S8 S8X8X@X8 8 8 8X88888888@888888@88@88@888 8888@8@88@@SS8S8 8S8888 8 8 8 8X8.%88888888888S8XS;88888X8@88XS8888S8%8X8 8 8 8 8 8888@8@88888X 8 @ 8X8%XX8@8 8 X8 8 S888 8SS88888 S888 888 8 S 8XXS 8
@@X8SS @%X88S88 8 8% 888 8:8%8@8S@8S8.8 8 8SX8 8 8 8@8 XSSSX8%@8S88 88XX888888@88@88@88 @8888888888888888@88888@888SX88888888X8X@8888888888888@8@8@8888888@8@XXXXXSX%8 S8%8X@8 8%8 8 8 8SX8;888@@X888X8X8XXS88888888 SX8S8 8:8 8.8SXX8X8%8@8888888888X 8 8 @88S8 8XS88 8%S8 S888 8X8X8 8 8:8 888 888X888S8SS
@@XS8%888 X88S8XS888 8 8  8 8 8 8 SSS8S8;8 8 X8t88@X8 8 8S8 S8 8 8 8SXXXXS@8@8@88@888888888@888888888888888888888X@888888@@888S8888888888888X888@888@88@8SXXXX@XX8 8S888XX@8 XS88XS88 8 8SXX@S8SS8888X888@88X88888888X8SX%888%XSX88X8S8 8 @@@X88@88888X 8888SSX@8@8 8S8 888S8S@88 8 8 888 8 8888 X8 8 8 X%8X
@@8SSX88 8X8 8S8 88 8 88@S%888 8 8 8 8 X8 S 8 S8 8 8:XS888 8 8 X8 8 8S8@S8 8X88@88888X88888@88888888888888888X8888888X8888888@88888888888888888X88888888SXXX8 8%8 888 88S8XX8 8 8 8 XXX8X8 8 888SX88888S@88888@8XS888 888%88.8S8 8 8@8 X 8SSXS@88888888888 8888%X888:SS8 @ 88@X8SX8 8 88 888:8 X8 S888 8 8 X
@@XX8S8SXS88SXXS8SX888 8 8 8SX8 S 888 8 X8 88X @8 8 8 8 8 X88.8 XSSSX8X@SX@8SX8X@8@8@888@888888888@8@88@88888888888S@888888X8888X88@88@888 @88.@8888@XXSXX8 8SSSSS88 @S@8.8 SS 8 8 8%8%8SX8 8S@888S8888X8SS88888S8SS8X@8@8 8@@X 8 8S8.8S8 8S8@S8X888888888X8X 8X8SX@8 8 888 8 8%@SSS88 XS8S88XX 88S8S8 8888X
@@X8 8SX8 888X8 S8 88X8 888 8 X8S888 88@ SSS8.8 XSS888%8X8S@@8 8 8888S88%8S@8 XX88888.8888@8X8.8@8@88 888@8@88888888888888@888S888@8@888.888@8888@XXXXX8 8 888S8888S@@8 8X 8 8 8@ 888 888 XSXSX@@8X8X8S88888888S888X88XXX@8X8%8S8888 88@ S 888X8XS88888@888S8S88XX8SS8 8 8 8 X 8 8%@ X8S88@S8S8 8S88888S8X8S
@@SS8 8S88X@SX%8 SX@8 XS8 X%S8 SXX8888%@@8SX8888S8S8 %8X8 8SS%888 S%8S8 8:8 8X8 88XX@S888@888888888@88888@88@8@8888888@88X88888888@88888888@88@X@XX@XSSS8 8S8 888:888XS8S8 X888 S888 8S8 8S8 8 8 8@8SS888XXX88S88XXX88 8S8@8@888%8S8@8XX8S8%8X8S@X@888888 @X@8 @8 88XS@88X8t8S8 888 888 SXS8S 8SS8S8X888 8 X
@@88 8 8 S8 8 8.8 8 S8 888S888%888S8 8X8 S8S8X88888@8 SX88 8 888 88888 XS8 8 8 8 XXXS8@S8888@@88@88@888 88@8@88@888 X88888888888@888@8X88888S8SXX8SS8 8 888 88%@X8 8.8 SSX8 S@@8 88X8 8 8;S 88@ @ 8888SX88888888@SS88;% 8@8S8X8@8 8S@@8 888 XXX8%8%XX@8888@@@X8 X8%X8X888X@8 S 8 8 8 8 8 8 88SS8SS8%8X8 8 8S
@@SSX888%8 8 S 888 888%S8 8 8 8 X8X88 888 S8%8X8X88XX8 8 SS888XX8t8@8@8 8 X 888 8 8 8 8 8S8X88.888888@8888@88@8@8.888888@8888@8X8@@88888@XSS8 88%88%X8 8 8 8 8@S8 8 X 8S8 S8S8 S8%8 X8 888X8 8 8 88@S8t88X8@@@@8888X88SX 8 @S8X@88 8X8 8 8 8 8XXS@8 XX8888@8S8 8SX8 8 8 88  8 888.888SS 888 XX8 8 SSXX@8 XSX
@@X8SS8 888X8S8S8 8 8 @SX888 88@ SXX@8S@@8 8X88;8 X8SX8:8 8 8 8 8X 8X888 8 888 S 8 8 S 8 X 8S@S8888888X8@88888@888@88@8.88888@88888888@XXX8 @8 @8888 X88@ X 8S8 88 8%8:S 8.X888S8SS8 XS8S8 8SXX 8 88@X@88@888S88XXS8S8X88:88 @8S@88 8 X88 8 8 8 8 S@8 88X8@S8 8 8SS8X8 8 888 888XSS8 8888@ 8 88@@8 8 8 XX88X
@@8.8 S8X8X8%@88@8 88@.8 8SX8 8.8%8S8 8S8 8S8 @X 8 8XX 8 888.8X8S8XX8X@@888@8 8 888 8 8 8S8 8@SX@X8888@88@8888@8888@888888@8X888888XXSXX@SS8 88S8@8 8%8 S8 888 8S8X@8 8S888S8 X8X8 S8S888 8S8%8%8X8SSSX8S88@888@S88@@8XS88S8@8 8S888X8%8 XSXX8 8;8 8 8XX8@8SSX 8 8 @ X8 8888SS8 8 8:888.8 8 8S8SSS8 8:8 8 X8
@XXXS8 SX@8%8X8S8 8%8 888 8 8S 8 888.SS8SXS S8 8 8 X88XS8888@8 X8 8S@8S8X88888S8X8 888X8 88@X8@SXXXX8X@888888 888@888.@8888888@X8X8@SXXXS8 8X8S8 8 8 X88 S%88 88@S8%888X88 8.8 8XX8 X888 888 X88@8X@88888XS8888888@88%S@S8@ 8 XX8S8S8 8 8 8S888 8 8 8 8 X8 8888XX888888888 X8@8@@8:X8XX8S8 88X 8%88@ 8 888 8
@@88S@888%X8XSS8;888 8 8;8 88@S 8 8:8 888S88S8%S8:8 X88888 8 88S%SX8 XSSS 8X8%X8 8SS8S@88 8 8%8%XX8 XS%S888.88888888@8888.@XX8SSX8SX8 8S@S8:8X888@XS8%8 8%8 X8@8 @ 8S8X8 X8 S88;8 X8%8 S8 8 8S8 @ 888S88S8S888@X@888@%X@8S8SS88X%@SX%8 S 888 8 888 888 8 8XXSX8X8 8 X8X8SS8 888@8;8 S8 8 X8 XX8 8 XX88@%8 8 
@@SX8%8888X8S8 8XS8 888 888SX 8 X8SS8 S8%8S8 S8 8X @8 8 8 888 88S8SX8 8S8SX@ 8 S8.8 X88X 8 X8XS8 8 8 SS888S888@8X8888@X8X88SXSXXSS8 8 S888 888@8@8S88@@8:888S8 SX8 SX@XS8SS8 88X 8:S8:8 8 S8:8 8S8 @88@@88888S8S88@@@8S8SX 8 @8S8 8XX%8 8 8:XS8 @ 88X 8 8 8 8.X8 8;8SSS%8%X8 X 8 8;88SS 8 S88XSS88S8 XX8 S 8
@@XX@8%8 8 8@88S8SS8 @ 8 8:X88 8 S8 S8% @X888 S8 8 88XS8 8 8 @%S8 8 S SS88X8S%88 888 X8 88@ 8SXS888 8%X%8888@8@8X8888888888SXXX8 8 888S@%8%8 X@@XS8 8S8 8S8@888S8 8 8S8  8 888 8% 8 @8 8 8 88 888 8X@SS88888X88X88X8888XX88 8 XXS8 8 888 888S8 8:8 8 888 8 888XX8SXX8 8 S8 S8S8 8 X888 888S8S8 8 SX88S8 8S8 
@@8@8 8 8 8X8 @X%8S8888SS88S@8S 8 S8888@@8S888 88S8SX8S@8 S 88@ X888 8S8 XX@8 X8S8 S8 8 X8.X8@8 8SS8 8  t@X8X8X@@8X@S888@888X8 8S 8 8 8SSS8 8 8 8 %8:888@8S8S888@@8@ XS8 8888 8 8%S@ @8 888 SS88X8.888S8888X8XXX8888888%8 8X 8%8SS888 88@8 SS888@XX8 S8 888 8 8 X888@8%88@8%X8 88@ 8X@8 8 8X8X8%8S8 S8S8SX88
@@S8.888SSX8 8 8%X8888888SS8 8%888 X8 8@8%S8XX8;8 88XS8SX8 8 8 8 88 888 8 8XS8 X888 X888 SXS88SX 8S888S 8888SSS88XS8888888XX8S8 8 S8SXS888S888 8 8 88@8X8 8@8S8X8%8 8%88888XX8 S 88S8 @8 8 8 888X8@8X8888XSS88888S88%X@ 8S8%8 888 8S88 8SS8 8 8@8 888 88%8 8 8 8 S8@8%S88 X8 S%88S@@X888@8@8X8%S88@8S8 S8 8X
@@SS8S8 8S8SX8 S8 X @XX@888@8 X88 8 X8 XXXXS8SSX @SX8 888S8 888 8S@8 8:@X8 8 S8 8 S8 88 8 8 888 8:8 888 St8X888888t8S88888888X 88@ X8S8 X888XS@8888 X@%8 8@8@XXXXX@8 8 8 SX8S@8 888SS8XX88@88 8 8:888S88XS888SSX88@@.SX8;8X8 8 8 88@XX8 8 SS 8 S 8 @X88 8 888 S 8 X8%@8X 8 S8 8 SXXS8X8X8 @XX@8 8S8%@@8 SX%8
@@88S8 8 8;8 8 S 8 @X8S8 @8 XSX88XX8S@8 8 8 S8888 8 88 8888888.X 8S88 8 8 8;8 88.8 88 88@88@S8 8 S88@8 @ 8St8@S@888888XSX888X8@X8 8 S8 88 XS8@8@8SS8S8 8888S8X8 8X8 8 88@ 8 8 S%88 8 8%8S8X888:888888888S.@XS8S88@@8@X8%8S8 888 8 8 8 X888 8 S8S888SXS8 S8 8 8 888 S@8S8SS8 88S8%8 8 XS8 8X8X8 8 8:8X8 8 8 X
@@SSXX8 S 8 88@88888X 8S8 8 8 8:8 8 8 SX8 S8 8 X8%X8 X8S8X8S@X8 88@ 8@888SS888S8@X8 88X8S88%X 8 8 8 8 8 8@88SSS8XS@88888888@8888X%@8S%888X8 @8%X 8 S8S8X8X88S@%8 8 888 8 888 8 8 SSXSX8 XS8X@X88888XX888S88888SS888;S8 @XSS8.8 S 8 S @8S8 88@ XS@8 8 88@ XS8888S8 8S@S8 8S88S8X888SX8 8 S 8 8 8 S 8 8 88888 
@@X8S8 8 888 8 8888@S888 888 888 8 88@%88@ SS8 888 S8%X8SXS8S8 8 8 8S8 S8S8.@X8X8 S8SS888 8@X8 888 X@8%@XS88S8888S8S@XS888S8@88888 88SX8S8 8 X8S8.8 88S8S8SSSSS888SX8 888 8 S 888 8 @ X8 8 8 88X88SSX88@S8SX8888888XSS8XXX88SX8%888 888 8 X8 8 @ SS8 S8 8 888 8%X8:8 8 X@8 X8S8 88S88XS888888@X88XS88@X8X888
@@8 8 S 88@ X 8:8X@%8X@ 8 8 88@ S 8 8 X88S88888 8S8 S8 888 SSSXX88S8@S8SS8 888S%X88 8@8 8S8%8 8;X 8X8%@XX8Xt@S88S8X8S8S888@8S@8888: X8SSSSS88S@8t888S8 S@SXX8 8 X8X8SS @ 8 8 8 8 8 88X SX8 S:t@8@SSS8X8S888888S8@X8XXXX8 888@8:8 8:8 8 888 X888 8 888 888X SX8 @ 8@@8 8S8.88 8%8 SX%88X 8 8888XS@8S88%XS8X@@
@XS888 8 8 8%888 8 8 X88.8 8 8 8 888 8S8 X 8S8 8 8888S8X8@8 8S8 X8S88XS8SS8@8X8S8 8SSXX8 8 SSS88 8 8tXX8 8SX.8XS88XS88888S88888SX@S88X8 @S8 S8 X@X8SSS8%8 8 888 8.X8@8SS8888@ 888X8S8 8 8X%;S888S888888XSS88@S8S88 8S8 88S8 88SXX 888 8 8 8 88 888%8 888S8X8%8 X8S8S8888 @SS8@8 8S8 X88SX8 8.8 8 S8 8@S8%X8@
@@S8S8 SS88X8 8 8 888 88SS%S888:8 8;8;8S@88.@@888S@%8 X8S@@8:X 8%X8 8 8 8S8 XX@8S@X8 8S8888S8S8 888 8 8 8.8 8;8X8888@S88@88888XS8X8888%8 888 S8 888XSSS88XX888 88@S8SX8 888XX8X8S8 8X88;;8%8@S8S88X@X8X8.888SSS88@8 8 888%88t8 8%8 8 S 888 8 88@8SSX888 8%888X8 SXX8S8XX8XXS8 SS8888S 8888SS8 8S888S8 8 XSS8
@@8:8S8 8 @ SSX8t8 8:8 888888X%8 888 8888 88S8SX%8 XS@SS88XS8 88@S8XS888 @88S8 SX8SS888S8 S88@ S%8 888;88888SX.@8X88888888@X888S88@8888888X@XX88S8X88 888@888 888S@ 8 SX8888 8888;@8%t8%88888SS8888S8888888X8X88X8%8 8 8 8 8X@8 88@.8 8.8 8S888%X8 8.8 X 8S8 88X%8 X8 8 888%8888%8%@8SSSSXSSXS88@8 8X%X8 8 X
@@@8@8 888 8%8 S888 888 X88888 @8 8 8S8 8S8t8@8 8;8 8 8 888 S8 8 8X8S88%8X8 @@8 @S8 S8 S @SX8 8 8;S88 8 8 8%XXX@88XXX88X88888@S8S888XS@8@88S88.88X8S88:8 8 8 X888S8 S888S88@ X%t88SXX8X8@@X8SS88S@S8X88S@8X8888XXS8 888X8S8 8S88 8 S 888 888 SS8SS8SX 8 8 8 8 8 8%8 8S%8SX8S8.X8 S8 XX88@8S8 8 @ 88%8S8 88@ 
@8 8 8888 888 8 S8 8 8 8S8 8 X8 X8 8 8 8 X88%88888XS 88XX888 XX8 S8 8 8X888@8SS8SXX8 SX88 8 S888 8 8%SX8.8 8S8SXXSX8@888S@S8S@888X8SSS8X8888tS88888S%8%88@8 8888X8S8X@888t8@X8X8X@88@X8SSSSS8SXXSS888@S8888@88@X@SS888S8%XXS%8 88 8 8 8 8 888S8SX8%88@X888 888 888S8 8 @8 8 88S88%X88X88 SX88.8 8 88888XXX 8
@@8 8 888@X@SX 8 88 8 888 8 8.S8%S X8 8 8 X88@8X8S8S8;8 8X888X88XSX88XX8 @88X8 S8S8@8X8 8  8S88SX888 @ S8 S 8 8 8S.88S8X8X:8@XX88SS8S88@S888@S88@888@@%8@888888X8888888@88888XX@888SS888888888SS88S@S88888XXXX8 8%8 8 @ 8S8 8 @%888S8X@8 8S8@8X8 XXS8X8%X 888 8 8 8.XX8SSX8 8.8.X88 88888%8SX8 88XS8S8@@8S8 
@XS88@S8X8 8%8 88S8XXS8 SSS%88 X8888 8888XS8 @S8 8%X88@8 8X@@%@8 8 8%@X @S8S8 8 S8S@88%XS8 X8 X8%8S@8:8 X8S8;8 8 8 88888X88SSS8SX8@8@S8X8S888@@8888X8@XX@88888888888888@@8@SSS88S8SS8SXX8@88SSS8SSS8SS888:@X8S88 888 8 8 888;8;8%88888X8XX8S@XSX8S8%X8%8%8;8S@ 888 8S8 8 88@ 888 X88X8 8 8 8 888SXX@XSSS%888
@@8 8 8 8 X 888 S@88XS88S8 8 X8X@S%S 8 8X@8 8 8 8t8X8X@88XS8S8SX8 88@X8SX8 888X8 888X 8SX888X8 8@888XS 8 8 S8 8 8 8 8X;8@SSS8X8SS8@S8:8888X888X8X888S88888888@X888@888S88888888S8888S888888SS8XXSS.888X S@XX@8S88 8 S 888 8 8:8@8@8S@8 8888@8 8SS8%8 8X 8 8 8 88@ 888.X8888 8 8;8 @8 S@8 S8888 8 8X8@S8 8 8 
@XS8 8 888%8 8 8%8 XS8.8@8SX8 S8S8S8S88;8 SS88X S8 8 8 8X8SXXS8S@8 8 8 8%88@8SSS8 X8X8 8S8 XSX8X8 X8S8 8 8 8;888 8 8S8 8888X8XS8S888@888X88@@X8888@S8SX8S8S888S@8S@8S8S8S8X888@8S888SXX8@SS8X8X8S8SS888@XSXSS@8 8 S8 8 8 8 S 8X8X8%8 @8 8:8 S8 8SX8S8S8S8X88.8X8 8 8 8 8 8.88 88 8S@8%888 %888SS888X@S888 8%
@@8;8 8X88888 888 8 888%8 8S888S8@8%8 8X 8%8 8S@ S8 S 8 8X8S8 S8 X8 8 S@8 X8 8 SS8XXXS8 88888X 8:8 XS888 88%S88 8X8 XS8S@S88X88@8888SX8S8888@8SXXS8X8888X8888SSS8@8S888888888X8888@S8S8@SS88@X888;8@@@XS@XX8 8 88@ S888 88@ 888 888X8 8 8@X8S@8 8@8.SX 8X8 88%8 888 8 88@ 8S888X@ 8S88@8 8S@SSX88X 8 8 8 8 8
@@@8 S 8X8S8888XX XSX8 8 8;8 8888 S%X8X8SS8 8 8;8 X8%8 88X @ 8:X8%SS88X8 8 @8 8%8 8 8 S8X8 888% 8 8 8 8.8 %88SX8S8S8S8 8 8X8 888S8@SS88XSX8888XS888@SS88XX88SS8XX@88X8S8X888@@X88S8X8888888888;@XX8SXX@SX8 8 888XX@ X8 8 8 8 8 8X8S8X%8888S88XX8%@X8 8SS8 8 8888 8 88@ 8 S 8 S8X8 S888 8SS8SX8S 8 8 888.888;
@8 X88 X8 8S8XX888 @ 8 88 88X @888 8 SS@8 S888 8.8 8 S8S8S8S88@ X888S%8 8 888888 88@:88 8%8S8 8 8 888@:888SXX8 8 X888S8X8 8 8S888t88X8888888@X8X8@S8@8888888S8888888XS88888XSS888888S88888%:8@XX8SSXX8 8S88 8 8 8S 8 S%S8 888 8 8@8S88X 8 8 88%X8@8 88@%88 8S8X888XS8 8 8 88@%X8 8 X88SS8 8S8%8 8 8888 8 8 @
@@8 888 8%S8 8 X@8SS8.8 8XX8 8X8S8SS8S8 S8 88 X 8:88@S8 X8%S8%X88SS8 8 8 888 8SX8 8:XS88%8 8 888888 8 8 8;8 8 8 8S8 8 @ XSX8 8@8 8X@88.S8@@SX8X888S8S88XX88S:8@XS888@88@@SS888@@X88S8t88@XXXXXSXSXX8 8 S8S8X 8 8 8 X88@ 88 8 88@@8@8@8S8 8 8XX8SSX@8 8 8SX888 8S8 8 88@8.8 8.8 8 88X8 8 8 X8X8.88@X8 8@S8 8 
@XX8 8S8.8 SS@8S8 8 8XS8 8 8 8 8%S8 S8:8 888@8S8 X8@X888%88 88 8S8 8SS888 8 8 8 S8:8 XS8SX8 88X 8 X8 888SX 88888 8S88 X8 8 S8@8S@X8S8 8@S@88%8888S8888S8S8888S88SX888888S88X888X888XXX@XXX8 8XXXXX8SX88SX8%8SSSS%88 X8 8 S 888S@8X888X8 888 8 8 8S8S@8 %8 8%@8 8 8t8X8 8@@8 S88 8 8SX8 88@ SX8888 8%8%8 88 8
@@88S8X8XX8 @ S@88X8S8 88888888.8 X8 @8 888X8S888 8888SX8 88 8 SSS888 88 8 8 S @8%S @88S8 S8S8%X @SS8.8 8S8:8 8 8 8 8S%8888%8XSX8 88%8S8X8S@S@@88888:8t8XXXSX88888SS;;88;88888XSXXX@XXXX8 @8@SX8 8 X8.88 8888 888 S8 S8 8 8 8 8S@XXXX@88 8 8 8 8 @88%888S8 8S@8 888SX@8@8 X8SS8@@8X8 XS8 8S8X8X888XS8 S8 S%X
@@%8X8 8888%S8S8@8.S8 8SS8888S8S 8 88 XS8SXX@8S888%@888SX8 88@888888@8XX888:8%888%8 S888@@8S8 8 8 8 8XX888.8X8:X 8 88@S8 888 8 8 8 8SX@X8@SSXX8%X@@@S@ @X8SSXXXX8SSXXS8SX8S@XXX8 8SXSXX8 8 8%8 8% 8 88:88S8 8  8 88@8 8888888S@8S8 8 8XX8 888 88XX8@8 X8 X8 8S888SX88XX8 8 88888 88S8 8 888 8 X8@8 888 @8S8 
@8 8 88 8XS8 8 8 88 888@ S 88888 X8 8S8S%8%8 X8X@@8 8X88SX8S8 @XSSX8 X8 8%SS888X@S88 S8S8 X8 888.88@S8 8SX8S8:8%888 8.S 8 8;8 8 888 XX8@8SXX8 XXXX8S@S8S8 @X@XSXS8 8S8 8 XXXX8 8SSXX8 8 8 8S8X88@%S8 88 XS88X888@88  @88%8 88888X88.8 8S@8S8 S 8 8X888 S8%SX8S8SX8SXX8 XX88 @8XXXX8 SS888X8 S8 S8%8 8 8 XX@8
@@8 8%8888SX8 88XS88 8SX888 @8SX8 8%S8 8 SS@8S@8S8 8 8S@8%S8S8S8 8 X@SSSX8S8 8 8 8:88SX8 8S88X@ 8 8 8 888XS8SXXS88 X88%888 XS88@ 8 8 8 8:88 88X8 8%XSXS8:8 8 8@SSS8 8 8 8 8 8 8 8 8 S8 88@X8S888 8 88 88888SXS888SS8 8888S8 X8SX8 8@XX8S8 S@8S8 8 8X888 S8S888.8 @8 8 8 8 S8 XX8X8 8 888 888 8 8  S 8 X8 @ S
@XX888X8SX8S8888 8 8888%SXX8 X8 S888S8 8 8S8 8 8 88 @@8S@8S@8@S8S @ 88888X888@8@88@88@8 X8%SS8S888 888.8%8SX8S888S8X8 888 8 8 8 888 888 8 @8 8@88 8 8 8%X88 8S88 8 8 8 S 8 8 S 888 888 S8SXS8X8XS88 88 8@X@888S 8XX @S8S8X88SS8SS8X8S8.88@X8 8 888 8X888%@8 88SX8SS8X8:8:8 888X88888X%S88 8 88@:8%8 888S8 8 
@@8S8 8 8S@888X 8 8S8X88XXS8SXX88@@ 8 88@:X 8 8 8 888X 8S@8@8XX 8 88 @X 8X8@8X8SS8 @8SS8 888@8888SX8S@8%@S8SS8X8888 888 %88888 8 8 8 8.X @SS8%8%88 X 888@8 8 8XX8 888S8 888 8 88@ 8 8 8 SX88 8S8X@ 8 88 8S8 8S8%888@@8 8S8 88%S8%S8 X 8 8 X 888%8 8.8S@@@SS8 8X8:8 8888S8 8 8888X8@8S8%8 8;8 8:88@88SS8%S888
@@SXX8 88@SX8 8 888@ 8%88SX 8 8S88 8;8 8t8S888%8X8%S8XX 8X@8 8 8 8 S8X8SSSS8;8X8 S8 X8 X8 X8X8@8.8%X@XS8 8 8S8 S88.8 8@8 8S88 88@ 888 8 8 888S88S88 8t8 8 888 8 X888S88@ 8 S 888 888 S88S8 XX8 8 8 88888 8 88888 @8@8;8 8 8 X8 8 8 8S888:8S8S8 XXS88XSXS8 888 XSX 8 X88XS8%8SX@ 8 8:X@8 X88 88@S88888SS8 88 
@8%8 8 8XX8 XSX8X8@8XX8 @8 888 8 XS88@X 8 8 8:8X8 8 88S8;8S8@XX888X8 888 8 88S8 8 8%X88 X8 8 8 8888 88 XX8 S8 8S8@8 8S888@8%S8S8 8 8 88@:8%8 8 X8 X888S8 8SXSX @8S8 8S8@8S8 88@ 8 8 8S8 X 8 888 888:8X888 8S88XS8S@8%X88XS88S88@8 8 8 8:8 888 8S8 8X88 888%X 8 8S888 8%XS88 8 8 8SX8X888X8.8 8S@S@88%8SX8S@8
@X8 888 8 8888X 8 X 8S@8 8 88 8 8 8 @X8 8% 8 8 8S@X8 8 8X 8X8S8 8 88@X888S8 88 888.8X8 8 S888 @88 8S88XSS88%S8;8@8XS 8X8@8 8SS8X888X8S8 888 S @SX88S8 888 8S8 888 8888S@8888@8 8 888 8S@88 8S@SSS8 @@@@@88 8 88SS8SX8X8SS8 S8S8S88@888:888%8 888 8 8SX8S8 8 88@ X88 8 8 8 8SXS88 88S8%888SXSSX8S88 8 888S8 X
@XS8 8 888@8SSX8:8S@ 8S88.8 8 S8%S 8 X88.8S888@ 8 8 88XS8SS8 @88888SX8X@ 888SX8 8:8 8 S @%8XX8:XS8 8 SX8 88@ 8X88%8S8;888S@XX8@8:X8SX8XS8S@8S8;8SS8SX8 8 X 8 S 8 @@8 XX@88X8SXS8888 8 88S88X8 88888SSX8X@ 888SXX@X8 XSS888SSS8:8%8X88 XX8 X8 S8 888 8 SS8  8 8 8S8SXSS8888 8 8 S8 8 S8S@@8S8S8 8 8XS8SS8 S8 
@@88S88S8X8X8S8 X@8 8 8 8@8SS8 X8%888 88@ 8 88X8 888 8 X 8%@888S8 8 8 8%8@@@8 X8.@888 8 S8:8 8 8 S888S888 8:8X8 @8 8 8X888S88@@S8 S8X8S88@ XX88@8 X8S%S 8 88@ 8 8 XX8%8 S%8 8 8 8X@8 8SX8 88@8 88888 8 8S8 8%8 8S888 8 8XS8 8 8@8%8 88 8 88 888 88 8 8%88@SS88X8X88S8 8 X88 88@S8S8888@8 XX 8;XS8S8 88 88SS8
@@%8S@8@ 8SX 8 8X8S8X8S8S8 8888X 8t8%8.8 88XSXXS8 8SXS8 8 8 X@ 8%88@SSXXX8@@ @ 88 8X8888 88 8 88X8S8 @88.X 8 X88SS 888X8SS@X8S8@ 8 8 X8 8 8 8 @ S8 888X888 8 888 8 8 888S8 88888 8X@8 8 888%8 8.8X8 888 888 8 8 8X8@888@8 88 8X888X8 8S 8 8 8 S8 XXS S%88 8 X8%8X8 8:8 8X8 SS8 8 888 8 S8%8 S8 8%SS8SX8 888S
@8 8X8%8S888XSX8@ 8S@88X8 X88 XXS88 XX8t8 8 8 8 S888%888 S @S8 XS8SX8S888SX@8.8 8@@8 88 8 S888 8 8 X8S8@8 888%XSX8%88SXS8 8 %8X888XS8SS8.888X8:8 88 888 8SXX 8S8 S8 8 8 8 8S8@888 8SX8 8 @@8 888 8 8;8 8 8 8 888 8X8S8S888S8X@8S8%SS8:88XX%88X X8 88888S@8 8 XX 8 8%X8S8S888S88X8 8 X88 X888%S8 8 8 8 888S8X
@@8 8SX 8 S888X88@ 8S8X8.8X8 8 8%888SX@8 8 888%8 8888S8%8 888:8 88X SX 8S88SXX88X8X88 8 S888 S% 88@  8X888 8 8X8888 8@SSS8 8SS8 S8X8.8 88 88S 8 8 88X888 8 8 888 8888@%8 S 8 8X888 8 X8 8X8 8 8S888t8 888.888 8tXS8% S8S@ 8S8%@XS8 888 8X88S8 8 S8S8%X 8 88X8X8SSS88S8SX8 S8 8 888.88X @ SX88888SS 888 8X@%8
@XS888 8 8SX888 XX8;8 @ 8 8 S 88@X888X8 88@@@ 8 8X8X88 S8888 S88 8 8X8%S8 88SX 8888 88 8%%X 8 8 88S8 S8S8 8 8 8S8S88 8 8 SS8S8 8 8 8 X8 88:88 8 88S888@ 8 888S8 8t8 8 88@ 888 8X888 8 X8 8 8 8 8 8:8 888 8 8.X 8 8 8 888 8 8@8S8S88%8XX 8:8%8XX8 @S8 8 S8%8 888888%S8 8 S8 SS 8 @;XS8%8 8S8 X8X88X8S8 X 8S@S
@@8 8 888 888S88 8.@88 8 S 8 8 8 8X8@8XS88S8S8 88@ 8 X8X88@@S8.8X888@@8 8S@S8%888 8S88XX88XS 888 SS@8 X8%XS8S8:X 8%X8 888S888 8 888 8 S8 88 XS88 SXS@8%8 88888@X 8 8 8 8 8 8 X 8X8 8 8 X8 8888888.888%8 888 8 888 S88S888 8SXSS@8 8@S8%8 SS8X8 8 S8.88@ SS@8X8%S888SX8t8SX8 8 88;8 8.888 8S8 XX%8%X888 8 8 8
@XS8 8 8.8:XX8 8 S88X%8 8 88888 8.8X8SX8 8 8 X8 8 8 8 S8S88SX88 8%8S8%X8;8@8 8 XS8 8 88@888 8 8 8 8SS8 88888@XX8 S8 8%SX 8;8 8t8.8 88@ X8SX8 8 88@8888%88;8X888 888.888 888 8 8 8%8 8%8 X8S8%8X8 8 8;SXX 8 88@.8%88XX8S888 8 8X8.8 8 8 888S8@S888 X8%8 8 8 88888S8 8 S8 8 S 88S88 888%8 888S8 8SS8%8 SX8 XSS]]

--[[@@@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8@8
@888X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8X8
@@8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 
@XS8 8 @S8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
@@SXSX8%8@8SXXS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888S@SS88 8 888.
@@8S8%X8X8%@XX@8X8X8 8 8S8%8.XS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.8 8S8 SS8 8.X
@@XSX8 S8 @8 8 X@88@8 X 8 888S88@.XS8:8S@888X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8 888 8S88X 8%
@@X8:S8SS8SX888 8 8%X8S8 8%8 8S888S8S8 88SX8 888 8%888 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX88XS8 8 8 XX8SX
@@X@8%X8XX8S88 8 8X8 XX88 8 X 8S888@8 8 @8SSS 8 8 S88.8S8SS@8 8X8SX88 8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 8.8SX 888 8 888 
@@8SS8 88SX8%8S 8S888S8 SS8888X8S8@8 X88 @8 8 X888 8%S@8X88 88@8 8 888X8 8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 888 8S8 8 S 8 8.@
@@XXXS8SS8 @8 8 888 SXX8S888:8 S8X@@8S8@8%88.8 S8 888X8@8 @8 8S@88@ @8 S88888%8t8 888 S 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 8.8 8 888 8 888 888 88@ 888 8 
@@X8SX888 8 8 SS8XX88@8 888 X 8S@8X8 8S8 8 8X 8 88.8 8 8:8 8 X8 8X@8S88 @ 8 SS88 8 8:8%888 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 888 SS8 8 S 8 8 X @ 8 8 8 8 8X8
@@XX8 8 X8 88@ 8X8S@SSS8XX 8 8 8%X8SSX8SXX8 8 88S8X 8 8 SX888 SXX8SS8S@8.8 8 8 X8 888 8 8.S 8 8 888 8S@ 8 888 8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 8 8:888@8.8 888.8S8 SS8 888:8X8 
@@8SSS88 8 XX 8:8 8 8%8.8 8 888 8 X8S@@8S8X88@ S@88@X888S8S@ 8S888X8 8 8SSX 888 X XXS888 8 88@ 8 8S888 888 8SS8@ 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 X@8.88@8SX8 8;X%888S888 8 @X8 8
@@XXX@8X8 8 8 88X8S@8 8888 88@ S @%X8S8 8X888 8%8 8888S@8S8 8 888 8 X888888S88 8 8 8 88 X88 8 888 8 8 8 8 8 8S8.S 8%8:8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8S8SX88S888XX 8 8 8 8 8 8X8@8 8 
@@X8 88 XSS888S88X8%X888 X8 8.8S888S@8SSX8S888@8 888 X8X88 888X@88 8S8 8 X88@8%S888 8S888X 8 888S888 888 S 888.8S8 888 888@8:X 8@8 888S88X8SSXSS88S888 8@8 8%8@8S@S888 %88X8:X 8@8 888S88X8SS8 888 S 8;8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@8888888@ 8X8 888SSX8888@888888X8 8 X 8
@@8 8SX8S8 8SXXS8 S8%S888 88 888@8 8 X8S8 8X8X8@8S888 X8SX@@8 8S8SS 8:XX8%X8SX8 88 S 8 S88@X8.8 8 8 888 8 888 X8888 8 8X8S8 8S8 8 8X888S8 S888 @t.t;8;8XXSXX8S8%8S8X8t%8t8:X8@@@S88X@88S8 S8 S8.8@8S8SS@S88X@ 8 888 88888@8@8SXS88@8 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@8888%88888 SX88 8 8@8@8@@SXSX 8 8 
@XS8 8S88@8:8%8 8S8 88 XX8S88X888@%@8 XSSX 8 8X8 8S888 S8X8 888X 8 8 8 8 8SS8SS8SX888@8X%8X88SX888.8 8 888 8 8X8@8 8 8S8 8 8 88XS88@S88t88;888t8XX%XS8X8@8@888@8%8S@XX%S88S888888%8 88XX 8.S8 88@X 8t8 8 8 8 X 8 8 8 XS@88XSXXX8:@8@8 8:8 S888S8 8 8XX8 X8SX8X8S8 S8%8 8 8 8XX8 X8SX8X8S8 S8%8 8 8 8 88888X8
@@SS S8 8 8@88%8 X88S8@8XX8 8888S8S8 8 8S8S%XS8 X 8X888S@8 8S8X8 S8 888 8S8 S8SX8 X88@88 8 S8888XXSS888 8 X@8 8 8 8 8XX%8 888 XXS8 8888t8X888888@8888@8888@88@8888888888X88@888tS8@%8888@ 8 X8 X8S8 XS8:8 X88 888 X 8 8@8 8 8 888 8%X8 8 8%8 S@S8X8 8XX8S@8SX@X@@8 S8X8 888 8XX8S@8SX@X@@8 S8X8 888 8 8888@8
@@8888SS @X8%@88@S8@8SXX8 8 8 8 8 8 888:888S8 S8 8 8X8@8 8X 8 @@8 X8S8 88888 8S8 8%S88888 8 X8SX88S8SX88 8X8SXX8X888 8 8 888 8 8@%%888888X@88S@888SS88@X@88888888@S88S888@88X8X8X8@88888@X88XX8%X8;8S8S8 88X 8 8 8 88@ 8 888XSS8.8 8 X%S SS88S8%8S88 8SS8 XSX8 8 S8 88X@88 8 8 S@S8 8 8S8 8%8SX8S8 888 SS8X8
@@S%S8S8 S8 8 8S@8 8X8XSS88@ 8 8 888 8S8 8 X 8.88 S%8X@XXXX8 8X8@8 S8SSX8X8@8 888:8%X8X8:8%8 8 8 8X888X 8 8;8 8S8.XXS88 8 8 8@8%@%@88@SSSS8XSS8SS88X888S@8X8S8X@SS8XS8888@8SS88888888@8@8@888.X@XX8 88888S88@X88XS888@8 8X8@88 SSSS88 8 8%8 X8 888 SX8S8 8 8 8SS8 %8 8X8XX8X8:8 8 SS88X8 S 8 8 X888@X888X88S
@@X8XXXX@8X8@ S8 SX@8 8%8 8.888%S88 888 8;8%88@ S8S8 XXS8 888 8X@X8S8X8SX8X8 8 8;8 8 8 8@ 888 888S8 S8 888 XS88XXX8 8 S%S 8888@8888X88888XS88888S888S88@888S8X8S@S8S88X@SS8888888888888X8X88S8888@X S8888SS8X8:88@8@888XX8 8 8 888S8 8 888.8 888XS8S8;8 S 888 8S888X8@8 8X8888XS88S8%8SS8%8t8.8 8@8SS 888@8@
@@XX8@8SS8S8S8.S8 @ XXSS8 SS8SX8%8%S 8 X 888 8 8.X8888 8 8 8;8 8X8%@SS8 8 8 888 888 88XS8S 8 8 8 S 8S@8 8 8 88@8XS88.8 8S ;888XS@@S8SXX8888S88@X8S@SS8888SS88888X88888SS8888888X88S88@SSS88@@888@888 8 @S8 XSS888@8 8:8 8 8 888 88888 888 8 @%88@@ 888;8%8.8 88@ S8%88X888 @88S8XS8.8 8 SS88@8 8 XS8S8SX8@8 
@@8XX@%8SS8 S 8 S8;8 8S88@%888XX8 8S8 8 8 8 8 888@88888.X8888X8S@@8S8 SS 888X8 8%8 8 8 X 8 8 S888 8 8%X8.888S8 XS8.88 88@t8888SS888XS8X888S:8XX8X8S@X8S888S88XXS8888@X88888888X@@S@8X888888S88@S8888888SSS8%8 X8 8S@XXX8 8 8 8 8S8X8SS88 888:8 888@@8 X%88X 8 8 8 8 888X8 8 8:8 8S@8 88@S8%8SS888 888 8 8 @@
@@XXSSXX8S@8S88X S8 888 8 888 8X@8 888 888 888 8 8 8@@88S8X8@8%@8SSSX8 88@SXX 888 88@ 8 8 88X 88 888 8 888X X 8%8S8 888@@888@S888SXS8X888S8@S8888S8X88@S8S888SS88X@S888888X88@SS88888888X8X8SSSX@88S%88 8S8888SX8 8 8S8S@S S8 888 8 8X8 X 8 8 8 @8@8%X88888S%8 8 88XS8 @ 8 8 8 88@ @8 8 8S@SXS@8 8 8 8@8 8 8
@@XXX8X8 8SX888 8 X8 8 88XXX 8 8S@8 8 888 8 8 8 888 8 X 8;888%8SS8 8 S 8XS8S8SS8%8 8 S 888 8 8 88@8 888 8888S8 8X8 88888@@@88888@S8S888888S8SX888888888888SX8888@8SS8SXX8888XS888@SX8888X8888S@S8XSXX88%XX8.SS8 X8 8 X 8X8X8SS88 8 888 8 8 888 8 8 8@S%S8SX8 88 888 8:8S8 8S8X8 8 8 X8 8 8 8 8SS%88X8 8.X 8 
@@8X8 8;8 8S8 88888888888 8S8 8 8 X8;X@@SX%X 888;8 8 8 8 8X888S8 XS88%8 8 X8 8 8 888X88X8 8 8 8X8X88 8 @ X@888S8 S8t8888SSX88888S8888888XS88X8X;8@88@@@@XXXX8S@XX@8888888tt@88@@8888888X8SS888S88888X@8888@8%888%@8 8 8 8 8S8 8.X 8S888888888 8 888S8S8SX8XX8S8SX8SX 8 888:8S8SS 8 8 XSX8 888 8S8888%8;8 888
@@XSSS88 8 888@8 X8X8X8SX8 888 X88 S8S8 8%8 888 8 8t8:8;X 8@8@888S8 X88888X@8 8 88 888SX8XSSX8t888S8888@888 888 8S8X88@SS888S88S88@@S@88888 8@S@XXXXX@X@SXXSS8 8S8XS8SX@@XXS@88X8XX8@XSS8:888X8S8888888888tS8888888888 888 S88:8 888S8X8S8S8 888 8 8:S 8S@8SX8X8 8 8 888X%8 8 8S8 88@S8 XS8 X8X8 SX8 S8 8 8 
@@X8888X8X8S88S@8%X8 8 8 XS8SX8S8 8 XS8@@888 8 8 888XX 8%8 8X8S888@8S8 8XX8 X888 8 8X88 8 8 88@X8@8S8X8S8888@@ 8 XS8@88SX8@X8@S8888SS8S888XX8SXXXXXX8 8 8 @X8 8 XS8 8SXXXXX8SXSX88X8SS88888SSS88@XX@X8S888@8S8 8.88SX 8 8 8S8%SX8 8 8 8 8 8 8 8 8 S 8S8;8S@@XS888X88@SX@X8 888.X%8 8 8S888X8 88S8 8 8%SS888 
@@XSX8@X8%S8X@8XX8%@8 8;8 8 8 S88888 8X8S88.@88 888X8S88@ S 8 8X8@@@888 8XX8 88 888 8 8X@8 8 8 8X8@88S@X@8SXX8 88S8888S8@X8@88XS88888.@X88S8 @X8X8 8 8 8 8%8 X 8 8 8 8 8 8 X8 8S@SS@8X88S88S888XSS8S8X8S8S888S8 8S@88X8 888%S8S8SX 8 888 8 888S88@ 888 8@8 88X8X88@8 8 8 888SS88XSX8 S888X8 888 SSSS888 8SX8
@@8@8 8 888S8S@8SS8 XS88X888.8 @ 8X@8 @%8 88S888XX 8 8 8:8S8 XSXXX8@8X@8 8SX8SX8X@88 8S8 888SS8 8X8X@XSXX8 8S88t@8X8SSSX8SS88@8@S88X8@@XXSSS8SXXXS8 888 8 8 8 888 8tXS8 88XS88 8 8SX%X:@X8X888888888S8888888@8%X 8 X8%8888 8 S8S8 888 8 888 @ X@8 8 8 8 8.8 XSS8 8S%8XX8 S8 8 X8888S8%8 X8 X 8 8 88X888888 X
@@XSX8 8 S8 X8%88@S8 8 8 @ S8 88@ 8XX8 8 8SX8 8X88 XSSS88 88@X8 8 8 8X8 8 8 S8%X88X 8 8 8;8 8S888X 8 8S8 8SS8 St88888;88S888888S8XSX@XXXXXXS8 8S8S88@8 8%888S8 8S8 8888X88:8S@8 8 8 8%X8@8X8888XS88S88888S@88888 S8 888S8 S 8 8@ 8 8 8 8 8 X 8S8 8X8 888 8 8 8 8 X8X8S888 X8:8 X8 8 88:8S@8 8t@ 888 888X88XX
@@X8 8 88S88SX8 X8SX8S8 888 XS8 8 8X888 88@S88S8 8S8888X 8 8 888 8 8 X%888 8 888 8S8 888t88XX8X8 8 SXSSS8:8 S8S8@@X@@@88S88X@8888 XXX8 8%8 888 X 8X8X88@8S8 S%8 888 @8 8.8X 8%88888SS8%8 88S88S8S@S88888XS8X888X8 8 SS8S88%888S88S888:8X8%88%%8 8S88888 888 888 @SSXSS8S88 8@X8S@8 8%8X@8 8 88%X 8 8.88@SXSX
@@8 88@ XXSX8  8 8X8 S%8 8 8 88@ 8 8X888XX 8 @XS888 SX888X8 8X8888888%8 8 88@ @8XSS 88X%@%8X8.8@S 8%88X8 X@8 @@SSSS8@8@@8XS8X8@S8X8 8 8 888S8 8 8 888X8 @XS888@88@ 8S8888 8 S8S8S888 SSX8 88@S88S8S8X8XS8S8S8X@.S88@ 8;8 S8S8 8 8 8S88X8 8 88%S88@X8S8@888 8 8 8 8 8S8 8 X8 8S88XS8 8%8 8 S8 S88SS8S8 8 8 8 
@XS8 8 8 888@8 8 X8t8 8;S 88@S8 888 8S8@88 X8 8 8SX8X8S8%888.8X8S8SX 8 8 8 8.8XX8 8 X8 8S8 88@@888S8 8%S8S8:::SS8X8888888t8@@S88SSS8 8t8 8.X8 S888X@S8 8S8S%8 888 8 8SS8 8 8 S8 8S888 8 8S@S8X8S888@X888888888X8 8%88;8 8S8 S8 8 88@ XSS88@ X8SX8 8@8S8X888 S 888 888 S 888SX8 @8XS88@ 88@ 8S8.88 S888 8 888
@@SSX8888X8@8 88X 8@S888S8S8 8X8S8 8 88XSS88 8 888XS8X8888%88@8 8 8S888t8X8 8%8 SX88 SSX888X8 8 S8 SSS8 S8 Xt888X88888@8S8XS88;%XX88XSS8888XS@8 @S8 8 8%8%8 SS 8 888 8SX888:8SS8 8XX 8 8 8S8t8S8S:S@@XXXStSSXX;88@8 SSS888 8 XSS 8 X888@8SX8 888SX8%SXX@@@88 8 8 8 8 8 8 8 8 S8 8 8 8 8 8 8888XS88X88@8 SX8.
@@88888S8XSX88 8 8S8 SXS8;8 88XXXX88@X@8 888SS 88@8 X8@88S888@S8 8 8 8;88@S8%8%8%8 8S8888%8 88@8SS8S88@8 8%888@S88888X88SS8@S88XX8.@88 8 8S8 888XSX8X8S8S8 8 8 X888 S 8%88 8S8 X8 8S888 S 8X8@S8SXS8%@SX@SXS8SXX8SS8 8 88 88@S8 88@X@XX@@8 88.888 S8 8%X8X8 888 S%888 888:XX88 888 888 888 8 X88%XXSXX@8S8S@
@@S%S888%XX8S@8 8 X888X8 888SX8%8S88 8S8888 8 888XX8 88S@X 8.8%S S88@;8 8 888 8@8;888 8SS8X8S8 @8 S8S8 88 888@888X8SSX8888888SX8 @8 88@:8 888S888X8S8 8@8 S 888S8 XX8SS8SX8S8X8S88t8 8 8 8 8X8SX8 8 8%@XSXXXS8 8 8  88@S@8 8.S 88@ 8S8 8 X8 88X@ @S88%8 8 8888 8 8%8 8 8 8S8 8 8S8 X8 S @ 8 888SX8XXX8S@8 8 
@@X888S88SSS8S@8 8 S888%8S8%8 %8S@SS8 8S8 8 SS88S8X@8 X8%8%8@ 8 8 8%SS8 8%%8 8SX88X8 8X8%8XS8S8 8S8:XX8S88 88XX88S88S888S8SX8;SS8SX88888X8X8 8S8 8@8 8S8:8S8 8 @ 8 S 8 88XX8S888 8X 8 SX88@88SXSS8 8 8 8 XX8 8SX8X8 X8 8%88@8S8 8:XS88X@88 @ X8S8 8 8X8 888S%8S 888 888 S 8:SS88@ 8 S8S8t888 8S8 88S8 8 S8 8
@@XSSX8 88SSS8 88X888@S8@8 8t8 SX8 888 8 8 8 8%8X88S@8S8@ 8X@S@8.888%888 8 S8X8 8X8X8X8@8X8SX8XS 8;8 8 8 88S8SX@S8XS8@888S8S88SXXX8%X8X8SS8S@@SS8S@X8 8;8 888 8 8 8 88@ @8SSS8SX8X8S 8S8 8@8 8%8 8 S8 8 8 8 888 @ S888 %8X8SX8;888S8%8 8:8 S8%X8t8 8S8 88@X8 X8 8S88%8 8 888S888@8:8% 888%8 S 8 8 SX%8 8 X8 
@@8XXSX8%X8XSX8X8 X 88X88X@88@888S8S8SS 88888 8S8SX8SS8S8 S888X 8 8 X 8 88@S8SS8 8%8 8X8S@S8@8X8 S8 8 888S888888X88888S@S888S8XXX8:8 SSS@8X8S88%S88@@8.@XS8SS S88888@8 8%X8 8 8 S888S@8 8 X%8 8 88@ X8 S 888 8 88@ X8 8 88@8S88XX 8@888 8 8 S8 8@@8:888%8 @ 8 XSX8 8@88@888 888888X@8 XX%8 8 8 888SX888 8 X8
@@X8 8 88@X8@8 X 8 @ XXSX88@8 8.8 S8X8 8 8 8 888 8S@8SS8X8XXSSX88@ 8 8 8 8 8 8 S8 8 888X8S8X8 XX8 S8 88S 8@8SX88XS8888S888X888@8 8 X8 8 S8 S8 888 888S8 8%S888%88888XSX8S8 888 8S8 X8X88X8 888 88X 8 X8 88@ 8 8 8 8 S8S8%8S@8 88S8 8X8888888 S8S8 8X%8 8 8 8 8 @ S8%8X8S%X88.8 8 8@888 8 S8888@ 8 8 X8 S 8 X
@8 8 S8 88%SSS8 888 8S8 8 8 88 888S8 SS888888 8 X 8S@8X8 S8%8 8 XX8.8 XX88@X X8 X8 888S8 8X888@X88 X8S8S88888S@8888X8S888888@8@8XS8 S X8 8X8 8 888@8 @8 S8 8X8X888SX8 8 8;XS8 888 8 %8S8S88 8 8 8 X 8 S8X8 8888@ 88@ S8 8 8 88 8 8SS8S8888S@8 SX@8S8 S8 8 888 88@ SSS8S8S8 8X 8 8%@S 88S8 88@8 8 88XS888888S
@@8 888S@%XX8 %888888@@8 8 8S88XXS8 8 8 8@88X@ 8 8 8S@8%8 8 SS88%8S8 8 8 888SXX8S88S888 X 8X888S8 8S88S8 8X8SS88S@S88888SS888@@@8 X888S88.888X8 88SS8SS888 @88S8888 X888%8 8 8 8 X88 X8 8 8@@88888%888S8 8 X8 8 8 8 8 X8 S 8SX@X8:8 SXXX%@8S88S8 SS88 XSS 88S8 8 88@ 8@8888%8%88.8S88X8S8888 88X8 8.8 888X8@
@XX8 @ 8 8 888 8888X8@8%S8888 X8 8 88X88 8.@88 S888@8SXXS88@S8 X8S8;X8888X@ 8%8 8 8X8 X88S 8X888SS 8.88S8@888888S8SSX888@X8S8S8XS8 88@S8 8S8@8X8SX8XX88X8%8 S8%88SX8S8 SXS88888 8 888SS8 8X8S8X8S88@8 8 88@ SX8 %8 88@ X8 8 8%8 8XX8 8S8S8 8 XXX8 8 X8 88SS8 SS8888 8S8 8888 8 8@8888 S8S88 8S8%888888 88XSX
@@8;888 888 8 8 @8 8 8;8 8S888 X8X8;8X8 8 8SXS8 @ @ S8%8 8SS8 8 @X88 888S8 8.888 8 8 8 8;8 X8X8 8 888 S8S8S8888888S88888888X8888XS8S8 8SSX8%8S8 8 @8 888 X 8 X8%X8S@888S8 88%8 S 8%8.8SXX8888 8 8S8%88@88888 88@ 88 8 8 SS88SSS8S8 8 S8 88888%8 SS 8 S8 8 88@ 8 8%8X%888X8 XS88S8S8 @8 SXS88% XX8888X88 X88@
@@@X%8 8 8 8 888SS8 8 888 8X@ 8S8 @8 8 888888 88X8 8 8%88;8 X88@X8 88X8SX%8.888 888 888 8%8 888SX88X 8 S8SS88888@S888X8SS88888888SX%8 S8S8.XS8 X 8 8S8 XS88 8 S8 8X8S@X8S8 XS8 8 88 X@8X8X8S8@ 8 8 8S8 X8X8SXS8.8 S888 8S8 8S88XSX8 8S88@8X@ 8:8 8 X8 X888 8 88@.8 8%SS8@S8S8S 8 @@8 X8 8X8%8S8 %X 8 8 8 XX@
@8 8 S8 888S888 8 8% @X888@S@8:888 XSS8S8X8X88:8%88@SS8%8X@8S88 8X8 888@SXX8X8 8 8 8t8 888 8 X8X8 SXS88 88@8XXXSS.8@SSS8@888888@8S8 888S888S8X888S8:S 8 8 8@88SS888 8X8 @X8S888 8 S8X8 8 @88S88SXS88888 SXX8SX 8 8%8 S888 888 8S@88888S8888XX 8 888 8X8 8 8 S%8;8 88X88 8 8 S8 S8X8@8 SS 8@8S888S8%S8 888S8 
@@8 8 X8 8:8 8 8 88@%S8S8S88SX8%8 8S88@ XX@XS@8 8S8 8 88@8SX8 X8SS%8SX@8S8SX8S888 S 8 8t8 8%8 XSS8 8 8S8 88%888S888SS88888X88888888t X8S8SX8X8 888S8 8 88X88 88%8SX8 8 8XS8888 88@ S88S888X%8 88888%8SX8 8SS8 888 S88 XXS8 8 8 8:88SX 8S8 X8%888 8 888 8t8;8%8SSS8 8 SS8 88@:%@8S8X888 8%X8 8S@ 8:8 8 @8 8 8
@XS@ 8 X8;8 8;888S8 8%@88@%X8 8 88:888 8S8 8X8 8 888:8SX@S8S@8%X88S88@@ 8 8SSS8SX888X%88 888%8 8 8888 8X8SXS8888X8SSS8@SSS8888@@88S88XXXS8SS8X8 X8 %88888 XS8%SX%8S@8 S 8S8X888 8 8 S8S8 8 8 8 X8XX8 8SX8 8 S%88X8%8 8 8 88:888S8 8 8 S8 8 8 8XX8 X88 888 888:8 888 8 88@X@@8SS8 X8X888:8 888@8 X8 8 8 SS8  
@@8SX 8 S888 8 8.XX S8 S@S8 8%X8S88S888.8X8.@XS88 8 8S8%8 88%S8 888XSX@8 8SX8%%888X8888X8@XS@X8:8 8 88X8 8S8SX8XS88888S8S@8X8SS8S88@@S88S@88@@@8 S888 8XX8X8SXXX8%8S@8 8:8 8X8S@8 S8 8 8888 8S8 8SX 8 8 SS88S8 8SS8S@8 %8 88X8 8 88@.8 @8 8 8:8 888 X8@8 8%8 X8888S%S8.8%8S8 8SS@SS8X8 X88XX8S@8 X8 888S88@S
@@XX8888 X@S888:8S888X8SSSS888S88SS8S8@8S@88S8 8S8@8X8@8X8 8@ 888SSS8 8S8 8 888X@SSSS8@8X8888S8X 8t8SSXSX 8X8888X88@@888888SS8S8@8888S888@88@8888 %X 8 8SX8X8@S888 8 S888 8 X 8S88888X8S8S88.8X8 8S888 8 8 XX88X8SS8 X8 88 X8 8 8 8 8 8 @8 888 8:@8X8S@ 8 8 8 8X@S8888%X8 8;X888 8 8 @8 8S8 X8SS8%X8S8 @88 8
@@X8.8 S8 8 8XX8.8:88SX8 888 X@8 8  8X8XS8 SX 8 8S888@8S8S8S8SS8 8 8 888 88X X8SXX8888SS8 S@8888 S8 8 8S8XX8SS8%8S8%8X888@S8@8@SSX8S8S@S@888888888 .8@XX8SS8S8 8 S S8 X8 X 8 8 8 8@@88S8%8 88S8S888 8:XS8:8S8%8 88XS8888X@8 X88888XSS8S8 X X8 88XS8 888S8888X8 8 8.SS8X8;88888SX@8%S8S8888 888X8 8 8%S88X 8 
@@SSSX8 S888 8S8@XXS8 8 888 8 88%S8 X8%8  @S8S888X8 X@XXX8@888S88.888 8SS @.8XSXX8 8888%X8S8 8 8 8:S888@@8 @X8S888X8X88@S8S88S888888@SSS8XS@@88@%SXS8888S888.S@ 8 888X8 8 888 8 8%8 888X@@8S8@ 8S8 8 8 8 88888 8 88 X8S8@8 8 888888X8%S88S8 SX8XX8 8 %8X8888@888@X88X888X 8S8@88 888@X88S 8 8 8 8;8:8 @8XS 8
@@888XX8 X8 8;8%8 8SS8X8%8 888 8X88XSSSS8SS8 8 X8 S88SS@8S8@8 8 X8S888@8 8 8S8 8 88 8SX8SS8S@XS88;8 @ 88888 8 8 888S8@88888888888X88X8@:8888888X88888888XS@8S888;t88 88888 8;8@8;8 8SX@888 888888888888 8S8 8X888S@8 88@8 S 888 8 S@88S8 8 8 88@S@88@ XS 8 8 8.8%8 8S888S8 @S8 88 88S8;@8%S%88SS88 X88 @8%8 
@@S 88 X88 888 8 8 8 @ S8 8X8@8 8;XX88X888 8S @ S8XXSX8 888X88@8S%8X8X8 88@XX 8 8S88%@SS8SX8S8 8SXS8:8S@XX88 8 8S@X888@X888@XS888888SS8@X@XX88XSSSS8@X888X88@8888X88@tX8%@8S8SX8X%88888888888S888888@8888@888888X8X88 8SS8S8t8SSX8X8 X@88 S 8 8 8 88 8 8 88@8 8@8SXXXSSSS%8 8 8 88%SSS8 8 8 8S8%8%8X8 8%X88S
@@@8 88XS8 SXS888 888 8 S8:X%8 888 8 8 S8S8:8XS8:S8SX8S8S8 8S8SX8XSXS8%S88 8X888 8 8@S8 8X8 @@8;8 8 X8@ 8@88XX8 8XX8S@S:@@88S@88@88X88XS88888@8888S8888@S88S@8X@X@88X@X@:.8@@8 88X8888888888X8888888888%8888%@8888888888@SX88S8S@@8 8%8S@8S888 X88 @8 888S8S88XX 8S8SXX8 888 8 8 88 8 8%88 8.S 8;XS8 888 X@8
@@X@8SX8 88 8 8 8.X8 88@ @8 8 8 8 888 8 S888 8%88SS8SSX 8 8 8 8%X8 8 X8X8 8 8 8 888S8 X888 8X8 XS88XS8%888 @8X88 8S@S88@XX@88@@XX8X;88888@88S88XX8888S8XX8S888@S8888@S8@XXX8SX8 8 8S88@888888888888888@8888@888888888888X8@88 XX@8@8@8 8SXS88 8 X88 88%@X8%8 88X8 8 8 888 8 888 8SX88@8@%8XS88XX88888XX @S8X
@@8XX8 8S88SX8.888XX8 8 8 SX8 X8;XS8%88XS88 X8888X88@8%88S%8S8 8SSS @ SS88@888:@@@8S 8%8 S8 8 8 8 8 X 8X8 8.S8%X8 8 8S@88888XSS888X888S88@@X8888@S8888S8888888S8S8X @@@8SXSS8S@88@ @ 8S8@8@888X88888X8888X8888@88888888@8888888XS@@X@88 8 8 S8 8 S88%888@ 8 8 8@88 8X8S8 8 8 8S88@S88%8S8 8 888X 8 8:8 8 8 8
@@XXSS888 @8 8XXXS8S88 8 8%88@ S8 8 8 8 8 888888@8888S88888X8888888 S8888SSX8 8 8.@88:888 XS888 8% 8 8 8 @88 S@SS8X8 8S@X@8t8888@8888SX888888X@SS888@X8S888@8888@@X@XSXSXX8 8X8S8@8 8 88S88@S%888@888888@888@8888888888888888888888@8SX8 8 8SX888%XX8%X8 8 8 8X8 88S8%X@888X8 8 8.8 8@ 8 8:8SX8 8;8.888 SS8 
@@XXX88@ 8.X8X8 8S@8XX8 888 8 8 S8 8888888888888888888888X888888888888S8 @8XXX 8 8SX@8X@ 8S8 8 88@SS888 8S888 8S8S8S@@SXXX8SX@8S8X88SS8XS8888XS8@88SSS@@S8X%:@SSX8SSXX8 8S88;8 8%8 8 8%8S8 @8 8 88888@88888888@8@8@8@8@88888X88888888XX88 88@%88 8X8SXSXX8 88%X@8S88 8X8S88XX8 888 8X8 888@88 8 %8 8X888 8;8
@@8XX%X8 S8 SX@8:8 8 8 88@ 8 88@ X888X88888888888888888888888888888888888X8@8 888 888SX8 SS88888 8S8SX 8 8X8@888X888@8@S8%8S@SSX88tS88@88888SSS888S8S8X88@8@88 8%XSXXSS8:8 8XXX 8 888 8 8 8 8SX88@@@888@8@888.@@888@8888888888888888888 SS8 X8 8X 8X88S8 888X8S@X8SX8 8 8%@8%888S8 SS88S8@8 X8X8%S%X8S8SX 8 
@@XX8S8 8 S8S8 S8 88@ S 8 888 8 X8X8888888888888888X888888888888888888888888@8X8 S 8S8%8888X8X88S 888X888 8X8S88@8SXXXSSX8 8 8S8@8S8X@88.%8888888888%@%8@X@88 8 8 8 8 88X 8%8S8S 8 8 8 S 8 8 8 8 XXXX8@X88@88888888@8888888@8@88888888@@8S888 @S8SS8 @@ 88@@8 8S8@8S8888;8 888 SS8888SS8%888 88X8S8 X8 8 8 @
@@X8.8 S 888 S8 @8 8 8 8 8 8 8888X8888888888X888888888888X888888888888X88888888S88 XXX8 S888XXX88@@@8 8%S8 8 8 8888 8 8 8 8XS@8 8 8 8S8SX@S@888@S@8t8@@SXXXSS@ 8 8t8:8 8 8 8 X 8 S8 88@ 8 S 888 8 8 8 XXSS@8@88@88888.@88@8888888@88888888@%8 S8 8S88S8 XX 8 S 8X888S88 XX888 8 888SS8SX8X8@8 8SSX@8S88@@X8 
@@XX8 888 8 8:88 XS8 S88888 88888888888X888@8888888@8@8888888888@8@888888888X888888@8SX8 8 88S8.8 8S8888 8%X8 8X8@@8 888;8%8S8 8 8 8 X 8%8%88X@X88888@8X@XX8 8 88X88SSSXS8888%8:8 8@ 8 8 8@@@%8t8%8X8@;@;8 8t 88888888888@888.888@8@88888S8888 X8;8 X8 8 8%%8%8 8X@X8 @8 8 8 888 8 8 8 8 8X888@8 @ S8S8@8 8S
@@8S%X88X8 SX8888S88@ X8 88888X8SXS@@X@8S88XX@@X 8@8888@88888@8@8@88@888@888888S888S888 8.8%X@SX 8 8S8X@88XS88%@@XS%8 8:X8@888S8@ X 8 8 8 8S@8X88888888888888 8 8 S8X8 8S8@88888888t88%88X8X@X@X@X8XS8@S@X88@888S@X@@XX@888888888888@8X88888888%8X 8 8 8888 8  8 X8SS8 XS88888 8 8 8 S8 X 8X8X888;8 88XXX8.8
@@XX888S8 8%8 8SSS@8 8 X@8@8 XSXXX8 8 8 8S8@SXX8SXXX8S8888 @8888X8888X888@8888@88888888S88S8 8 8 888@88 8SX8 88SSX8 8 88%8X8 88888 888.8X8 8S88888@8@88888888S888888S88.8S8@88888@@X8@@888X88XXSS@S@8XX@@@8@@88@@SXXXXXXX@@X@88888@8@88@888X888XXX888X8 8 SXS8 S8 X8%X8 8 @ 8 888 888 X8 8 8X@@@@8 8 @8 8 8X
@@X8 X8@X88X 8 8 8SX8 @S@XSS8S88@8 S 8 X%8SSXXSS8 8 @88 8@@888@@888888@88@8888888@8888@888888S88XX8S8%8SS8 8S8S8 8 888 S8@8 888SS88 8 8S8 8X8888@8@88 @88888@88888888888 @88t8%8S88XX@@@SS888888888888S8888S8@88@@SXXXX8 8XXS8S8@8888@8@88888888@8.8 8.8t8S88888 8S88X%8:8 888 8 8 8 8 8 8X8SXX8%@8%8SSS88X8
@@SS88@8@8 8 88X8 8 8X@8 8S8 XS8 S88SS8S8SXX8 8 S8@8S8%@SX8@@X@@8888@888 @88@8@88888@88888888S8@8XXS88 8S88;8X888 8 @@X8XX 8S8%8S8 8 888S888888888@888888888888888888SXX8 8 @888:%888888S8XX8S8S8S8S888888S8X888@8XX8 8 8 8%8 8 8S8X88@8@88@888888SS8 X88@8 8 S8X88 88 %8 SS8 8 888 X 888 8 8 8 8 S8 8 8 8S8
@@8SXXXS88@X8X8%88:8X8 XS@88888 8SX88 S8@S8SS88@S8 X8X8 8SXXSXS@@@888@8@8888@88@888888@88888@8888888XX8:8 8X 8X888X8S8%X8S8 8 8 8%X88X888888X888888 88@8@8888888888 XXXSX8 8X@8S@SS@:@8X;8SS888XS8888X8@S88X8SS888@SS888 8 8 8@8 8 8S@X888888888888X 8S8@8%@@8S8%@X8 X8 88 8.S8888 8%8:8 8t8 8 8 8 X8 888 8 
@@XX8 8 S8X8 X 8 8@ 8%8 8S8 S@888@ @88X8%X888 8 X 8S8SS8 8 8S88 88@8@88888@88@8@@@8@88888888888X88888888 8S8 S8X8X@X8 8 8 8X88888888@888888@88@88@888 8888@8@88@@SS8S8 8S8888 8 8 8 8X8.%88888888888S8XS;88888X8@88XS8888S8%8X8 8 8 8 8 8888@8@88888X 8 @ 8X8%XX8@8 8 X8 8 S888 8SS88888 S888 888 8 S 8XXS 8
@@X8SS @%X88S88 8 8% 888 8:8%8@8S@8S8.8 8 8SX8 8 8 8@8 XSSSX8%@8S88 88XX888888@88@88@88 @8888888888888888@88888@888SX88888888X8X@8888888888888@8@8@8888888@8@XXXXXSX%8 S8%8X@8 8%8 8 8 8SX8;888@@X888X8X8XXS88888888 SX8S8 8:8 8.8SXX8X8%8@8888888888X 8 8 @88S8 8XS88 8%S8 S888 8X8X8 8 8:8 888 888X888S8SS
@@XS8%888 X88S8XS888 8 8  8 8 8 8 SSS8S8;8 8 X8t88@X8 8 8S8 S8 8 8 8SXXXXS@8@8@88@888888888@888888888888888888888X@888888@@888S8888888888888X888@888@88@8SXXXX@XX8 8S888XX@8 XS88XS88 8 8SXX@S8SS8888X888@88X88888888X8SX%888%XSX88X8S8 8 @@@X88@88888X 8888SSX@8@8 8S8 888S8S@88 8 8 888 8 8888 X8 8 8 X%8X
@@8SSX88 8X8 8S8 88 8 88@S%888 8 8 8 8 X8 S 8 S8 8 8:XS888 8 8 X8 8 8S8@S8 8X88@88888X88888@88888888888888888X8888888X8888888@88888888888888888X88888888SXXX8 8%8 888 88S8XX8 8 8 8 XXX8X8 8 888SX88888S@88888@8XS888 888%88.8S8 8 8@8 X 8SSXS@88888888888 8888%X888:SS8 @ 88@X8SX8 8 88 888:8 X8 S888 8 8 X
@@XX8S8SXS88SXXS8SX888 8 8 8SX8 S 888 8 X8 88X @8 8 8 8 8 X88.8 XSSSX8X@SX@8SX8X@8@8@888@888888888@8@88@88888888888S@888888X8888X88@88@888 @88.@8888@XXSXX8 8SSSSS88 @S@8.8 SS 8 8 8%8%8SX8 8S@888S8888X8SS88888S8SS8X@8@8 8@@X 8 8S8.8S8 8S8@S8X888888888X8X 8X8SX@8 8 888 8 8%@SSS88 XS8S88XX 88S8S8 8888X
@@X8 8SX8 888X8 S8 88X8 888 8 X8S888 88@ SSS8.8 XSS888%8X8S@@8 8 8888S88%8S@8 XX88888.8888@8X8.8@8@88 888@8@88888888888888@888S888@8@888.888@8888@XXXXX8 8 888S8888S@@8 8X 8 8 8@ 888 888 XSXSX@@8X8X8S88888888S888X88XXX@8X8%8S8888 88@ S 888X8XS88888@888S8S88XX8SS8 8 8 8 X 8 8%@ X8S88@S8S8 8S88888S8X8S
@@SS8 8S88X@SX%8 SX@8 XS8 X%S8 SXX8888%@@8SX8888S8S8 %8X8 8SS%888 S%8S8 8:8 8X8 88XX@S888@888888888@88888@88@8@8888888@88X88888888@88888888@88@X@XX@XSSS8 8S8 888:888XS8S8 X888 S888 8S8 8S8 8 8 8@8SS888XXX88S88XXX88 8S8@8@888%8S8@8XX8S8%8X8S@X@888888 @X@8 @8 88XS@88X8t8S8 888 888 SXS8S 8SS8S8X888 8 X
@@88 8 8 S8 8 8.8 8 S8 888S888%888S8 8X8 S8S8X88888@8 SX88 8 888 88888 XS8 8 8 8 XXXS8@S8888@@88@88@888 88@8@88@888 X88888888888@888@8X88888S8SXX8SS8 8 888 88%@X8 8.8 SSX8 S@@8 88X8 8 8;S 88@ @ 8888SX88888888@SS88;% 8@8S8X8@8 8S@@8 888 XXX8%8%XX@8888@@@X8 X8%X8X888X@8 S 8 8 8 8 8 8 88SS8SS8%8X8 8 8S
@@SSX888%8 8 S 888 888%S8 8 8 8 X8X88 888 S8%8X8X88XX8 8 SS888XX8t8@8@8 8 X 888 8 8 8 8 8S8X88.888888@8888@88@8@8.888888@8888@8X8@@88888@XSS8 88%88%X8 8 8 8 8@S8 8 X 8S8 S8S8 S8%8 X8 888X8 8 8 88@S8t88X8@@@@8888X88SX 8 @S8X@88 8X8 8 8 8 8XXS@8 XX8888@8S8 8SX8 8 8 88  8 888.888SS 888 XX8 8 SSXX@8 XSX
@@X8SS8 888X8S8S8 8 8 @SX888 88@ SXX@8S@@8 8X88;8 X8SX8:8 8 8 8 8X 8X888 8 888 S 8 8 S 8 X 8S@S8888888X8@88888@888@88@8.88888@88888888@XXX8 @8 @8888 X88@ X 8S8 88 8%8:S 8.X888S8SS8 XS8S8 8SXX 8 88@X@88@888S88XXS8S8X88:88 @8S@88 8 X88 8 8 8 8 S@8 88X8@S8 8 8SS8X8 8 888 888XSS8 8888@ 8 88@@8 8 8 XX88X
@@8.8 S8X8X8%@88@8 88@.8 8SX8 8.8%8S8 8S8 8S8 @X 8 8XX 8 888.8X8S8XX8X@@888@8 8 888 8 8 8S8 8@SX@X8888@88@8888@8888@888888@8X888888XXSXX@SS8 88S8@8 8%8 S8 888 8S8X@8 8S888S8 X8X8 S8S888 8S8%8%8X8SSSX8S88@888@S88@@8XS88S8@8 8S888X8%8 XSXX8 8;8 8 8XX8@8SSX 8 8 @ X8 8888SS8 8 8:888.8 8 8S8SSS8 8:8 8 X8
@XXXS8 SX@8%8X8S8 8%8 888 8 8S 8 888.SS8SXS S8 8 8 X88XS8888@8 X8 8S@8S8X88888S8X8 888X8 88@X8@SXXXX8X@888888 888@888.@8888888@X8X8@SXXXS8 8X8S8 8 8 X88 S%88 88@S8%888X88 8.8 8XX8 X888 888 X88@8X@88888XS8888888@88%S@S8@ 8 XX8S8S8 8 8 8S888 8 8 8 8 X8 8888XX888888888 X8@8@@8:X8XX8S8 88X 8%88@ 8 888 8
@@88S@888%X8XSS8;888 8 8;8 88@S 8 8:8 888S88S8%S8:8 X88888 8 88S%SX8 XSSS 8X8%X8 8SS8S@88 8 8%8%XX8 XS%S888.88888888@8888.@XX8SSX8SX8 8S@S8:8X888@XS8%8 8%8 X8@8 @ 8S8X8 X8 S88;8 X8%8 S8 8 8S8 @ 888S88S8S888@X@888@%X@8S8SS88X%@SX%8 S 888 8 888 888 8 8XXSX8X8 8 X8X8SS8 888@8;8 S8 8 X8 XX8 8 XX88@%8 8 
@@SX8%8888X8S8 8XS8 888 888SX 8 X8SS8 S8%8S8 S8 8X @8 8 8 888 88S8SX8 8S8SX@ 8 S8.8 X88X 8 X8XS8 8 8 SS888S888@8X8888@X8X88SXSXXSS8 8 S888 888@8@8S88@@8:888S8 SX8 SX@XS8SS8 88X 8:S8:8 8 S8:8 8S8 @88@@88888S8S88@@@8S8SX 8 @8S8 8XX%8 8 8:XS8 @ 88X 8 8 8 8.X8 8;8SSS%8%X8 X 8 8;88SS 8 S88XSS88S8 XX8 S 8
@@XX@8%8 8 8@88S8SS8 @ 8 8:X88 8 S8 S8% @X888 S8 8 88XS8 8 8 @%S8 8 S SS88X8S%88 888 X8 88@ 8SXS888 8%X%8888@8@8X8888888888SXXX8 8 888S@%8%8 X@@XS8 8S8 8S8@888S8 8 8S8  8 888 8% 8 @8 8 8 88 888 8X@SS88888X88X88X8888XX88 8 XXS8 8 888 888S8 8:8 8 888 8 888XX8SXX8 8 S8 S8S8 8 X888 888S8S8 8 SX88S8 8S8 
@@8@8 8 8 8X8 @X%8S8888SS88S@8S 8 S8888@@8S888 88S8SX8S@8 S 88@ X888 8S8 XX@8 X8S8 S8 8 X8.X8@8 8SS8 8  t@X8X8X@@8X@S888@888X8 8S 8 8 8SSS8 8 8 8 %8:888@8S8S888@@8@ XS8 8888 8 8%S@ @8 888 SS88X8.888S8888X8XXX8888888%8 8X 8%8SS888 88@8 SS888@XX8 S8 888 8 8 X888@8%88@8%X8 88@ 8X@8 8 8X8X8%8S8 S8S8SX88
@@S8.888SSX8 8 8%X8888888SS8 8%888 X8 8@8%S8XX8;8 88XS8SX8 8 8 8 88 888 8 8XS8 X888 X888 SXS88SX 8S888S 8888SSS88XS8888888XX8S8 8 S8SXS888S888 8 8 88@8X8 8@8S8X8%8 8%88888XX8 S 88S8 @8 8 8 888X8@8X8888XSS88888S88%X@ 8S8%8 888 8S88 8SS8 8 8@8 888 88%8 8 8 8 S8@8%S88 X8 S%88S@@X888@8@8X8%S88@8S8 S8 8X
@@SS8S8 8S8SX8 S8 X @XX@888@8 X88 8 X8 XXXXS8SSX @SX8 888S8 888 8S@8 8:@X8 8 S8 8 S8 88 8 8 888 8:8 888 St8X888888t8S88888888X 88@ X8S8 X888XS@8888 X@%8 8@8@XXXXX@8 8 8 SX8S@8 888SS8XX88@88 8 8:888S88XS888SSX88@@.SX8;8X8 8 8 88@XX8 8 SS 8 S 8 @X88 8 888 S 8 X8%@8X 8 S8 8 SXXS8X8X8 @XX@8 8S8%@@8 SX%8
@@88S8 8 8;8 8 S 8 @X8S8 @8 XSX88XX8S@8 8 8 S8888 8 88 8888888.X 8S88 8 8 8;8 88.8 88 88@88@S8 8 S88@8 @ 8St8@S@888888XSX888X8@X8 8 S8 88 XS8@8@8SS8S8 8888S8X8 8X8 8 88@ 8 8 S%88 8 8%8S8X888:888888888S.@XS8S88@@8@X8%8S8 888 8 8 8 X888 8 S8S888SXS8 S8 8 8 888 S@8S8SS8 88S8%8 8 XS8 8X8X8 8 8:8X8 8 8 X
@@SSXX8 S 8 88@88888X 8S8 8 8 8:8 8 8 SX8 S8 8 X8%X8 X8S8X8S@X8 88@ 8@888SS888S8@X8 88X8S88%X 8 8 8 8 8 8@88SSS8XS@88888888@8888X%@8S%888X8 @8%X 8 S8S8X8X88S@%8 8 888 8 888 8 8 SSXSX8 XS8X@X88888XX888S88888SS888;S8 @XSS8.8 S 8 S @8S8 88@ XS@8 8 88@ XS8888S8 8S@S8 8S88S8X888SX8 8 S 8 8 8 S 8 8 88888 
@@X8S8 8 888 8 8888@S888 888 888 8 88@%88@ SS8 888 S8%X8SXS8S8 8 8 8S8 S8S8.@X8X8 S8SS888 8@X8 888 X@8%@XS88S8888S8S@XS888S8@88888 88SX8S8 8 X8S8.8 88S8S8SSSSS888SX8 888 8 S 888 8 @ X8 8 8 88X88SSX88@S8SX8888888XSS8XXX88SX8%888 888 8 X8 8 @ SS8 S8 8 888 8%X8:8 8 X@8 X8S8 88S88XS888888@X88XS88@X8X888
@@8 8 S 88@ X 8:8X@%8X@ 8 8 88@ S 8 8 X88S88888 8S8 S8 888 SSSXX88S8@S8SS8 888S%X88 8@8 8S8%8 8;X 8X8%@XX8Xt@S88S8X8S8S888@8S@8888: X8SSSSS88S@8t888S8 S@SXX8 8 X8X8SS @ 8 8 8 8 8 88X SX8 S:t@8@SSS8X8S888888S8@X8XXXX8 888@8:8 8:8 8 888 X888 8 888 888X SX8 @ 8@@8 8S8.88 8%8 SX%88X 8 8888XS@8S88%XS8X@@
@XS888 8 8 8%888 8 8 X88.8 8 8 8 888 8S8 X 8S8 8 8888S8X8@8 8S8 X8S88XS8SS8@8X8S8 8SSXX8 8 SSS88 8 8tXX8 8SX.8XS88XS88888S88888SX@S88X8 @S8 S8 X@X8SSS8%8 8 888 8.X8@8SS8888@ 888X8S8 8 8X%;S888S888888XSS88@S8S88 8S8 88S8 88SXX 888 8 8 8 88 888%8 888S8X8%8 X8S8S8888 @SS8@8 8S8 X88SX8 8.8 8 S8 8@S8%X8@
@@S8S8 SS88X8 8 8 888 88SS%S888:8 8;8;8S@88.@@888S@%8 X8S@@8:X 8%X8 8 8 8S8 XX@8S@X8 8S8888S8S8 888 8 8 8.8 8;8X8888@S88@88888XS8X8888%8 888 S8 888XSSS88XX888 88@S8SX8 888XX8X8S8 8X88;;8%8@S8S88X@X8X8.888SSS88@8 8 888%88t8 8%8 8 S 888 8 88@8SSX888 8%888X8 SXX8S8XX8XXS8 SS8888S 8888SS8 8S888S8 8 XSS8
@@8:8S8 8 @ SSX8t8 8:8 888888X%8 888 8888 88S8SX%8 XS@SS88XS8 88@S8XS888 @88S8 SX8SS888S8 S88@ S%8 888;88888SX.@8X88888888@X888S88@8888888X@XX88S8X88 888@888 888S@ 8 SX8888 8888;@8%t8%88888SS8888S8888888X8X88X8%8 8 8 8 8X@8 88@.8 8.8 8S888%X8 8.8 X 8S8 88X%8 X8 8 888%8888%8%@8SSSSXSSXS88@8 8X%X8 8 X
@@@8@8 888 8%8 S888 888 X88888 @8 8 8S8 8S8t8@8 8;8 8 8 888 S8 8 8X8S88%8X8 @@8 @S8 S8 S @SX8 8 8;S88 8 8 8%XXX@88XXX88X88888@S8S888XS@8@88S88.88X8S88:8 8 8 X888S8 S888S88@ X%t88SXX8X8@@X8SS88S@S8X88S@8X8888XXS8 888X8S8 8S88 8 S 888 888 SS8SS8SX 8 8 8 8 8 8%8 8S%8SX8S8.X8 S8 XX88@8S8 8 @ 88%8S8 88@ 
@8 8 8888 888 8 S8 8 8 8S8 8 X8 X8 8 8 8 X88%88888XS 88XX888 XX8 S8 8 8X888@8SS8SXX8 SX88 8 S888 8 8%SX8.8 8S8SXXSX8@888S@S8S@888X8SSS8X8888tS88888S%8%88@8 8888X8S8X@888t8@X8X8X@88@X8SSSSS8SXXSS888@S8888@88@X@SS888S8%XXS%8 88 8 8 8 8 888S8SX8%88@X888 888 888S8 8 @8 8 88S88%X88X88 SX88.8 8 88888XXX 8
@@8 8 888@X@SX 8 88 8 888 8 8.S8%S X8 8 8 X88@8X8S8S8;8 8X888X88XSX88XX8 @88X8 S8S8@8X8 8  8S88SX888 @ S8 S 8 8 8S.88S8X8X:8@XX88SS8S88@S888@S88@888@@%8@888888X8888888@88888XX@888SS888888888SS88S@S88888XXXX8 8%8 8 @ 8S8 8 @%888S8X@8 8S8@8X8 XXS8X8%X 888 8 8 8.XX8SSX8 8.8.X88 88888%8SX8 88XS8S8@@8S8 
@XS88@S8X8 8%8 88S8XXS8 SSS%88 X8888 8888XS8 @S8 8%X88@8 8X@@%@8 8 8%@X @S8S8 8 S8S@88%XS8 X8 X8%8S@8:8 X8S8;8 8 8 88888X88SSS8SX8@8@S8X8S888@@8888X8@XX@88888888888888@@8@SSS88S8SS8SXX8@88SSS8SSS8SS888:@X8S88 888 8 8 888;8;8%88888X8XX8S@XSX8S8%X8%8%8;8S@ 888 8S8 8 88@ 888 X88X8 8 8 8 888SXX@XSSS%888
@@8 8 8 8 X 888 S@88XS88S8 8 X8X@S%S 8 8X@8 8 8 8t8X8X@88XS8S8SX8 88@X8SX8 888X8 888X 8SX888X8 8@888XS 8 8 S8 8 8 8 8X;8@SSS8X8SS8@S8:8888X888X8X888S88888888@X888@888S88888888S8888S888888SS8XXSS.888X S@XX@8S88 8 S 888 8 8:8@8@8S@8 8888@8 8SS8%8 8X 8 8 8 88@ 888.X8888 8 8;8 @8 S@8 S8888 8 8X8@S8 8 8 
@XS8 8 888%8 8 8%8 XS8.8@8SX8 S8S8S8S88;8 SS88X S8 8 8 8X8SXXS8S@8 8 8 8%88@8SSS8 X8X8 8S8 XSX8X8 X8S8 8 8 8;888 8 8S8 8888X8XS8S888@888X88@@X8888@S8SX8S8S888S@8S@8S8S8S8X888@8S888SXX8@SS8X8X8S8SS888@XSXSS@8 8 S8 8 8 8 S 8X8X8%8 @8 8:8 S8 8SX8S8S8S8X88.8X8 8 8 8 8 8.88 88 8S@8%888 %888SS888X@S888 8%
@@8;8 8X88888 888 8 888%8 8S888S8@8%8 8X 8%8 8S@ S8 S 8 8X8S8 S8 X8 8 S@8 X8 8 SS8XXXS8 88888X 8:8 XS888 88%S88 8X8 XS8S@S88X88@8888SX8S8888@8SXXS8X8888X8888SSS8@8S888888888X8888@S8S8@SS88@X888;8@@@XS@XX8 8 88@ S888 88@ 888 888X8 8 8@X8S@8 8@8.SX 8X8 88%8 888 8 88@ 8S888X@ 8S88@8 8S@SSX88X 8 8 8 8 8
@@@8 S 8X8S8888XX XSX8 8 8;8 8888 S%X8X8SS8 8 8;8 X8%8 88X @ 8:X8%SS88X8 8 @8 8%8 8 8 S8X8 888% 8 8 8 8.8 %88SX8S8S8S8 8 8X8 888S8@SS88XSX8888XS888@SS88XX88SS8XX@88X8S8X888@@X88S8X8888888888;@XX8SXX@SX8 8 888XX@ X8 8 8 8 8 8X8S8X%8888S88XX8%@X8 8SS8 8 8888 8 88@ 8 S 8 S8X8 S888 8SS8SX8S 8 8 888.888;
@8 X88 X8 8S8XX888 @ 8 88 88X @888 8 SS@8 S888 8.8 8 S8S8S8S88@ X888S%8 8 888888 88@:88 8%8S8 8 8 888@:888SXX8 8 X888S8X8 8 8S888t88X8888888@X8X8@S8@8888888S8888888XS88888XSS888888S88888%:8@XX8SSXX8 8S88 8 8 8S 8 S%S8 888 8 8@8S88X 8 8 88%X8@8 88@%88 8S8X888XS8 8 8 88@%X8 8 X88SS8 8S8%8 8 8888 8 8 @
@@8 888 8%S8 8 X@8SS8.8 8XX8 8X8S8SS8S8 S8 88 X 8:88@S8 X8%S8%X88SS8 8 8 888 8SX8 8:XS88%8 8 888888 8 8 8;8 8 8 8S8 8 @ XSX8 8@8 8X@88.S8@@SX8X888S8S88XX88S:8@XS888@88@@SS888@@X88S8t88@XXXXXSXSXX8 8 S8S8X 8 8 8 X88@ 88 8 88@@8@8@8S8 8 8XX8SSX@8 8 8SX888 8S8 8 88@8.8 8.8 8 88X8 8 8 X8X8.88@X8 8@S8 8 
@XX8 8S8.8 SS@8S8 8 8XS8 8 8 8 8%S8 S8:8 888@8S8 X8@X888%88 88 8S8 8SS888 8 8 8 S8:8 XS8SX8 88X 8 X8 888SX 88888 8S88 X8 8 S8@8S@X8S8 8@S@88%8888S8888S8S8888S88SX888888S88X888X888XXX@XXX8 8XXXXX8SX88SX8%8SSSS%88 X8 8 S 888S@8X888X8 888 8 8 8S8S@8 %8 8%@8 8 8t8X8 8@@8 S88 8 8SX8 88@ SX8888 8%8%8 88 8
@@88S8X8XX8 @ S@88X8S8 88888888.8 X8 @8 888X8S888 8888SX8 88 8 SSS888 88 8 8 S @8%S @88S8 S8S8%X @SS8.8 8S8:8 8 8 8 8S%8888%8XSX8 88%8S8X8S@S@@88888:8t8XXXSX88888SS;;88;88888XSXXX@XXXX8 @8@SX8 8 X8.88 8888 888 S8 S8 8 8 8 8S@XXXX@88 8 8 8 8 @88%888S8 8S@8 888SX@8@8 X8SS8@@8X8 XS8 8S8X8X888XS8 S8 S%X
@@%8X8 8888%S8S8@8.S8 8SS8888S8S 8 88 XS8SXX@8S888%@888SX8 88@888888@8XX888:8%888%8 S888@@8S8 8 8 8 8XX888.8X8:X 8 88@S8 888 8 8 8 8SX@X8@SSXX8%X@@@S@ @X8SSXXXX8SSXXS8SX8S@XXX8 8SXSXX8 8 8%8 8% 8 88:88S8 8  8 88@8 8888888S@8S8 8 8XX8 888 88XX8@8 X8 X8 8S888SX88XX8 8 88888 88S8 8 888 8 X8@8 888 @8S8 
@8 8 88 8XS8 8 8 88 888@ S 88888 X8 8S8S%8%8 X8X@@8 8X88SX8S8 @XSSX8 X8 8%SS888X@S88 S8S8 X8 888.88@S8 8SX8S8:8%888 8.S 8 8;8 8 888 XX8@8SXX8 XXXX8S@S8S8 @X@XSXS8 8S8 8 XXXX8 8SSXX8 8 8 8S8X88@%S8 88 XS88X888@88  @88%8 88888X88.8 8S@8S8 S 8 8X888 S8%SX8S8SX8SXX8 XX88 @8XXXX8 SS888X8 S8 S8%8 8 8 XX@8
@@8 8%8888SX8 88XS88 8SX888 @8SX8 8%S8 8 SS@8S@8S8 8 8S@8%S8S8S8 8 X@SSSX8S8 8 8 8:88SX8 8S88X@ 8 8 8 888XS8SXXS88 X88%888 XS88@ 8 8 8 8:88 88X8 8%XSXS8:8 8 8@SSS8 8 8 8 8 8 8 8 8 S8 88@X8S888 8 88 88888SXS888SS8 8888S8 X8SX8 8@XX8S8 S@8S8 8 8X888 S8S888.8 @8 8 8 8 S8 XX8X8 8 888 888 8 8  S 8 X8 @ S
@XX888X8SX8S8888 8 8888%SXX8 X8 S888S8 8 8S8 8 8 88 @@8S@8S@8@S8S @ 88888X888@8@88@88@8 X8%SS8S888 888.8%8SX8S888S8X8 888 8 8 8 888 888 8 @8 8@88 8 8 8%X88 8S88 8 8 8 S 8 8 S 888 888 S8SXS8X8XS88 88 8@X@888S 8XX @S8S8X88SS8SS8X8S8.88@X8 8 888 8X888%@8 88SX8SS8X8:8:8 888X88888X%S88 8 88@:8%8 888S8 8 
@@8S8 8 8S@888X 8 8S8X88XXS8SXX88@@ 8 88@:X 8 8 8 888X 8S@8@8XX 8 88 @X 8X8@8X8SS8 @8SS8 888@8888SX8S@8%@S8SS8X8888 888 %88888 8 8 8 8.X @SS8%8%88 X 888@8 8 8XX8 888S8 888 8 88@ 8 8 8 SX88 8S8X@ 8 88 8S8 8S8%888@@8 8S8 88%S8%S8 X 8 8 X 888%8 8.8S@@@SS8 8X8:8 8888S8 8 8888X8@8S8%8 8;8 8:88@88SS8%S888
@@SXX8 88@SX8 8 888@ 8%88SX 8 8S88 8;8 8t8S888%8X8%S8XX 8X@8 8 8 8 S8X8SSSS8;8X8 S8 X8 X8 X8X8@8.8%X@XS8 8 8S8 S88.8 8@8 8S88 88@ 888 8 8 888S88S88 8t8 8 888 8 X888S88@ 8 S 888 888 S88S8 XX8 8 8 88888 8 88888 @8@8;8 8 8 X8 8 8 8S888:8S8S8 XXS88XSXS8 888 XSX 8 X88XS8%8SX@ 8 8:X@8 X88 88@S88888SS8 88 
@8%8 8 8XX8 XSX8X8@8XX8 @8 888 8 XS88@X 8 8 8:8X8 8 88S8;8S8@XX888X8 888 8 88S8 8 8%X88 X8 8 8 8888 88 XX8 S8 8S8@8 8S888@8%S8S8 8 8 88@:8%8 8 X8 X888S8 8SXSX @8S8 8S8@8S8 88@ 8 8 8S8 X 8 888 888:8X888 8S88XS8S@8%X88XS88S88@8 8 8 8:8 888 8S8 8X88 888%X 8 8S888 8%XS88 8 8 8SX8X888X8.8 8S@S@88%8SX8S@8
@X8 888 8 8888X 8 X 8S@8 8 88 8 8 8 @X8 8% 8 8 8S@X8 8 8X 8X8S8 8 88@X888S8 88 888.8X8 8 S888 @88 8S88XSS88%S8;8@8XS 8X8@8 8SS8X888X8S8 888 S @SX88S8 888 8S8 888 8888S@8888@8 8 888 8S@88 8S@SSS8 @@@@@88 8 88SS8SX8X8SS8 S8S8S88@888:888%8 888 8 8SX8S8 8 88@ X88 8 8 8 8SXS88 88S8%888SXSSX8S88 8 888S8 X
@XS8 8 888@8SSX8:8S@ 8S88.8 8 S8%S 8 X88.8S888@ 8 8 88XS8SS8 @88888SX8X@ 888SX8 8:8 8 S @%8XX8:XS8 8 SX8 88@ 8X88%8S8;888S@XX8@8:X8SX8XS8S@8S8;8SS8SX8 8 X 8 S 8 @@8 XX@88X8SXS8888 8 88S88X8 88888SSX8X@ 888SXX@X8 XSS888SSS8:8%8X88 XX8 X8 S8 888 8 SS8  8 8 8S8SXSS8888 8 8 S8 8 S8S@@8S8S8 8 8XS8SS8 S8 
@@88S88S8X8X8S8 X@8 8 8 8@8SS8 X8%888 88@ 8 88X8 888 8 X 8%@888S8 8 8 8%8@@@8 X8.@888 8 S8:8 8 8 S888S888 8:8X8 @8 8 8X888S88@@S8 S8X8S88@ XX88@8 X8S%S 8 88@ 8 8 XX8%8 S%8 8 8 8X@8 8SX8 88@8 88888 8 8S8 8%8 8S888 8 8XS8 8 8@8%8 88 8 88 888 88 8 8%88@SS88X8X88S8 8 X88 88@S8S8888@8 XX 8;XS8S8 88 88SS8
@@%8S@8@ 8SX 8 8X8S8X8S8S8 8888X 8t8%8.8 88XSXXS8 8SXS8 8 8 X@ 8%88@SSXXX8@@ @ 88 8X8888 88 8 88X8S8 @88.X 8 X88SS 888X8SS@X8S8@ 8 8 X8 8 8 8 @ S8 888X888 8 888 8 8 888S8 88888 8X@8 8 888%8 8.8X8 888 888 8 8 8X8@888@8 88 8X888X8 8S 8 8 8 S8 XXS S%88 8 X8%8X8 8:8 8X8 SS8 8 888 8 S8%8 S8 8%SS8SX8 888S
@8 8X8%8S888XSX8@ 8S@88X8 X88 XXS88 XX8t8 8 8 8 S888%888 S @S8 XS8SX8S888SX@8.8 8@@8 88 8 S888 8 8 X8S8@8 888%XSX8%88SXS8 8 %8X888XS8SS8.888X8:8 88 888 8SXX 8S8 S8 8 8 8 8S8@888 8SX8 8 @@8 888 8 8;8 8 8 8 888 8X8S8S888S8X@8S8%SS8:88XX%88X X8 88888S@8 8 XX 8 8%X8S8S888S88X8 8 X88 X888%S8 8 8 8 888S8X
@@8 8SX 8 S888X88@ 8S8X8.8X8 8 8%888SX@8 8 888%8 8888S8%8 888:8 88X SX 8S88SXX88X8X88 8 S888 S% 88@  8X888 8 8X8888 8@SSS8 8SS8 S8X8.8 88 88S 8 8 88X888 8 8 888 8888@%8 S 8 8X888 8 X8 8X8 8 8S888t8 888.888 8tXS8% S8S@ 8S8%@XS8 888 8X88S8 8 S8S8%X 8 88X8X8SSS88S8SX8 S8 8 888.88X @ SX88888SS 888 8X@%8
@XS888 8 8SX888 XX8;8 @ 8 8 S 88@X888X8 88@@@ 8 8X8X88 S8888 S88 8 8X8%S8 88SX 8888 88 8%%X 8 8 88S8 S8S8 8 8 8S8S88 8 8 SS8S8 8 8 8 X8 88:88 8 88S888@ 8 888S8 8t8 8 88@ 888 8X888 8 X8 8 8 8 8 8:8 888 8 8.X 8 8 8 888 8 8@8S8S88%8XX 8:8%8XX8 @S8 8 S8%8 888888%S8 8 S8 SS 8 @;XS8%8 8S8 X8X88X8S8 X 8S@S
@@8 8 888 888S88 8.@88 8 S 8 8 8 8X8@8XS88S8S8 88@ 8 X8X88@@S8.8X888@@8 8S@S8%888 8S88XX88XS 888 SS@8 X8%XS8S8:X 8%X8 888S888 8 888 8 S8 88 XS88 SXS@8%8 88888@X 8 8 8 8 8 8 X 8X8 8 8 X8 8888888.888%8 888 8 888 S88S888 8SXSS@8 8@S8%8 SS8X8 8 S8.88@ SS@8X8%S888SX8t8SX8 8 88;8 8.888 8S8 XX%8%X888 8 8 8
@XS8 8 8.8:XX8 8 S88X%8 8 88888 8.8X8SX8 8 8 X8 8 8 8 S8S88SX88 8%8S8%X8;8@8 8 XS8 8 88@888 8 8 8 8SS8 88888@XX8 S8 8%SX 8;8 8t8.8 88@ X8SX8 8 88@8888%88;8X888 888.888 888 8 8 8%8 8%8 X8S8%8X8 8 8;SXX 8 88@.8%88XX8S888 8 8X8.8 8 8 888S8@S888 X8%8 8 8 88888S8 8 S8 8 S 88S88 888%8 888S8 8SS8%8 SX8 XSS]]


--[[]]
function retard()
    local Event = game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest
--    Event:FireServer("hi im a skid who didn't read the readme in sangware", "All")
--    Event:FireServer("please laugh at me", "All")
while true do end --wait()
end
-- Instances:
game.StarterGui:SetCore("SendNotification", {
    Title = "Script Executed!";
    Text = "Thank you for using my hub";
    Button1 = "yes";
    Icon = "";
    Duration = 4;
})

if not sethiddenproperty then
   -- retard()
 game.StarterGui:SetCore("SendNotification", {
    Title = "no";
    Text = "get synapse kid";
    Button1 = "h";
    Icon = "";
    Duration = 4;
    
})
wait(3)
  retard()
else
  -- retard()
end
rconsoleprint ("fe = no")

local Selection = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local DW = Instance.new("ImageLabel")
local Icon = Instance.new("ImageLabel")
local AcceptBtn = Instance.new("ImageButton")
local Light = Instance.new("TextLabel")
local TextLabel = Instance.new("TextLabel")
local WD = Instance.new("ImageLabel")
local Icon_2 = Instance.new("ImageLabel")
local Dark = Instance.new("ImageButton")
local TextLabel_2 = Instance.new("TextLabel")
local TextLabel_3 = Instance.new("TextLabel")

--Properties:

Selection.Name = "Selection"
Selection.Parent = game.CoreGui

Frame.Parent = Selection
Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Frame.BackgroundTransparency = 1.000
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.306103587, 0, 0.341810346, 0)
Frame.Size = UDim2.new(0, 478, 0, 323)

DW.Name = "DW"
DW.Parent = Frame
DW.AnchorPoint = Vector2.new(0.5, 0.5)
DW.BackgroundColor3 = Color3.fromRGB(250, 250, 250)
DW.BackgroundTransparency = 1.000
DW.Position = UDim2.new(0, 119, 0, 161)
DW.Size = UDim2.new(0, 239, 0, 323)
DW.Image = "rbxassetid://2790382281"
DW.ImageColor3 = Color3.fromRGB(250, 250, 250)
DW.ScaleType = Enum.ScaleType.Slice
DW.SliceCenter = Rect.new(4, 4, 252, 252)

Icon.Name = "Icon"
Icon.Parent = DW
Icon.AnchorPoint = Vector2.new(0.5, 0.5)
Icon.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Icon.BackgroundTransparency = 1.000
Icon.BorderSizePixel = 0
Icon.Position = UDim2.new(0, 48, 0, 46)
Icon.Size = UDim2.new(0, 79, 0, 62)
Icon.Image = "http://www.roblox.com/asset/?id=5459745167"

AcceptBtn.Name = "AcceptBtn"
AcceptBtn.Parent = DW
AcceptBtn.AnchorPoint = Vector2.new(0.5, 0.5)
AcceptBtn.BackgroundColor3 = Color3.fromRGB(240, 240, 240)
AcceptBtn.BackgroundTransparency = 1.000
AcceptBtn.Position = UDim2.new(0.498796433, 0, 0.769522369, 0)
AcceptBtn.Size = UDim2.new(0, 207, 0, 46)
AcceptBtn.Image = "rbxassetid://2790389767"
AcceptBtn.ImageColor3 = Color3.fromRGB(0, 190, 139)
AcceptBtn.ScaleType = Enum.ScaleType.Slice
AcceptBtn.SliceCenter = Rect.new(8, 8, 248, 248)

Light.Name = "Light"
Light.Parent = AcceptBtn
Light.AnchorPoint = Vector2.new(0.5, 0.5)
Light.BackgroundTransparency = 1.000
Light.BorderSizePixel = 0
Light.Position = UDim2.new(0.49751544, 0, 0.495129824, 0)
Light.Size = UDim2.new(1.34710741, 0, 1.89285719, 0)
Light.Font = Enum.Font.GothamSemibold
Light.Text = "Execute"
Light.TextColor3 = Color3.fromRGB(255, 255, 255)
Light.TextSize = 16.000
AcceptBtn.MouseButton1Down:connect(function()
Selection.Frame:TweenPosition(UDim2.new(-0.409, 0,0.288, 0), 'Out', 'Bounce', 1, true)
wait(4)
game.CoreGui.Selection:Destroy()
-- Instances:
lplayer = game:GetService("Players").LocalPlayer
local Mouse = lplayer:GetMouse()
local sangiscool = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local sangWAREexecutionground = Instance.new("ImageLabel")
local Icon = Instance.new("ImageLabel")
local ImageButton = Instance.new("ImageButton")
local BAR = Instance.new("TextBox")

--Properties:

sangiscool.Name = "sangiscool"
sangiscool.Parent = game.CoreGui
sangiscool.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Frame.Parent = sangiscool
Frame.BackgroundColor3 = Color3.fromRGB(34, 34, 34)
Frame.BackgroundTransparency = 1.000
Frame.Position = UDim2.new(0.37716049, 0, 0.270689636, 0)
Frame.Size = UDim2.new(0, 536, 0, 281)

sangWAREexecutionground.Name = "sangWARE execution ground"
sangWAREexecutionground.Parent = Frame
sangWAREexecutionground.AnchorPoint = Vector2.new(0.5, 0.5)
sangWAREexecutionground.BackgroundColor3 = Color3.fromRGB(24, 24, 24)
sangWAREexecutionground.BackgroundTransparency = 1.000
sangWAREexecutionground.Position = UDim2.new(0, 268, 0, 142)
sangWAREexecutionground.Size = UDim2.new(0, 519, 0, 264)
sangWAREexecutionground.Image = "rbxassetid://2790382281"
sangWAREexecutionground.ImageColor3 = Color3.fromRGB(250, 250, 250)
sangWAREexecutionground.ScaleType = Enum.ScaleType.Slice
sangWAREexecutionground.SliceCenter = Rect.new(4, 4, 252, 252)

Icon.Name = "Icon"
Icon.Parent = sangWAREexecutionground
Icon.AnchorPoint = Vector2.new(0.5, 0.5)
Icon.BackgroundColor3 = Color3.fromRGB(24, 24, 24)
Icon.BackgroundTransparency = 1.000
Icon.BorderSizePixel = 0
Icon.Position = UDim2.new(0, 48, 0, 42)
Icon.Size = UDim2.new(0, 79, 0, 62)
Icon.Image = "http://www.roblox.com/asset/?id=5459745167"

--ImageButton.Parent = sangWAREexecutionground
--ImageButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
--ImageButton.BorderColor3 = Color3.fromRGB(255, 255, 255)
--ImageButton.Position = UDim2.new(0.882948041, 0, 0.774934292, 0)
--ImageButton.Size = UDim2.new(0, 40, 0, 40)
ImageButton.Image = "http://www.roblox.com/asset/?id=115574122"

BAR.Name = "BAR"
BAR.Parent = sangWAREexecutionground
BAR.AnchorPoint = Vector2.new(0.5, 0.5)
BAR.BackgroundColor3 = Color3.fromRGB(229, 229, 229)
BAR.BackgroundTransparency = 0.500
BAR.BorderSizePixel = 0
BAR.Position = UDim2.new(0.498792917, 0, 0.561797142, 0)
BAR.Size = UDim2.new(0, 367, 0, 81)
BAR.Font = Enum.Font.Gotham
BAR.PlaceholderColor3 = Color3.fromRGB(103, 103, 103)
BAR.PlaceholderText = "Enter Command"
BAR.Text = ""
BAR.TextColor3 = Color3.fromRGB(2, 2, 2)
BAR.TextSize = 14.000



-- Scripts:
local function RULWIG_fake_script() -- MainFrame.Draggify 
	local script = Instance.new('LocalScript', game.CoreGui.sangiscool.Frame)

	local UIS = game:GetService("UserInputService")
	function dragify(Frame)
		dragToggle = nil
		dragSpeed = 0.5
		dragInput = nil
		dragStart = nil
		dragPos = nil
		function updateInput(input)
			Delta = input.Position - dragStart
			Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
			game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.25), {Position = Position}):Play()
		end
		Frame.InputBegan:Connect(function(input)
			if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and UIS:GetFocusedTextBox() == nil then
				dragToggle = true
				dragStart = input.Position
				startPos = Frame.Position
				input.Changed:Connect(function()
					if input.UserInputState == Enum.UserInputState.End then
						dragToggle = false
					end
				end)
			end
		end)
		Frame.InputChanged:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
				dragInput = input
			end
		end)
		game:GetService("UserInputService").InputChanged:Connect(function(input)
			if input == dragInput and dragToggle then
				updateInput(input)
			end
		end)
	end
	dragify(script.Parent)
	
end
coroutine.wrap(RULWIG_fake_script)()



--chat command
prefix = "."

game.Players.LocalPlayer.Chatted:Connect(function(msg)
if string.sub(msg, 1, 5) == (prefix.."gale") then
     	    

--cal hm  = sethiddenproperty(game.Players.CurbYismm.SimulationRadius            )
--int(hm)
---thiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end

loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()

print("cool")




--[[ Name : Gale Fighter ]]--
-------------------------------------------------------
--A Collaboration Between makhail07 and KillerDarkness0105

--Base Animaion by makhail07, attacks by KillerDarkness0105
-------------------------------------------------------


local FavIDs = {
	340106355, --Nefl Crystals
	927529620, --Dimension
	876981900, --Fantasy
	398987889, --Ordinary Days
	1117396305, --Oh wait, it's you.
	885996042, --Action Winter Journey
	919231299, --Sprawling Idiot Effigy
	743466274, --Good Day Sunshine
	727411183, --Knife Fight
	1402748531, --The Earth Is Counting On You!
	595230126 --Robot Language
	}



--The reality of my life isn't real but a Universe -makhail07
wait(0.2)
local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name)
print('yankee with no')
print('brim')
local char = workspace.non
local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")
hum.MaxHealth = 200
hum.Health = 200

-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
vt = Vector3.new
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 90
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------



-------------------------------------------------------
--Start Combo Function--
-------------------------------------------------------
local comboing = false
local combohits = 0
local combotime = 0
local maxtime = 65



function sandbox(var,func)
	local env = getfenv(func)
	local newenv = setmetatable({},{
		__index = function(self,k)
			if k=="script" then
				return var
			else
				return env[k]
			end
		end,
	})
	setfenv(func,newenv)
	return func
end
cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
comboframe = Instance.new("ScreenGui")
Frame1 = Instance.new("Frame")
Frame2 = Instance.new("Frame")
TextLabel3 = Instance.new("TextLabel")
comboframe.Name = "combinserter"
comboframe.Parent = mas
Frame1.Name = "combtimegui"
Frame1.Parent = comboframe
Frame1.Size = UDim2.new(0, 300, 0, 14)
Frame1.Position = UDim2.new(0, 900, 0.629999971, 0)
Frame1.BackgroundColor3 = Color3.new(0, 0, 0)
Frame1.BorderColor3 = Color3.new(0.0313726, 0.0470588, 0.0627451)
Frame1.BorderSizePixel = 5
Frame2.Name = "combtimeoverlay"
Frame2.Parent = Frame1
Frame2.Size = UDim2.new(0, 0, 0, 14)
Frame2.BackgroundColor3 = Color3.new(0, 1, 0)
Frame2.ZIndex = 2
TextLabel3.Parent = Frame2
TextLabel3.Transparency = 0
TextLabel3.Size = UDim2.new(0, 300, 0, 50)
TextLabel3.Text ="Hits:  "..combohits
TextLabel3.Position = UDim2.new(0, 0, -5.5999999, 0)
TextLabel3.BackgroundColor3 = Color3.new(1, 1, 1)
TextLabel3.BackgroundTransparency = 1
TextLabel3.Font = Enum.Font.Bodoni
TextLabel3.FontSize = Enum.FontSize.Size60
TextLabel3.TextColor3 = Color3.new(0, 1, 0)
TextLabel3.TextStrokeTransparency = 0
gui = game:GetService("Players").LocalPlayer.PlayerGui
for i,v in pairs(mas:GetChildren()) do
	v.Parent = game:GetService("Players").LocalPlayer.PlayerGui
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
	spawn(function()
		pcall(v)
	end)
end





coroutine.resume(coroutine.create(function()
	while true do
		wait()
		
		
		if combotime>65 then
		    combotime = 65
	    end
	    
	    
	    
	    
	    
		if combotime>.1 and comboing == true then
		    TextLabel3.Transparency = 0
		    TextLabel3.TextStrokeTransparency = 0
		    TextLabel3.BackgroundTransparency = 1
		    Frame1.Transparency = 0
		    Frame2.Transparency = 0
		       TextLabel3.Text ="Hits:  "..combohits
		    combotime = combotime - .34
Frame2.Size = Frame2.Size:lerp(UDim2.new(0, combotime/maxtime*300, 0, 14),0.42)
    end
    
    
    
    
	    if combotime<.1 then
	        		    TextLabel3.BackgroundTransparency = 1
	        		    TextLabel3.Transparency = 1
		    TextLabel3.TextStrokeTransparency = 1

Frame2.Size = UDim2.new(0, 0, 0, 14)
	        combotime = 0
	        comboing = false
	       		    Frame1.Transparency = 1
		    Frame2.Transparency = 1
		   combohits = 0 
	        
	        end
end
end))



-------------------------------------------------------
--End Combo Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
         if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
         if insta == true then
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:service("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end




	kDamagefunc=function(hit,minim,maxim,knockback,Type,Property,Delay,KnockbackType,decreaseblock)
        if hit.Parent==nil then
                return
        end
        h=hit.Parent:FindFirstChild("Humanoid")
        for _,v in pairs(hit.Parent:children()) do
        if v:IsA("Humanoid") then
        h=v
        end
        end
        if hit.Parent.Parent:FindFirstChild("Torso")~=nil then
        h=hit.Parent.Parent:FindFirstChild("Humanoid")
        end
        if hit.Parent.className=="Hat" then
        hit=hit.Parent.Parent:findFirstChild("Head")
        end
        if h~=nil and hit.Parent.Name~=char.Name and hit.Parent:FindFirstChild("Torso")~=nil then
        if hit.Parent:findFirstChild("DebounceHit")~=nil then if hit.Parent.DebounceHit.Value==true then return end end
        --[[                if game.Players:GetPlayerFromCharacter(hit.Parent)~=nil then
                        return
                end]]
--                        hs(hit,1.2) 
                        c=Instance.new("ObjectValue")
                        c.Name="creator"
                        c.Value=game:service("Players").LocalPlayer
                        c.Parent=h
                        game:GetService("Debris"):AddItem(c,.5)
                Damage=math.random(minim,maxim)
--                h:TakeDamage(Damage)
                blocked=false
                block=hit.Parent:findFirstChild("Block")
                if block~=nil then
                print(block.className)
                if block.className=="NumberValue" then
                if block.Value>0 then
                blocked=true
                if decreaseblock==nil then
                block.Value=block.Value-1
                end
                end
                end
                if block.className=="IntValue" then
                if block.Value>0 then
                blocked=true
                if decreaseblock~=nil then
                block.Value=block.Value-1
                end
                end
                end
                end
                if blocked==false then
--                h:TakeDamage(Damage)
                h.Health=h.Health-Damage
                kshowDamage(hit.Parent,Damage,.5,BrickColor.new("White"))
                else
                h.Health=h.Health-(Damage/2)
                kshowDamage(hit.Parent,Damage/2,.5,BrickColor.new("White"))
                end
                if Type=="Knockdown" then
                hum=hit.Parent.Humanoid
hum.PlatformStand=true
coroutine.resume(coroutine.create(function(HHumanoid)
swait(1)
HHumanoid.PlatformStand=false
end),hum)
                local angle=(hit.Position-(Property.Position+Vector3.new(0,0,0))).unit
--hit.CFrame=CFrame.new(hit.Position,Vector3.new(angle.x,hit.Position.y,angle.z))*CFrame.fromEulerAnglesXYZ(math.pi/4,0,0)
local bodvol=Instance.new("BodyVelocity")
bodvol.velocity=angle*knockback
bodvol.P=5000
bodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
bodvol.Parent=hit
rl=Instance.new("BodyAngularVelocity")
rl.P=3000
rl.maxTorque=Vector3.new(500,500,500)
rl.angularvelocity=Vector3.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))
rl.Parent=hit
game:GetService("Debris"):AddItem(bodvol,.5)
game:GetService("Debris"):AddItem(rl,.5)
                elseif Type=="Normal" then
                vp=Instance.new("BodyVelocity")
                vp.P=500
                vp.maxForce=Vector3.new(math.huge,0,math.huge)
--                vp.velocity=Character.Torso.CFrame.lookVector*Knockback
                if KnockbackType==1 then
                vp.velocity=Property.CFrame.lookVector*knockback+Property.Velocity/1.05
                elseif KnockbackType==2 then
                vp.velocity=Property.CFrame.lookVector*knockback
                end
                if knockback>0 then
                        vp.Parent=hit.Parent.Torso
                end
                game:GetService("Debris"):AddItem(vp,.5)
            elseif Type=="Up" then
                hit.Parent.Humanoid.PlatformStand = true
                local bodyVelocity=Instance.new("BodyVelocity")
                bodyVelocity.velocity=vt(0,15,0)
                bodyVelocity.P=5000
                bodyVelocity.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
                bodyVelocity.Parent=hit
                game:GetService("Debris"):AddItem(bodyVelocity,1)
                rl=Instance.new("BodyAngularVelocity")
                rl.P=3000
rl.AngularVelocity = Vector3.new(2000,2000,2000)
rl.MaxTorque = Vector3.new(40000,40000,40000)
                rl.Parent=hit
                hit.Parent.Humanoid.PlatformStand = false
                game:GetService("Debris"):AddItem(rl,.5)
                elseif Type=="Snare" then
                bp=Instance.new("BodyPosition")
                bp.P=2000
                bp.D=100
                bp.maxForce=Vector3.new(math.huge,math.huge,math.huge)
                bp.position=hit.Parent.Torso.Position
                bp.Parent=hit.Parent.Torso
                game:GetService("Debris"):AddItem(bp,1)
            elseif Type=="Float" then
                hit.Parent.Humanoid.PlatformStand = true
                                bp=Instance.new("BodyPosition")
                bp.P=2000
                bp.D=400
                bp.maxForce=Vector3.new(math.huge,math.huge,math.huge)
                bp.position=hit.Parent.Torso.Position+vt(0,35,24)
                                bp.Parent=hit.Parent.Torso
                	
local	rl=Instance.new("BodyAngularVelocity",hit.Parent.Torso)
rl.P=377705
rl.maxTorque=Vector3.new(1,1,1)*500
rl.angularvelocity=Vector3.new(math.random(-3,3),math.random(-6,6),math.random(-3,3))

 local BF = Instance.new("BodyForce",hit.Parent.Torso)
            BF.force = Vector3.new(0, workspace.Gravity/1.10, 0)
                game:GetService("Debris"):AddItem(bp,5)
game:GetService("Debris"):AddItem(BF,5)
game:GetService("Debris"):AddItem(rl,5)
                elseif Type=="Target" then
                if Targetting==false then
                ZTarget=hit.Parent.Torso
                coroutine.resume(coroutine.create(function(Part) 
                so("http://www.roblox.com/asset/?id=15666462",Part,1,1.5) 
                swait(5)
                so("http://www.roblox.com/asset/?id=15666462",Part,1,1.5) 
                end),ZTarget)
                TargHum=ZTarget.Parent:findFirstChild("Humanoid")
                targetgui=Instance.new("BillboardGui")
                targetgui.Parent=ZTarget
                targetgui.Size=UDim2.new(10,100,10,100)
                targ=Instance.new("ImageLabel")
                targ.Parent=targetgui
                targ.BackgroundTransparency=1
                targ.Image="rbxassetid://4834067"
                targ.Size=UDim2.new(1,0,1,0)
                cam.CameraType="Scriptable"
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)
                workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                Targetting=true
                RocketTarget=ZTarget
                for i=1,Property do
                --while Targetting==true and Humanoid.Health>0 and Character.Parent~=nil do
                if Humanoid.Health>0 and char.Parent~=nil and TargHum.Health>0 and TargHum.Parent~=nil and Targetting==true then
                swait()
                end
                --workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,Head.CFrame.p+rmdir*100)
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)*cf(0,5,10)*euler(-0.3,0,0)
                end
                Targetting=false
                RocketTarget=nil
                targetgui.Parent=nil
                cam.CameraType="Custom"
                end
                end
                        debounce=Instance.new("BoolValue")
                        debounce.Name="DebounceHit"
                        debounce.Parent=hit.Parent
                        debounce.Value=true
                        game:GetService("Debris"):AddItem(debounce,Delay)
                        c=Instance.new("ObjectValue")
                        c.Name="creator"
                        c.Value=Player
                        c.Parent=h
                        game:GetService("Debris"):AddItem(c,.5)
                CRIT=false
                hitDeb=true
                AttackPos=6
                comboing = true
                combohits = combohits+1
                combotime = combotime+3.4


                
                if hitfloor == nil then
                    
    local velo=Instance.new("BodyVelocity")
                velo.velocity=vt(0,5.5,0)
                velo.P=8000
                velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                velo.Parent=root
                game:GetService("Debris"):AddItem(velo,0.06)
                
                                   local hitvelo=Instance.new("BodyVelocity")
                hitvelo.velocity=vt(0,5.5,0)
                hitvelo.P=8000
                hitvelo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                hitvelo.Parent=hit
                             game:GetService("Debris"):AddItem(hitvelo,0.06)
                             
                                                          coroutine.resume(coroutine.create(function()
                                 for i = 0,3.7,0.1 do
   swait()
         hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,0,-2.4)
        root.Velocity = root.CFrame.lookVector*0
        hit.Velocity = hit.CFrame.lookVector*130
end
end))
         coroutine.resume(coroutine.create(function()
             while ultra == true do
                 swait()
                 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,0,-2.4)
             end
             end))
                             
                
                end
                
                
        end
end
 
kshowDamage=function(Char,Dealt,du,Color)
        m=Instance.new("Model")
        m.Name=tostring(Dealt)
        h=Instance.new("Humanoid")
        h.Health=0
        h.MaxHealth=0
        h.Parent=m
        c=Instance.new("Part")
        c.Transparency=0
        c.BrickColor=Color
        c.Name="Head"
        c.Material = "Neon"
        c.TopSurface=0
        c.BottomSurface=0
        c.formFactor="Plate"
        c.Size=Vector3.new(1,.4,1)
        ms=Instance.new("CylinderMesh")
        ms.Scale=Vector3.new(.8,.8,.8)
        if CRIT==true then
                ms.Scale=Vector3.new(1,1.25,1)
        end
        ms.Parent=c
        c.Reflectance=0
        Instance.new("BodyGyro").Parent=c
        c.Parent=m
        if Char:findFirstChild("Head")~=nil then
        c.CFrame=CFrame.new(Char["Head"].CFrame.p+Vector3.new(0,1.5,0))
        elseif Char.Parent:findFirstChild("Head")~=nil then
        c.CFrame=CFrame.new(Char.Parent["Head"].CFrame.p+Vector3.new(0,1.5,0))
        end
        f=Instance.new("BodyPosition")
        f.P=2000
        f.D=220
        f.maxForce=Vector3.new(math.huge,math.huge,math.huge)
        f.position=c.Position+Vector3.new(0,3,0)
        f.Parent=c
        game:GetService("Debris"):AddItem(m,.5+du)
        c.CanCollide=false
        m.Parent=workspace
        c.CanCollide=false
    
end

-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end

function Eviscerate(dude)
	if dude.Name ~= char then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
			dude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
					end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
						v:Destroy()
					end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
						for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
								o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							v.Color = maincolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.08
								end
								wait(0.5)
								PartEmmit1.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end




--killer's effects





		function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end
	
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh){
		Parent = Part,
		Offset = OffSet,
		Scale = Scale,
	}
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
		
		
		
function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {
			prt,
			"Block1",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 2 then
		table.insert(Effects, {
			prt,
			"Block2",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
end

function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt=CreatePart(workspace,"Neon",0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh,num) 
for i=0,1,delay do
swait()
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,(math.random(0,1)+math.random())/5)
end

function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end


function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function BreakEffect(brickcolor, cframe, x1, y1, z1)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	local num = math.random(10, 50) / 1000
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Shatter",
		num,
		prt.CFrame,
		math.random() - math.random(),
		0,
		math.random(50, 100) / 100
	})
end





						       so = function(id,par,vol,pit)
		coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound",par or workspace)
		sou.Volume=vol
		sou.Pitch=pit or 1
		sou.SoundId=id
		sou:play()
		game:GetService("Debris"):AddItem(sou,8)
		end))
		end


--end of killer's effects


function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 900817147 --900817147
local SONG2 = 0
local Music = Instance.new("Sound",tors)
Music.Volume = 0.7
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
local attacktype = 1
local attackdebounce = false
local euler = CFrame.fromEulerAnglesXYZ
local cankick = false
----------------------------------------------------------------------------------
hum.WalkSpeed = 8
hum.JumpPower = 57
--[[
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
]]
local ANIMATOR = hum.Animator
local ANIMATE = char.Animate
ANIMATE.Parent = nil
ANIMATOR.Parent = nil
-------------------------------------------------------
--End Customization--
-------------------------------------------------------


-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------

--pls be proud mak i did my best



function attackone()
    
    attack = true
    
          for i = 0, 1.35, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4-2*i), math.rad(4+2*i), math.rad(-40-11*i)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(40+11*i)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.6, 0.2) * angles(math.rad(90+4*i), math.rad(-43), math.rad(16+6*i)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-43)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, 0) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, -0.2) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
      end
      
      so("http://roblox.com/asset/?id=1340545854",ra,1,math.random(0.7,1))


con5=ra.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,3,4,math.random(2,3),"Normal",root,0,1)

so("http://roblox.com/asset/?id=636494529",ra,2,1)
 
 RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))


      wait(0.34)
attackdebounce = false

end
end
end)
                for i = 0, 1.12, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(6), math.rad(23)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(-23)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.6, -0.8) * angles(math.rad(110), math.rad(23), math.rad(2)), 0.4)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0.2) * angles(math.rad(-37), math.rad(0), math.rad(-13)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.3) * RHCF * angles(math.rad(-4), math.rad(0), math.rad(6)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0.05) * LHCF * angles(math.rad(-22), math.rad(0), math.rad(23)), 0.3)
      end
      
      con5:Disconnect()
          attack = false
          
      end












function attacktwo()
    
    attack = true
    
          for i = 0, 1.35, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(46)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(6)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
      end
      
      so("http://roblox.com/asset/?id=1340545854",la,1,math.random(0.7,1))


con5=la.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,3,4,math.random(2,3),"Normal",root,0,1)

so("http://roblox.com/asset/?id=636494529",la,2,1)
 
 RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))


      wait(0.34)
attackdebounce = false

end
end
end)




                for i = 0, 1.12, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(-6), math.rad(-27)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(27)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.16) * angles(math.rad(-33), math.rad(0), math.rad(23)), 0.4)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.67, -0.9) * angles(math.rad(116), math.rad(-28), math.rad(1)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0.05) * RHCF * angles(math.rad(-22), math.rad(0), math.rad(-18)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, -0.3) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(4)), 0.3)
      end
      
      con5:Disconnect()
attack = false
          
      end





function attackthree()
    
    attack = true
    
    
              for i = 0, 1.14, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-46)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(36)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-12), math.rad(0), math.rad(34)), 0.2)
      end
    
    con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,4,5,math.random(3,4),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",ll,2,1)
 
 RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))

    
          wait(0.34)
attackdebounce = false

end
end
end)

        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 9.14, 0.3 do
        swait()
        BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-54*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      attack = false
      con5:disconnect()
end



function attackfour()
    
    attack = true
            so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
     WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
              for i = 0, 5.14, 0.1 do
        swait()
        SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24+4*i), math.rad(0), math.rad(0)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0+11*i), math.rad(0), math.rad(0)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(36+4*i)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(-36-4*i)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28+4*i)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34-4*i)), 0.2)
      end
              so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
       local velo=Instance.new("BodyVelocity")
                velo.velocity=vt(0,25,0)
                velo.P=8000
                velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                velo.Parent=root
                game:GetService("Debris"):AddItem(velo,0.7)



con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.6,-1.8)
end
end))
--kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1)
 RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8)),0.44)
end
end))


      wait(0.14)
attackdebounce = false
end
end
end)

                    for i = 0, 5.11, 0.15 do
        swait()
        BlockEffect(BrickColor.new("White"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.2*i) * angles(math.rad(-10-80*i), math.rad(0), math.rad(0)), 0.42)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
      end


      attack = false
      con5:disconnect()
    end





local cooldown = false
function quickkick()
    attack = true
    
    
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.3,-1.8)
end
end))

--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1)
 RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8)),0.44)
end
end))


      wait(0.08)
attackdebounce = false
end
end
end)

        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 11.14, 0.3 do
        swait()
        root.Velocity = root.CFrame.lookVector * 30
        BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-90*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      attack = false
      con5:disconnect()
end

    
    
    
    
    
    
    
function Taunt()
	attack = true
	hum.WalkSpeed = 0
	Cso("1535995570", hed, 8.45, 1)
	for i = 0, 8.2, 0.1 do
		swait()
		hum.WalkSpeed = 0
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25), Rad(0), Rad(16 * Cos(sine / 12))), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.1* Player_Size, 0.5 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(180), Rad(6), Rad(-56)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.1 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(45), Rad(6), Rad(86)), 0.1)
	end
	attack = false
	hum.WalkSpeed = 8
end
    
    





function Hyperkickcombo()
    
    attack = true
            so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
     WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
      for i = 0, 7.14, 0.1 do
        swait()
        SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(36)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-36)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
      end
local Cracking = Cso("292536356", tors, 10, 1)
 for i = 0, 7.14, 0.1 do
        swait()
		hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
		Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Lime green", 0, "Sphere")
		WaveEffect(BrickColor.new("Lime green"), root.CFrame * CFrame.new(0, -6, 0) * euler(0, math.random(-25, 25), 0), 1, 1, 1, 1, 0.2, 1, 0.05)
        SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
		SphereEffect(BrickColor.new("Lime green"),ll.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(30), math.rad(0), math.rad(0)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(36)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(-36)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
      end
      Cracking.Playing = false
      so("http://www.roblox.com/asset/?id=197161452", char, 3, 0.8)
              so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
              SphereEffect(BrickColor.new("Lime green"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
       local velo=Instance.new("BodyVelocity")
                velo.velocity=vt(0,27,0)
                velo.P=11000
                velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                velo.Parent=root
                game:GetService("Debris"):AddItem(velo,1.24)



con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,3.4,-1.8)
end
end))
--kDamagefunc(hit,2,3,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.09)
attackdebounce = false
end
end
end)

                    for i = 0, 9.11, 0.2 do
        swait()
        BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.12*i) * angles(math.rad(-10-95*i), math.rad(0), math.rad(0)), 0.42)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
      end




      con5:disconnect()
      
      
      
      
      
      
      con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
                       
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.08)
attackdebounce = false
end
end
end)
      
      
      
        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 9.14, 0.3 do
        swait()
               root.Velocity = root.CFrame.lookVector * 20
        BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(53), math.rad(8), math.rad(0-54*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      
      
      
            con5:disconnect()
      
      
      
      con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)
      
      
              so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 15.14, 0.32 do
        swait()
        root.Velocity = root.CFrame.lookVector * 20
        BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-50*i), math.rad(8+20*i), math.rad(0-90*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-4*i)), 0.35)
      end
      
      attack = false
      con5:disconnect()
      
    end





local ultra = false

function Galekicks()
    
    attack = true
                so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
          for i = 0, 1.65, 0.1 do
        swait()
        root.Velocity = root.CFrame.lookVector * 0
        SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end


for i = 1, 17 do
    
          con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)
    
          for i = 0, .1, 0.2 do
        swait()
                BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
                root.Velocity = root.CFrame.lookVector * 10
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
      end

      so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))
      
          for i = 0, 0.4, 0.2 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end
      con5:disconnect()
end

          		    		    
        u =   mouse.KeyDown:connect(function(key)
          	if key == 'r' and combohits >= 150 then
		    ultra = true
		    SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,15,15,15,0.04)
		    end
          end)
          wait(0.3)
         if ultra == true then 
combohits = 0
wait(0.1)
 for i = 0, 1.65, 0.1 do
        swait()
        root.Velocity = root.CFrame.lookVector * 0
        SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end


so("http://roblox.com/asset/?id=146094803",hed,1,1.2)

for i = 1, 65 do
    --Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Really red", 0, "Brick")
          con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)

            
            
            
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)
    
          for i = 0, .03, 0.1 do
        swait()
                BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
                root.Velocity = root.CFrame.lookVector * 10
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
      end

      so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))
      
          for i = 0, 0.07, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end
      con5:disconnect()
end

for i = 0, 1.65, 0.1 do
        swait()
        root.Velocity = root.CFrame.lookVector * 0
        SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end

con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 --hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit, 1, 3, 0,"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,.63)
 RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)

              so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 1, 1.4)
          SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
   
  for i = 0, 2, 0.1 do
        swait()
		--BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0.2) * RHCF * angles(math.rad(-50), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end
        SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
        
        wait(0.25)
        con5:Disconnect() 
   

        
        
        con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=565207203",ll,7,0.63)
 
 RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
SpecialEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,5,18,5,0.04)
WaveEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,1.5,16,1.5,0.04)

coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))
    
          wait(0.06)
attackdebounce = false

end
end
end)

coroutine.resume(coroutine.create(function()
    while ultra == true do
        swait()
        root.CFrame = root.CFrame*CFrame.new(math.random(-3,3),math.random(-2,2),math.random(-3,3))
    end
    end))


        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
        for i = 1,3 do
          for i = 0, 9.14, 0.45 do
        swait()
                root.Velocity = root.CFrame.lookVector * 30
        BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-94*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      end
    
    
    for i = 1,3 do
              for i = 0, 11.14, 0.45 do
        swait()
        root.Velocity = root.CFrame.lookVector * 30
        BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-110*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(27), math.rad(0), math.rad(74)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-34-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      
      
      
    end
     so("http://www.roblox.com/asset/?id=197161452", char, 0.5, 0.8)
    con5:disconnect()
     
     
  end -- combo hit end
            attack = false
          ultra = false
  u:disconnect()
          
      end




-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 2
        hum.WalkSpeed = 24.82
	end
end)
mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 1
        hum.WalkSpeed = 8
	end
end)

 





mouse.Button1Down:connect(function()
 if attack==false then
                if attacktype==1 then
                        attack=true
                        attacktype=2
                        attackone()
                elseif attacktype==2 then
                        attack=true
                        attacktype=3
                        attacktwo()
                elseif attacktype==3 then
                        attack=true
                        attacktype=4
                        attackthree()
                elseif attacktype==4 then
                        attack=true
                        attacktype=1
                        attackfour()
                end
        end
end)




		  mouse.KeyDown:connect(function(key)
		if key == 'e' and attack == false and cankick == true and cooldown == false then
quickkick()
cooldown = true

coroutine.resume(coroutine.create(function()
    wait(2)
cooldown = false
end))



		end
		end)








mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 't' then
			Taunt()
		elseif key == 'f' then
			Hyperkickcombo()
					elseif key == 'r' then
			Galekicks()
		end
	end
end)

-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
print("By Makhail07 and KillerDarkness0105")
print("Basic Animations by Makhail07")
print("Attack Animations by KillerDarkness0105")
print("This is pretty much our final script together")
print("--------------------------------")
print("Attacks")
print("E in air: Quick Kicks")
print("Left Mouse: 4 click combo")
print("F: Hyper Kicks")
print("R: Gale Kicks, Spam R if your combo is over 150 to do an ultra combo")
print("--------------------------------")
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	
	if hitfloor == nil then
	    cankick = true
    else
        cankick = false
        end
	
	
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(20)), 0.1)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-6.5 * Sin(sine / 12)), Rad(0), Rad(-20)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(110), Rad(6 + 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.3* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(110), Rad(6 - 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
			end
		elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-1), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-15 - 15 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 15 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(56)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-56)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
			end
		elseif torvel >= 22 and hitfloor ~= nil then
			Anim = "Sprint"
			change = 1.35
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-8.5 - 2 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
			RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         	LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65) , Rad(0), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65)  , Rad(0) ,	Rad(-13) + la.RotVelocity.Y / 75), 0.15)
			end
		end
	end
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 0.7
	Music.Parent = tors
	Music:Resume()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end 
local basetpart = game.workspace.non:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end  
end





if string.sub(msg, 1, 7) == (prefix.."insane") then
       

Bypass = "death"
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
        sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
    end
end)

loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(5)


Ply = game.Players.LocalPlayer
--FIXED WITH TRIGECTORY's CheatSheet--
cheatsheetplr = game.Players.LocalPlayer
i = Instance.new("NumberValue", cheatsheetplr )
i.Name = "FPSCH"
Bin = Instance.new("HopperBin", cheatsheetplr .Backpack)
script.Parent = Bin
local cf = CFrame.new
local function Create(A)
local A = Instance.new(A)
return function(B)
for i,v in pairs(B) do
A[i] = v
end
return A
end
end
RW = Create("Weld")({Name = "Right Shoulder", Part0 = Tor, C0 = CFrame.new(1.5, 0.5, 0), C1 = CFrame.new(0, 0.5, 

0), Part1 = RA, Parent = Tor})
LW = Create("Weld")({Name = "Left Shoulder", Part0 = Tor, C0 = CFrame.new(-1.5, 0.5, 0), C1 = CFrame.new(0, 0.5, 

0), Part1 = LA, Parent = Tor})
wait(.05)
--Saz

debounce=true
etime=0
etimem=20
down=false

vPlayer=game.Players.LocalPlayer
cPlayer=nil
Humanoid=nil

Welds={}

stopVictoly=function()
	
	for _,v in pairs(Welds) do
		v.Parent = cPlayer.Torso
	end
	
	wait(.2)
	
	g1:Remove() g2:Remove() g3:Remove() g4:Remove() g5:Remove()
	
	b1:Remove() b2:Remove()
	
	p1:Remove() p2:Remove()
	
	bpos:Remove()
	brot:Remove()
	
	Head.Anchored=false
	
	Humanoid.PlatformStand=false
	
end
startVictoly=function()
	
	Welds={}

	cPlayer=workspace.non
	Humanoid = nil
	for _,v in pairs(cPlayer:children()) do
		if v.className=="Humanoid" then
			Humanoid=v
		end
		if v.Name=="Torso" then
			for __,vv in pairs(v:children()) do
				if vv:IsA("JointInstance") then
					table.insert(Welds,vv)
				end
			end
		end
	end
	
	Torso = cPlayer.Torso
	Head = cPlayer.Head
	RightArm = cPlayer["Right Arm"]
	LeftArm = cPlayer["Left Arm"]
	RightLeg = cPlayer["Right Leg"]
	LeftLeg = cPlayer["Left Leg"]
	
	Head.Anchored=true
	
	headpos = Head.CFrame.p
	
	print("noob")
	
	Humanoid.PlatformStand=true
	
	Torso.Anchored=true
	
	p1=Instance.new("Part",cPlayer)
	p1.Anchored=true
	p1.formFactor="Custom"
	p1.Size=Vector3.new(1,1,1)
	p1.TopSurface=0
	p1.BottomSurface=0
	p1.CanCollide=false
	p1.Name="AnchorR"
	p1.CFrame = Torso.CFrame * CFrame.new(.5,-3.5,0)
	p1.Transparency=1
	
	p2=Instance.new("Part",cPlayer)
	p2.Anchored=true
	p2.formFactor="Custom"
	p2.Size=Vector3.new(1,1,1)
	p2.TopSurface=0
	p2.BottomSurface=0
	p2.CanCollide=false
	p2.Name="AnchorL"
	p2.CFrame = Torso.CFrame * CFrame.new(-.5,-3.5,0)
	p2.Transparency=1
	
	g1=Instance.new("Glue",RightLeg)
	g1.Part0 = Torso
	g1.Part1 = RightLeg
	g1.C0 = CFrame.new(.5,-2,0)
	g1.C1 = CFrame.new(0,0,0)
	g1.F0 = Vector3.new(0,1,0)
	g1.F1 = Vector3.new(0,1,0)
	g1.F2 = Vector3.new(0,1,0)
	g1.F3 = Vector3.new(0,1,0)
	
	g2=Instance.new("Glue",p1)
	g2.Part0 = p1
	g2.Part1 = RightLeg
	g2.C0 = CFrame.new(0,1.5,0)
	g2.C1 = CFrame.new(0,0,0)
	g2.F0 = Vector3.new(.25,-1,.25)
	g2.F1 = Vector3.new(.25,-1,-.25)
	g2.F2 = Vector3.new(-.25,-1,.25)
	g2.F3 = Vector3.new(-.25,-1,-.25)
	
	g3=Instance.new("Glue",LeftLeg)
	g3.Part0 = Torso
	g3.Part1 = LeftLeg
	g3.C0 = CFrame.new(-.5,-2,0)
	g3.C1 = CFrame.new(0,0,0)
	g3.F0 = Vector3.new(0,1,0)
	g3.F1 = Vector3.new(0,1,0)
	g3.F2 = Vector3.new(0,1,0)
	g3.F3 = Vector3.new(0,1,0)
	
	g4=Instance.new("Glue",p2)
	g4.Part0 = p2
	g4.Part1 = LeftLeg
	g4.C0 = CFrame.new(0,1.5,0)
	g4.C1 = CFrame.new(0,0,0)
	g4.F0 = Vector3.new(.25,-1,.25)
	g4.F1 = Vector3.new(.25,-1,-.25)
	g4.F2 = Vector3.new(-.25,-1,.25)
	g4.F3 = Vector3.new(-.25,-1,-.25)
	
	g5=Instance.new("Glue",Torso)
	g5.Part0 = Head
	g5.Part1 = Torso
	g5.C0 = CFrame.new(0,0,0)
	g5.C1 = CFrame.new(0,1.5,0)
	g5.F0 = Vector3.new(0,0,0)
	g5.F1 = Vector3.new(0,0,0)
	g5.F2 = Vector3.new(0,0,0)
	g5.F3 = Vector3.new(0,0,0)
	
	for _,v in pairs(Welds) do
		if v.Name~="Neck" then
			print(v.Name)
			v.Parent = nil
			if v.Name=="Right Shoulder" then
				RSC0 = v.C0
				RSC1 = v.C1
			elseif v.Name=="Left Shoulder" then
				LSC0 = v.C0
				LSC1 = v.C1				
			end
		end
	end
	
	b1=Instance.new("Motor6D",RightArm)
	b1.Part0 = Torso
	b1.Part1 = RightArm
	b1.C0 = RSC0
	b1.C1 = RSC1 * CFrame.new(0,.25,0)
	
	b2=Instance.new("Motor6D",LeftArm)
	b2.Part0 = Torso
	b2.Part1 = LeftArm
	b2.C0 = LSC0
	b2.C1 = LSC1 * CFrame.new(0,.25,0)
	
	pos=Torso.Position
	brot=Instance.new("BodyAngularVelocity",Torso)
	brot.P=2250
	brot.maxTorque=Vector3.new(8000000,8000000,8000000)
	bpos=Instance.new("BodyPosition",Torso)
	bpos.P=4250
	bpos.D=150
	bpos.maxForce=Vector3.new(8000000000,0,8000000000)
	bpos.position=Torso.Position
	
	Torso.RotVelocity=Vector3.new()
	Torso.Velocity=Vector3.new()
	
	
	for i=1, 5 do
		for _,v in pairs(cPlayer:children()) do
			if v:IsA("BasePart") then
				v.Velocity=Vector3.new()
				v.RotVelocity=Vector3.new()
			end
		end
		wait(.05)
	end
	
	Torso.Neck.Parent=nil
	Torso.Anchored=false
	
	ex=0
	em = 0
	elo = 0
	
	local mus = Instance.new("Sound",Torso)
	mus.Volume = 1
	mus.SoundId="http://www.roblox.com/asset/?id=230597205"
	mus:Play()
	
	ded=false
	
	wait()
	
	li=Instance.new("PointLight",Torso)
	li.Range=25
	li.Brightness=5
	li.Shadows=true
	
	pos=Torso.CFrame
	
	while down do
		game:GetService("RunService").Heartbeat:wait()
		em = em+1
		elo = elo+1
		if em == 11 then
			brot.angularvelocity=Vector3.new(math.random(-26,26),math.random(-20,20)/6,math.random(-26,26)/2)
			bpos.position = (pos * CFrame.new(math.random(-20,20)/10,0,math.random(-20,20)/20)).p
			em = math.random(0,4)
			li.Color=Color3.new(math.random(100,255)/255,math.random(100,255)/255,math.random(100,255)/255)
		end
		
		b1.C0 = RSC0 * CFrame.new(math.cos(math.rad(elo*15))/20,.5,math.sin(math.rad(elo*15))/30) * CFrame.Angles(math.rad(ex/8)*elo - math.pi/3,math.cos(math.rad(elo*15))/100,math.sin(elo/8)*7)
		b2.C0 = LSC0 * CFrame.new(math.cos(math.rad(elo*15))/20,.5,math.sin(math.rad(elo*15))/30) * CFrame.Angles(math.rad(-ex/8)*elo - math.pi/3,math.sin(math.rad(elo*15))/100,-math.cos(elo/8)*7)
		
		ex = ex + math.random(-5,5)/5
		if ex > 50 then
			ex = 50
		elseif ex < 10 then
			ex = 20
		end
		
		if elo > 15 then
		
			if g1.Parent==nil or g2.Parent==nil or g3.Parent==nil or g4.Parent==nil or g5.Parent==nil or Humanoid.Health <= 0 then
				ded = true
				break
			end
			if g1.Part0==nil or g2.Part0==nil or g3.Part0==nil or g4.Part0==nil or g5.Part0==nil then
				ded = true
				break
			end
			if RightArm.Parent == nil or LeftArm.Parent == nil or LeftLeg.Parent==nil or RightLeg.Parent==nil then
				ded=true
				break
			end
		
		end
		
	end
	
	li:Remove()
	
	mus:Stop()
	
	if ded then
		Head.Anchored=false
		
		for _,v in pairs(cPlayer:children()) do
			if v:IsA("BasePart") then
				v:BreakJoints()
				v.CFrame = CFrame.new(Torso.Position + Vector3.new(math.random(-2,2),math.random(-1,2),math.random(-2,2))) * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				v.Velocity=Vector3.new(0,0,0)
			end
		end
		
		e=Instance.new("Explosion",workspace)
		e.BlastRadius=10
		e.BlastPressure=0
		e.Position=Torso.Position
		e.Hit:connect(function(hit) if hit.Parent == cPlayer and hit.Name~="AnchorR" and hit.Name~="AnchorL" then if hit:FindFirstChild("Fire") == nil then Instance.new("Fire",hit) end hit:BreakJoints() hit.Velocity = (e.Position - hit.Position).unit * 80 hit.RotVelocity = hit.Velocity end end)
		
		s=Instance.new("Sound",Head)
		s.SoundId="http://www.roblox.com/asset/?id=230597277"
		s.Volume=1
		s:Play()
		
		s=Instance.new("Sound",p1)
		s.SoundId="http://www.roblox.com/asset/?id=221920821"
		s.Volume=1
		s.Pitch=1.25
		s:Play()
	end
	
	wait(.5)
	mus:Remove()
	
end

onEquip=function(mouse)
	mouse.Button1Down:connect(function() down=true startVictoly() end)
	mouse.Button1Up:connect(function() down=false stopVictoly() end)
end
script.Parent.Selected:connect(onEquip)
local basetpart = game.Players.Character:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
  sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
  end

end




if string.sub(msg, 1, 7) == (prefix.."billie") then
       spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)

function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end


loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(1)

-- nebula's ezconvert
--[[
PUT YOUR SCRIPTS BELOW HERE VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV	
]]
local plr = game:GetService("Players").LocalPlayer
local char = workspace.non
if char:FindFirstChild("Animate") then
	char.Animate:Destroy()
end
local hum = char:FindFirstChildOfClass("Humanoid")
local tors = char.Torso
local head = char.Head
local rootpart = char.HumanoidRootPart
local RS = tors["Right Shoulder"]
local LS = tors["Left Shoulder"]
local RH = tors["Right Hip"]
local LH = tors["Left Hip"]
local neck = tors.Neck
local rootj = rootpart.RootJoint
local RSnor = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
local LSnor = CFrame.new(-1, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
local RHnor = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
local LHnor = CFrame.new(-1, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
local necknor = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local rootjnor = CFrame.new(0, 0, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local sine = 0
local music = Instance.new("Sound")
music.Parent = tors
local timepos = 0
local attack = false
local rooted = false
local playing = true
local speed = 16
local nokill = {
	"mrfunnylaughs4",
	"v_Sado"
}
local wig = Instance.new("Part")
wig.Size = Vector3.new(1.4, 1.99, 0.84)
wig.Parent = head
local mesh = Instance.new("SpecialMesh")
mesh.MeshType = Enum.MeshType.FileMesh
mesh.MeshId = "rbxassetid://952995462"
mesh.Scale = Vector3.new(1.44, 1.4, 1.22)
mesh.TextureId = "rbxassetid://949743130"
mesh.VertexColor = Vector3.new(1, 0.839, 0.73)
mesh.Parent = wig
local weld = Instance.new("Weld")
weld.Part0 = wig
weld.Part1 = head
weld.C1 = CFrame.new(0, -0.8, 0.25)
weld.Parent = wig
local rem = Instance.new("RemoteEvent")
rem.Name = "Events"
--[[
local Player = game:GetService("Players").LocalPlayer
    local Event = script:WaitForChild("UserInput_Event")
 
    local Mouse = Player:GetMouse()
    local UIS = game:GetService("UserInputService")
    local input = function(io,a)
        if a then return end
        --Since InputObject is a client-side instance, we create and pass table instead
        Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState,Hit=Mouse.Hit,Target=Mouse.Target})
    end
    UIS.InputBegan:Connect(input)
    UIS.InputEnded:Connect(input)
 
    local h,t
    --Give the server mouse data 30 times every second, but only if the values changed
    --If player is not moving their mouse, client won't fire events
    while wait(1/30) do
        if h~=Mouse.Hit or t~=Mouse.Target then
            h,t=Mouse.Hit,Mouse.Target
            Event:FireServer({isMouse=true,Target=t,Hit=h})
        end
    ]]--,plr.Character)	
rem.OnServerEvent:Connect(function(player, key)
	if player == plr then
		if attack == false then
			if key == "t" then
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://145757437"
				sound.Volume = 10
				sound.Parent = head
				local effect = Instance.new("PitchShiftSoundEffect")
				effect.Octave = 1.75
				effect.Parent = sound
				sound:Play()
				for i = 1, 120 do
					game:GetService("RunService").Stepped:Wait()
					head.Size = Vector3.new(2 + 1 * math.sin(sine / 5), 1 + 1 * math.sin(sine / 5), 1 + 1 * math.sin(sine / 5)) 
					neck.C0 = necknor * CFrame.new(0, 0, math.sin(sine / 5))
				end
				head.Size = Vector3.new(2, 1, 1)
			end
			if key == "r" then
				attack = true
				rooted = true
				playing = false
				local scream = Instance.new("Sound")
				scream.SoundId = "rbxassetid://176238381"
				scream.Parent = head
				scream:Play()
				repeat
					game:GetService("RunService").Stepped:Wait()
					RS.C0 = RSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					LS.C0 = LSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					RH.C0 = RHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					LH.C0 = LHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					rootj.C0 = rootjnor * CFrame.new(0, 0, 3 * math.sin(sine / 2)) * CFrame.Angles(sine / 2, 0, 0)
					neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
				until scream.Playing == false
				scream:Destroy()
				rooted = false
				if math.random(1, 3) == 1 then
					local sound = Instance.new("Sound")
					sound.SoundId = "rbxassetid://2878822762"
					sound.Volume = 10
					sound.PlaybackSpeed = 2
					sound.Parent = head
					sound:Play()
					repeat
						game:GetService("RunService").Stepped:Wait()
						head.Size = Vector3.new(2 + 1 * math.sin(sine / 2), 1 + 1 * math.sin(sine / 2), 1 + 1 * math.sin(sine / 2)) 
						RS.C0 = RSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						LS.C0 = LSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						RH.C0 = RHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						LH.C0 = LHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						rootj.C0 = rootjnor
						neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					until sound.Playing == false
					head.Size = Vector3.new(2, 1, 1)
				end
				playing = true
				attack = false
			end
			if key == "y" then
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://3475233802"
				sound.Volume = 10
				sound.Parent = head
				sound:Play()
				local thing = head.Touched:Connect(function(hit)
					local found = false
					for i,v in pairs(nokill) do
						if game:GetService("Players"):FindFirstChild(v) then
							if hit:IsDescendantOf(game:GetService("Players")[v].Character) then
								found = true
							end
						end
					end
					if found == false and hit.Size.Magnitude < 300 then
						local parent = hit.Parent
						hit.Parent = nil
						wait(math.random(20, 50) / 10)
						hit.Anchored = false
						hit.BrickColor = BrickColor.new("Bright green")
						hit.CFrame = head.CFrame
						hit.Velocity = head.CFrame.LookVector * 150
						hit.Parent = parent
						local sound = Instance.new("Sound")
						sound.SoundId = "rbxassetid://704088758"
						sound.Volume = 10
						sound.Parent = head
						sound:Play()
					end
				end)
				for i = 1, 180 do
					game:GetService("RunService").Stepped:Wait()
					head.Size = Vector3.new(20, 10, 10)
					neck.C0 = necknor * CFrame.new(0, -10, 0)
				end
				thing:Disconnect()
				head.Size = Vector3.new(2, 1, 1)
			end
			if key == "p" then
				attack = true
				playing = false
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://2533880583"
				sound.Volume = 3
				sound.TimePosition = 20.15
				sound.Parent = head
				sound:Play()
				wig.Parent = nil
				local hat = Instance.new("Part")
				hat.Name = "JevilHat"
				hat.CanCollide = false
				hat.Size = Vector3.new(1, 1, 1)
				hat.Parent = char
				local mesh = Instance.new("SpecialMesh")
				mesh.MeshType = Enum.MeshType.FileMesh
				mesh.MeshId = "rbxassetid://193760002"
				mesh.TextureId = "rbxassetid://193760041"
				mesh.VertexColor = Vector3.new(0.5, 0, 0.5)
				mesh.Parent = hat
				local weld = Instance.new("Weld")
				weld.Part0 = head
				weld.Part1 = hat
				weld.C0 = CFrame.new(0, 0.5, 0.31)
				weld.Parent = hat
				for i,v in pairs(head:GetChildren()) do
					if v:IsA("Decal") then
						local old = v.Texture
						v.Texture = "rbxassetid://241553801"
						coroutine.resume(coroutine.create(function()
							repeat game:GetService("RunService").Stepped:Wait() until sound.Playing == false or sound.TimePosition > 30.35
							v.Texture = old
						end))
					end
				end
				local anything = Instance.new("Sound")
				anything.SoundId = "rbxassetid://2544975373"
				anything.Volume = 10
				anything.Parent = head
				anything:Play()
				speed = 50
				repeat
					game:GetService("RunService").Stepped:Wait()
					RS.C0 = RSnor * CFrame.Angles(0, 0, math.pi / 2 - 1 * math.sin(sine / 3))
					LS.C0 = LSnor * CFrame.Angles(0, 0, -math.pi / 2 + 1 * math.sin(sine / 3))
					RH.C0 = RHnor
					LH.C0 = LHnor
					rootj.C0 = rootjnor
					neck.C0 = necknor
				until sound.Playing == false or sound.TimePosition > 30.35
				speed = 16
				hat:Destroy()
				wig.Parent = head
				sound:Destroy()
				playing = true
				attack = false
			end
			if key == "f" then
				attack = true
				playing = false
				speed = 150
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://2259766079"
				sound.Volume = 10
				sound.Parent = head
				sound:Play()
				local timepos = 0
				local thing = 1
				repeat
					game:GetService("RunService").Stepped:Wait()
					if sound.Parent ~= head then
						local sound = Instance.new("Sound")
						sound.TimePosition = timepos
						sound.Parent = head
					end
					sound.Volume = 10
					sound.PlaybackSpeed = 1
					sound.Playing = true
					timepos = sound.TimePosition
					RS.C0 = RSnor * CFrame.Angles(0, 0, math.pi / 2 - 1 * math.sin(sine / (15 / thing)))
					LS.C0 = LSnor * CFrame.Angles(0, 0, -math.pi / 2 + 1 * math.sin(sine / (15 / thing)))
					RH.C0 = RHnor
					LH.C0 = LHnor
					rootj.C0 = rootjnor
					neck.C0 = necknor
					thing = thing + 0.005
				until sound.Playing == false or sound.TimePosition > 10
				local old = head.BrickColor
				repeat
					game:GetService("RunService").Stepped:Wait()
					if sound.TimePosition > 20 then
						head.BrickColor = BrickColor.new("Sunrise")
					end
					sound.PlaybackSpeed = sound.PlaybackSpeed + 0.001
					head.Size = head.Size + Vector3.new(0.01, 0.01, 0.01)
					neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
				until sound.Playing == false
				for i = 1, 20 do
					local clone = head:Clone()
					clone.Parent = workspace
					clone.Velocity = Vector3.new(0, 200, 0)
					local sound = Instance.new("Sound")
					sound.SoundId = "rbxassetid://2878822762"
					sound.Volume = 0.5
					sound.Parent = head
					sound:Play()
				end
				head.Size = Vector3.new(2, 1, 1)
				head.BrickColor = old
				speed = 16
				playing = true
				attack = false
			end
			if key == "u" then
				local part = Instance.new("Part")
				part.CFrame = rootpart.CFrame * CFrame.new(0, 0, 5)
				part.Size = Vector3.new(3, 4, 3)
				part.Parent = workspace
				local click = Instance.new("ClickDetector")
				click.Parent = part
				local mesh = Instance.new("SpecialMesh")
				mesh.MeshType = Enum.MeshType.FileMesh
				mesh.MeshId = "rbxassetid://430897733"
				mesh.Scale = Vector3.new(4, 4, 4)
				mesh.TextureId = "rbxassetid://430897961"
				mesh.Parent = part
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://741801027"
				sound.Volume = 3
				sound.Parent = part
				sound:Play()
				click.MouseClick:Connect(function()
					local banana = Instance.new("Part")
					banana.Size = Vector3.new(1, 1, 1)
					banana.CFrame = part.CFrame * CFrame.new(0, 5, 0)
					banana.Velocity = Vector3.new(math.random(-25, 25), 200, math.random(-25, 25))
					banana.Parent = workspace
					local mesh = Instance.new("SpecialMesh")
					mesh.MeshType = Enum.MeshType.FileMesh
					mesh.MeshId = "rbxassetid://28937301"
					mesh.TextureId = "rbxassetid://28937670"
					mesh.Scale = Vector3.new(0.8, 0.8, 0.8)
					mesh.Parent = banana
					local sound = Instance.new("Sound")
					sound.SoundId = "rbxassetid://28976727"
					sound.Volume = 2
					sound.Parent = banana
					sound:Play()
					local touched = false
					banana.Touched:Connect(function(hit)
						if hit.Parent and hit.Parent:FindFirstChild("Head") and not hit:IsDescendantOf(char) and touched == false then
							touched = true
							coroutine.resume(coroutine.create(function()
								for i = 1, 60 do
									game:GetService("RunService").Stepped:Wait()
									mesh.Scale = mesh.Scale + Vector3.new(0.3, 0.3, 0.3)
									banana.Size = banana.Size + Vector3.new(0.3, 0.3, 0.3)
								end
								banana:Destroy()
							end))
							local sound = Instance.new("Sound")
							sound.SoundId = "rbxassetid://168411776"
							sound.Volume = 10
							sound.Parent = hit.Parent.Head
							sound:Play()
						end
					end)
				end)
				repeat game:GetService("RunService").Stepped:Wait() until sound.Playing == false
				part:Destroy()
			end
		end
	end
end)
while game:GetService("RunService").Stepped:Wait() do
	sine = sine + 1
	if attack then 
		if rooted then
			hum.WalkSpeed = 0
			hum.JumpPower = 0
		else
			hum.WalkSpeed = speed
			hum.JumpPower = 50
		end
	else
		hum.WalkSpeed = 16
		hum.JumpPower = 50
	end
	for i,v in pairs(char:GetChildren()) do
		if v:IsA("Accessory") then
			v:Destroy()
		end
	end
	if music.Parent ~= tors then
		music = Instance.new("Sound")
		music.Parent = tors
		music.TimePosition = timepos
	else
		timepos = music.TimePosition
	end
	music.PlaybackSpeed = 0.84
	music.Volume = 1
	music.SoundId = "rbxassetid://3015811673"
	music.Playing = playing
	local torsvel = (tors.Velocity * Vector3.new(1, 0, 1)).Magnitude
	local hitfloor = workspace:FindPartOnRay(Ray.new(char.HumanoidRootPart.CFrame.Position, ((CFrame.new(char.HumanoidRootPart.Position, char.HumanoidRootPart.Position - Vector3.new(0, 1, 0))).LookVector).Unit * 4), char)
	if attack == false then
		if torsvel < 1 and hitfloor then
			RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(0, 0, math.pi / 2 + 0.3 * math.cos(sine / 7) + 0.5 * math.sin(sine / 14)), 0.15)
			LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(0, 0, 0.5 + 0.2 * math.sin(sine / 7) + 0.15 * math.cos(sine / 14)), 0.15)
			RH.C0 = RH.C0:Lerp(RHnor * CFrame.Angles(0, 0, -0.5 + 1 * math.sin(sine / 14) - 0.5 * math.cos(sine / 28)), 0.15)
			LH.C0 = LH.C0:Lerp(LHnor * CFrame.new(0.1 * math.sin(sine / 3.5) + 0.2 * math.cos(sine / 14), 0, 0) * CFrame.Angles(0, 0.2 * math.cos(sine / 28) - 0.3 * math.sin(sine / 48) + 0.15 * math.cos(sine / 3.5) - 0.25 * math.sin(sine / 3.5), -0.1 * math.sin(sine / 3.5) - 0.2 * math.cos(sine / 14)), 0.15)
			rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.new(0, 0, 0.3 * math.cos(sine / 4.5)), 0.15)
			neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(math.sin(sine / 10), math.cos(sine / 10), 0), 0.15)
		end
		if torsvel > 1 and hitfloor then
			RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(0, sine / 5, -1 * math.sin(sine / 7)), 0.15)
			LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(0, sine / 5, -1 * math.sin(sine / 7)), 0.15)
			RH.C0 = RH.C0:Lerp(RHnor * CFrame.new(1 * math.cos(sine / 7), 0.15 + 0.5 * math.cos(sine / 7), 0) * CFrame.Angles(0, 0.3 * math.sin(sine / 7), -0.23 + 1 * math.sin(sine / 7)), 0.15)
			LH.C0 = LH.C0:Lerp(LHnor * CFrame.new(1 * math.cos(sine / 7), 0.15 - 0.5 * math.cos(sine / 7), 0) * CFrame.Angles(0, 0.3 * math.sin(sine / 7), 0.23 + 1 * math.sin(sine / 7)), 0.15)
			rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.new(0, 0, -0.1 + 0.2 * math.cos(sine / 3.5)) * CFrame.Angles(0.2 - 0.4 * math.sin(sine / 3.5), rootpart.RotVelocity.Y / 50, -0.3 * math.sin(sine / 7)), 0.15)
			neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(0.4 * math.sin(sine / 3.5), 0, -head.RotVelocity.Y / 15 + 0.3 * math.sin(sine / 7)), 0.15)
		end
		if not hitfloor then
			RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(math.clamp(tors.Velocity.Y / 200 - 0.3, -hum.JumpPower / 200 - 0.3, hum.JumpPower / 200 - 0.3), 0, math.pi / 1.5), 0.15)
			LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(math.clamp(tors.Velocity.Y / 200 - 0.3, -hum.JumpPower / 200 - 0.3, hum.JumpPower / 200 - 0.3), 0, -math.pi / 1.5), 0.15)
			RH.C0 = RH.C0:Lerp(RHnor + Vector3.new(0, -0.6, 0.4), 0.15)
			LH.C0 = LH.C0:Lerp(LHnor * CFrame.Angles(0, 0, -0.3) + Vector3.new(0, -0.1, 0), 0.15)
			rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.Angles(-math.clamp(tors.Velocity.Y / 100, -hum.JumpPower / 100, hum.JumpPower / 100), 0, 0), 0.15)
			neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(math.random(-100, 100) / 1000, math.random(-100, 100) / 1000, math.random(-100, 100) / 1000), 0.15)
		end
	end
end

end

if string.sub(msg, 1, 4) == (prefix.."rpg") then
    
--//====================================================\\--
--||                       BASIS
--\\====================================================//--


 sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
       --sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


local rpg = game.Players.LocalPlayer.Character["Back Attack Missle Launcher"].Handle
rpg.AccessoryWeld:Destroy()



local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = rpg
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true


attachment0.CFrame = CFrame.new(1.8,.5,-.3)
attachment1.CFrame = CFrame.Angles(.4,5,20) 

loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(1)




local MODULE = script
local CHARACTER = workspace.non
local PLAYER = game:GetService("Players"):GetPlayerFromCharacter(CHARACTER)
local HUM = CHARACTER.Humanoid
--local REMOTE = MODULE.Event
local ROOT = HUM.Torso
local HEAD = CHARACTER.Head
local TORSO = CHARACTER.Torso
local RIGHTARM = CHARACTER["Right Arm"]
local LEFTARM = CHARACTER["Left Arm"]
local RIGHTLEG = CHARACTER["Right Leg"]
local LEFTLEG = CHARACTER["Left Leg"]
local ROOTJOINT = ROOT["RootJoint"]
local NECK = TORSO["Neck"]
local RIGHTSHOULDER = TORSO["Right Shoulder"]
local LEFTSHOULDER = TORSO["Left Shoulder"]
local RIGHTHIP = TORSO["Right Hip"]
local LEFTHIP = TORSO["Left Hip"]
local MOUSEPOS = ROOT.Position
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor


--//====================================================\\--
--||                  BACKGROUND VALUES
--\\====================================================//--
local ANIM_SPEED = 3
local MOUSE = game.Players.LocalPlayer:GetMouse()
local Mouse = game.Players.LocalPlayer:GetMouse()
local MOUSEPOS = Mouse.Hit.p
local FRAME_SPEED = 1 / 60 -- (1 / 30) OR (1 / 60)
local CHANGE = 2 / ANIM_SPEED
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local KEYHOLD = false
local MOUSEHOLD = false
local SINE = 0
local ATTACKING = false
local Debris = game:GetService("Debris")
local Effects = IT("Folder",CHARACTER)
Effects.Name = "FXFolder"
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local BGM = 213546066
local BOMB = 2671146857
local STORED = 9999999999999
--//====================================================\\--
--||                     HEARTBEAT
--\\====================================================//--
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = FRAME_SPEED
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end
--//====================================================\\--
--||                       CLERP
--\\====================================================//--
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
--//====================================================\\--
--||                     FUNCTIONS
--\\====================================================//--
function WeldParts(A,B)
	local WLD = IT("ManualWeld")
	WLD.Part0 = A
	WLD.Part1 = B
	WLD.C1 = B.CFrame:inverse() * A.CFrame
	WLD.Parent = A
	return WLD
end
--NewSound({ID = 0,PARENT = ROOT,VOLUME = 0.5,PITCH = 1,LOOP = false,MAXDISTANCE = 1000,EMITTERSIZE = 10,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
function NewSound(TABLE)
	local ID = "rbxassetid://"..(TABLE.ID or 0)
	local PARENT = (TABLE.PARENT or ROOT)
	local VOLUME = (TABLE.VOLUME or 0.5)
	local PITCH = (TABLE.PITCH or 1)
	local LOOP = (TABLE.LOOP or false)
	local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
	local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
	local PLAYING = (TABLE.PLAYING or true)
	local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
	local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
	if ID ~= "rbxassetid://0" then
		local SOUND = IT("Sound",PARENT)
		SOUND.SoundId = ID
		SOUND.Volume = VOLUME
		SOUND.Pitch = PITCH
		SOUND.Looped = LOOP
		SOUND.MaxDistance = MAXDISTANCE
		SOUND.EmitterSize = EMITTERSIZE
		SOUND.PlayOnRemove = PLAYONREMOVE
		if DOESDEBRIS == true and PLAYING == true and LOOP == false then
			Debris:AddItem(SOUND,SOUND.TimeLength+5)
		end
		if PLAYING == true then
			SOUND:Play()
		end
		return SOUND
	end
end
function ManSlaughter(MAN)
	if MAN then
		local ROOT = MAN:FindFirstChild("HumanoidRootPart")
		if ROOT then
			ROOT:Remove()
		end
		local MANHUM = MAN:FindFirstChildOfClass("Humanoid")
		if MANHUM then
			MANHUM.BreakJointsOnDeath = false
			MANHUM.Health = 0
		end
		if MAN:FindFirstChild("R6Ragdoll") == nil and MAN:FindFirstChild("R15Ragdoll") == nil then
			if MAN:FindFirstChild("UpperTorso") then
				local SCRIPT = script.R15Ragdoll:Clone()
				SCRIPT.Parent = MAN
				SCRIPT.Disabled = false
			else
				local SCRIPT = script.R6Ragdoll:Clone()
				SCRIPT.Parent = MAN
				SCRIPT.Disabled = false
			end
			local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
			if TORSO then
				NewSound({ID = 146594648,PARENT = TORSO,VOLUME = 1,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 75,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
			end
		end
		MAN:BreakJoints()
		if MAN:FindFirstChild("Slaughtered") == nil then
			local MARK = IT("Folder",MAN)
			MARK.Name = "Slaughtered"
		else
			if MAN:FindFirstChild("Slaughtered") then
				local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
				if TORSO then
					TORSO.RotVelocity = VT(0,MRANDOM(-25,25),0)
				end
			end
		end
	end
end
function AreaOfEffect(AREA,RANGE,FLING,RETURN)
	local HIT = {}
	for index, CHILD in pairs(workspace:GetChildren()) do
		if CHILD:FindFirstChildOfClass("Humanoid") then
			local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
			local ROOT = HUMAN.Torso
			if ROOT then
				if (ROOT.Position - AREA).Magnitude <= RANGE then
					if RETURN == true then
						if CHILD ~= CHARACTER then
							table.insert(HIT,{CHILD,HUMAN,ROOT})
						end
					else
						if CHILD ~= CHARACTER then
							ManSlaughter(CHILD)
						end
						local BV = IT("BodyVelocity")
						BV.MaxForce = BV.MaxForce * 500
						BV.Velocity = CF(AREA,ROOT.Position+VT(0,0.5,0)).lookVector*FLING
						BV.Parent = ROOT
						Debris:AddItem(BV,0.05)
					end
				end
			end
		end
	end
	if RETURN == true then
		return HIT
	end
end
function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = ROOT.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end
function CameraShake(AREA,RANGE,SHAKE,TIMER)
	for index, CHILD in pairs(workspace:GetChildren()) do
		if CHILD:FindFirstChildOfClass("Humanoid") then
			local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
			local ROOT = HUMAN.Torso
			if ROOT and game.Players:GetPlayerFromCharacter(CHILD) then
				if (ROOT.Position - AREA).Magnitude <= RANGE then
					if CHILD:FindFirstChild("CamShake") then
						Debris:AddItem(CHILD:FindFirstChild("CamShake"),0.05)
					end
					local CAMSHAKE = script.CamShake:Clone()
					CAMSHAKE.Parent = CHILD
					local TIMER_V = IT("NumberValue",CAMSHAKE)
					TIMER_V.Name = "Timer"
					TIMER_V.Value = TIMER
					local SHAKE_V = IT("NumberValue",CAMSHAKE)
					SHAKE_V.Name = "Shake"
					SHAKE_V.Value = SHAKE
					CAMSHAKE.Disabled = false
					Debris:AddItem(CAMSHAKE,15)
				end
			end
		end
	end
end
--//====================================================\\--
--||                     CHARACTER
--\\====================================================//--

for index, CHILD in pairs(CHARACTER:GetChildren()) do
	if CHILD ~= ROOT then
		if CHILD:IsA("Accessory") then
			CHILD:Remove()
		end
	end
end
local FACE = HEAD.face
FACE.Texture = "rbxassetid://559113097"
--HELMET.CFrame = HEAD.CFrame*CF(0,0.5,0)
--HELMET.Anchored = false
--WeldParts(HEAD,HELMET)
--local BAZOOKA = MODULE.Bazooka
--.Parent = CHARACTER
--BAZOOKA.Anchored = false
--local GRIP = IT("Motor6D")
--GRIP.Part0 = RIGHTARM
--GRIP.Part1 = BAZOOKA
--GRIP.C0 = CF(0,-1,-0.5)*ANGLES(RAD(-90),0,0)*CF(0,0,1.85)
--local G_C0 = GRIP.C0
--GRIP.Parent = RIGHTARM
for i = 1, 15 do
	local FACE = CreatePart(3, CHARACTER, "Fabric", 0, 0+(i-1)/15.2, "Dark stone grey", "FaceGradient", VT(1.01,0.58,1.01),false)
	FACE.Color = C3(0,0,0)
	HEAD:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
	FACE.CFrame = HEAD.CFrame*CF(0,0.3-(i-1)/35,0)
	WeldParts(HEAD,FACE)
end
--local MISSILE = MODULE.Missile
--MISSILE.Parent = nil

--//====================================================\\--
--||                     ABILITIES
--\\====================================================//--
function Fire_in_the_hole()
	if STORED > 0 then
		ATTACKING = true
		local GYRO = IT("BodyGyro")
		GYRO.D = 50
		GYRO.P = 5000
		GYRO.MaxTorque = VT(0,4000000,0)
		GYRO.CFrame = CF(ROOT.Position,Mouse.Hit.p)
		GYRO.Parent = ROOT
		ATTACKING = true
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				GYRO.CFrame = CF(ROOT.Position,Mouse.Hit.p)
			until ATTACKING == false
			GYRO:Remove()
		end))
		repeat
			for i=0, 0.06, 0.1 / ANIM_SPEED do
				Swait()
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
			end
		--	AddTo(-1)
			coroutine.resume(coroutine.create(function()
				local GOTO = Mouse.Hit.p
				local ROCKET = MISSILE:Clone()
				ROCKET.Parent = Effects
				ROCKET.CFrame = CF(BAZOOKA.CFrame*CF(0,0,-2).p,GOTO)
				NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				NewSound({ID = 440145223,PARENT = ROCKET,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for i = 1, 200 do
					Swait()
					local HIT,POS = Raycast(ROCKET.Position,ROCKET.CFrame.lookVector,5,CHARACTER)
					if HIT then
						ROCKET.CFrame = CF(POS)
						break
					end
					ROCKET.CFrame = ROCKET.CFrame*CF(0,0,-4)
				end
				ROCKET.Transparency = 1
				ROCKET.Hind:Remove()
				ROCKET.CFrame = CF(ROCKET.Position)
				ROCKET.Size = VT(0,0,0)
				NewSound({ID = 142070127,PARENT = ROCKET,VOLUME = 7,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 300,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for index, CHILD in pairs(script.Grenade:GetChildren()) do
					local C = CHILD:Clone()
					C.Parent = ROCKET
					C:Emit(125)
				end
				CameraShake(ROCKET.Position,50,125,70)
				AreaOfEffect(ROCKET.Position,35,200,false)
				Debris:AddItem(ROCKET,2)
			end))
			for i=0, 0.025, 0.1 / ANIM_SPEED do
				Swait()
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(200), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
			end
		until MOUSEHOLD == false or STORED <= 0
		if STORED <= 0 then
			STORED = 0
			STOREDGUI.Text = "STORED: 0"
		end
		ATTACKING = false
	end
end
function Store()
	HUM.WalkSpeed = 0
	HUM.JumpPower = 0
	ATTACKING = true
	repeat
		for i=0, 0.01, 0.1 / ANIM_SPEED do
			Swait()
	--		GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
	
		for i=0, 0.02, 0.1 / ANIM_SPEED do
			Swait()
		--	GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.675, 0.45, 0.3) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
		for i=0, 0.02, 0.1 / ANIM_SPEED do
			Swait()
		--	GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
		NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 1,PITCH = MRANDOM(9,11)/6,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		for i=0, 0.05, 0.1 / ANIM_SPEED do
			Swait()
		--	GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.75, 0.45, -0.1) * ANGLES(RAD(45), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-0.9, 0.5, -0.75) * ANGLES(RAD(60), RAD(0), RAD(37.5)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
		end
	--	ROCKET:Remove()
	--	BAZOOKA.Face.Pop:Emit(5)
	--	AddTo(1)
	until KEYHOLD == false
	ATTACKING = false
	HUM.WalkSpeed = 100
	HUM.JumpPower = 50
end
function Dance()
	HUM.WalkSpeed = 0
	HUM.JumpPower = 0
	ATTACKING = true
	local REMOVETRACK = false
	local TRACK = nil
	if ROOT:FindFirstChild("BGM_MUSIC") then
		TRACK = ROOT:FindFirstChild("BGM_MUSIC")
		TRACK.Volume = 5
	else
		TRACK = NewSound({ID = BOMB,PARENT = ROOT,VOLUME = 5,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		REMOVETRACK = true
	end
	TRACK.SoundId = "rbxassetid://"..BOMB
	TRACK:Play()
	local DONEWITHDANCING = false
	local NC = mouse.KeyDown:connect(function(key)
		key=key:lower()
		local V2 = key
		if V2 == "m" then
			DONEWITHDANCING = true
			ATTACKING = false
			if REMOVETRACK == true then
				TRACK:Remove()
			else
				TRACK:Play()
				TRACK.Volume = 1.25
				TRACK.SoundId = "rbxassetid://"..BGM
			end
		end
	end)
	local I = 0
	local RAVE = IT("PointLight",ROOT)
	RAVE.Brightness = 25
	RAVE.Color = BrickColor.random().Color
	repeat
		I = I + 2
		Swait()
		RAVE.Color = BrickColor.random().Color
		ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0 - 0.32 * SIN(I / 10), 0, -0.55 - 0.05 * COS(I / 5)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
		NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
		RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(170), RAD(10), RAD(-35 * COS(I/10)))  *CF(0,-1,0) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
		LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(170), RAD(-10), RAD(-35 * COS(I/10))) * CF(0,-1,0) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
		RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1.35, -0.475 + 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-12 - 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
		LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.35, -0.475 - 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-12 + 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
	until DONEWITHDANCING == true
	RAVE:Remove()
	NC:Disconnect()
	if REMOVETRACK == true then
		TRACK:Remove()
	else
		TRACK:Play()
		TRACK.Volume = 1.25
		TRACK.SoundId = "rbxassetid://"..BGM
	end
	ATTACKING = false
	HUM.WalkSpeed = 100
	HUM.JumpPower = 50
end
--//====================================================\\--
--||                       WRAP
--\\====================================================//--
game.Players.LocalPlayer:GetMouse().Button1Down:connect(function()
	MOUSEHOLD = true
	if ATTACKING == false then
		Fire_in_the_hole()
	end
end)
game.Players.LocalPlayer:GetMouse().Button1Up:connect(function()
	MOUSEHOLD = false
end)
game.Players.LocalPlayer:GetMouse().KeyDown:connect(function(key)
	key=key:lower()
	local V2 = key
	KEYHOLD = true
				if V2 == "z" then
					Store()
				elseif V2 == "m" then
					Dance()
				elseif V2 == "t" then
					NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				elseif V2 == "e" then
					if ROOT:FindFirstChild("BGM_MUSIC") then
						ROOT:FindFirstChild("BGM_MUSIC"):Remove()
					else
						local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						M.Name = "BGM_MUSIC"
					end
				end
end)
game.Players.LocalPlayer:GetMouse().KeyUp:connect(function()
	KEYHOLD = false
end)
--[[
REMOTE.OnServerEvent:Connect(function(PLR,V1,V2)
	if PLR == PLAYER and ANIM ~= "Sit" then
		--if V1 == "MousePositionUpdate" then
			--MOUSEPOS = V2
		if V1 == "KeyUp" then
			KEYHOLD = false
		elseif V1 == "MouseUp" then
			MOUSEHOLD = false
		end
		if ATTACKING == false then
			if V1 == "MouseDown" then
				MOUSEHOLD = true
				Fire_in_the_hole()
			elseif V1 == "KeyDown" then
				KEYHOLD = true
				if V2 == "z" then
					Store()
				elseif V2 == "m" then
					Dance()
				elseif V2 == "t" then
					NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				elseif V2 == "e" then
					if ROOT:FindFirstChild("BGM_MUSIC") then
						ROOT:FindFirstChild("BGM_MUSIC"):Remove()
					else
						local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						M.Name = "BGM_MUSIC"
					end
				end
			end
		end
	end
end)
]]--
local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
M.Name = "BGM_MUSIC"
HUM.WalkSpeed = 100
while true do
	Swait()
	local MOUSEPOS = Mouse.Hit.p
	SINE = SINE + CHANGE
	if CHARACTER:FindFirstChild("Animate") then
		CHARACTER:FindFirstChild("Animate"):Destroy()
	end
	if CHARACTER:FindFirstChild("Sound") then
		CHARACTER:FindFirstChild("Sound"):Destroy()
	end
	for _,v in next, HUM:GetPlayingAnimationTracks() do
		v:Stop();
	end
	local TORSOVELOCITY = (ROOT.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = ROOT.Velocity.y
	local HITFLOOR = Raycast(ROOT.Position, (CF(ROOT.Position, ROOT.Position + VT(0, -1, 0))).lookVector, 4+HUM.HipHeight, CHARACTER)
	local WALKSPEEDVALUE = 0.5
	local SITTING = HUM.Sit
	if ANIM == "Walk" and TORSOVELOCITY > 1 and SITTING == false then
		RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 0.875 - 0.3 * SIN(SINE / WALKSPEEDVALUE), -0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RIGHTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
		LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 0.875 + 0.3 * SIN(SINE / WALKSPEEDVALUE), 0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LEFTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) or SITTING == true then
		RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
		LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
	end
---	if ATTACKING == false then
--		GRIP.C0 = Clerp(GRIP.C0, G_C0, 1.5 / ANIM_SPEED)
--	end
	if SITTING == false then
		if HITFLOOR then
			if TORSOVELOCITY < 1 and HITFLOOR ~= nil then
				ANIM = "Idle"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 6)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(100), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25 - 2.5 * COS(SINE / 6))) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
				end
			elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
				ANIM = "Walk"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.05 + 0.05 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(135), RAD(0), RAD(5 + 2.5 * COS(SINE / WALKSPEEDVALUE))) * RIGHTSHOULDERC0, 2 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(0), RAD(-25 - 2.5 * COS(SINE / WALKSPEEDVALUE))) * LEFTSHOULDERC0, 2 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1 , -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-15)), 2 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(15)), 2 / ANIM_SPEED)
				end
			end
		else
			if TORSOVERTICALVELOCITY > 0 then
				ANIM = "Jump"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(10)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 1 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
			    end
			else
				ANIM = "Fall"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(150), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / ANIM_SPEED)
				end
			end
		end
	else
		ANIM = "Sit"
		if ATTACKING == false then
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.65, 0) * ANGLES(RAD(50), RAD(-10), RAD(45))*CF(0,-0.25,0) * LEFTSHOULDERC0, 1.25 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.25, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.25 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -0.25, -1) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1.25 / ANIM_SPEED)
		end
	end
end
local basetpart = game.workspace.non:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end

    
end

if string.sub(msg, 1, 7) == (prefix.."hammer") then
    			

Bypass = "death"
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)




local pee = game.Players.LocalPlayer.Character["MARTILLO"]
local gold = game.Players.LocalPlayer.Character["MARTILLO"].Handle
gold.AccessoryWeld:Destroy()




local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = gold
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true

attachment1.CFrame = CFrame.Angles(-25.7,5,20) 
  attachment0.CFrame = CFrame.new(1,-3,-.1)
  
  




  
  ----fling attachments
  
 
--  local toolgoflingfling = Instance.new("BodyVelocity", gold)
--toolgoflingfling.MaxForce = Vector3.new(90000,90000,90000)
--toolgoflingfling.Velocity = Vector3.new(90000,90000,90000)

  

wait(0.1)

warn([[Have fun with sangWARE!]])

--loadstring(game:GetObjects("rbxassetid://4480871791")[1].Source)()
--wait(5)

-- 5325226148
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(0.1)



playerss = workspace.non

local ToolName = pee

Bypass = "death"


local IsDead = false
local StateMover = true



Bypass = "death"
plr = game.Players.LocalPlayer
--dead = false
char = plr.Character




wait(4)




--



-- game:GetService("Workspace").GoldAxe.Handle.Rotation = Vector3.new(-0,0,-50)


 --local lol = Instance.new("Attachment",Right Arm)

--The reality of my life isn't real but a Universe -makhail07
wait()
local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name)
print('God Loaded')
print('hahahAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')
char = playerss
local hum = char.Humanoid
local hed = char.Head
local lol = Instance.new("Attachment",char["Right Arm"])
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")



function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end

function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end






-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end


function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end


local kan = Instance.new("Sound",char)
kan.Volume = 1.25
kan.TimePosition = 0
kan.PlaybackSpeed = 1
kan.Pitch = 1
kan.SoundId = "rbxassetid://853707984"
kan.Name = "wrecked"
kan.Looped = true
kan:Play()

local currentThemePlaying = kan.SoundId
local currentPitch = kan.Pitch
local currentVol = kan.Volume
function newTheme(ID,timepos,pitch,vol)
local kanz = kan
--kanz:Stop()
kanz.Volume = vol
--kanz.TimePosition = timepos
kanz.PlaybackSpeed = pitch
kanz.Pitch = pitch
kanz.SoundId = ID
kanz.Name = "wrecked"
kanz.Looped = true
currentThemePlaying = kanz.SoundId
currentVol = kanz.Volume
currentPitch = kanz.Pitch
--kanz:Play()
--coroutine.resume(coroutine.create(function()
--wait(0.05)
--end))
end

--newTheme("rbxassetid://853707984",0,1.01,0.85)

function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end


--local RbxUtility = LoadLibrary("RbxUtility")
--local Create = RbxUtility.Create

local function Create(A)
local A = Instance.new(A)
return function(B)
for i,v in pairs(B) do
A[i] = v
end
return A
end
end
-------------------------------------------------------
-----------------------hammer--------------------------
---- WEAPON OR STUFF
local rarmor = CreateParta(m,1,0,"SmoothPlastic",BrickColor.Random())
----local weaponweld = CreateWeld(rarmor,tors,rarmor,-3,0,-0.5,math.rad(0),math.rad(0),math.rad(-40),0,0,0,math.rad(0),math.rad(0),math.rad(0))
--local MainWeldS = CreateWeld(Part475,rarmor,Part475,0,0,0,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local A0 = Instance.new("Attachment",rarmor)
local A1 = Instance.new("Attachment",rarmor)
tl1 = Instance.new('Trail',rarmor)
tl1.Attachment0 = A0
tl1.Attachment1 = A1
tl1.LightEmission = 1
tl1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
tl1.Lifetime = 0.6
tl1.Enabled = false


rarmor.Attachment.Name = "Attachment2"


-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
    --    if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
 --       hit.Parent:FindFirstChild("Head"):BreakJoints()
  --     end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
   --     if insta == true then
--      hit.Parent:FindFirstChild("Head"):BreakJoints()
  --      end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:service("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end


function Eviscerate(dude)
	if dude.Name ~= char then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
	--	d//ude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
				end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
					v:Destroy()
				end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
					for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
							o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							v.Color = maincolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.08
								end
								wait(0.5)
								PartEmmit1.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
function chatfunc(text, color)
	local chat = coroutine.wrap(function()
		if char:FindFirstChild("TalkingBillBoard") ~= nil then
			char:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local naeeym2 = Instance.new("BillboardGui", char)
		naeeym2.Size = UDim2.new(0, 100, 0, 40)
		naeeym2.StudsOffset = Vector3.new(0, 5, 0)
		naeeym2.Adornee = hed
		naeeym2.Name = "TalkingBillBoard"
		local tecks2 = Instance.new("TextLabel", naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SciFi"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 0
		tecks2.TextColor3 = color
		tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
		tecks2.Size = UDim2.new(1, 0, 0.5, 0)
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
				tecks2.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
				tecks2.Rotation = math.random(-5, 5)
			end
		end))
		for i = 1, string.len(text) do
			CFuncs.Sound.Create("rbxassetid://274118116", hed, 5.25, 0.115)
			tecks2.Text = string.sub(text, 1, i)
			swait(1)
		end
		wait(1)
		naeeym2:Destroy()
	end)
	chat()
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 703597239
local SONG2 = 853707984
local Music = Instance.new("Sound",tors)
Music.Volume = 2.5
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
----------------------------------------------------------------------------------
hum.WalkSpeed = 16
hum.JumpPower = 57
hum.Animator.Parent = nil
----------------------------------------------------------------------------------
--local Blobby = Instance.new("Part", char)
--Blobby.Name = "Blob"
--Blobby.CanCollide = false
--Blobby.BrickColor = BrickColor.new("Really black")
--Blobby.Transparency = 0
--Blobby.Material = "Plastic"
--Blobby.Size = Vector3.new(1, 1, 2)
--Blobby.TopSurface = Enum.SurfaceType.Smooth
--Blobby.BottomSurface = Enum.SurfaceType.Smooth

--local Weld = Instance.new("Weld", Blobby)
--Weld.Part0 = ra
--Weld.Part1 = Blobby
--Weld.C1 = CFrame.new(0, -2, 1.1)
--Weld.C0 = CFrame.Angles(Rad(-86),0,0)

--local M2 = Instance.new("SpecialMesh")
--M2.Parent = Blobby
--M2.MeshId = "http://www.roblox.com/asset/?id=10604848"
--M2.TextureId = "http://www.roblox.com/asset/?id=10605252"
--M2.Scale = Vector3.new(1, 1, 1)

--[[local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0, 3.5, 0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"
--naeeym2.PlayerToHideFrom = Player
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Fight Me"
tecks2.Font = Enum.Font.Bodoni
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(0, 0, 0)
tecks2.TextStrokeColor3 = Color3.new(1, 1, 1)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2]]
-------------------------------------------------------
--End Customization--
-------------------------------------------------------


-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
function Ban()
	attack = true
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
 --	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 9.5)) do
--		if v:FindFirstChild("Head") then
--			Eviscerate(v)
--		end
--	end
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
	attack = false
end
function BigBan()
	attack = true
--	Weld.C0 = CFrame.Angles(Rad(-90), Rad(-25), Rad(0))
	for i = 0, 3.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-6), Rad(45)), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
 --	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 14.5)) do
--		if v:FindFirstChild("Head") then
--			Eviscerate(v)
---		end
--	end
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(75), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-6), Rad(45)), 0.2)
	end
--	Weld.C0 = CFrame.Angles(Rad(-86),0,0)
	attack = false
end
function BANN()
	attack = true
--	M2.Scale = Vector3.new(2, 2, 2)
	for i = 0, 4.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(-20)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(.6* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-.8* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(156), Rad(-.6), Rad(45)), 0.2)
	end
	Cso("147722910", char, 10, 1)
	CameraEnshaking(2, 35)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
	Effects.Ring.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0) * angles(math.rad(90), math.rad(0), math.rad(0)), 0.5, 0.5, 0.1, 2, 2, 0, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 7, 10, 15, -0.1, 15, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 6, 10, 15, -0.1, 15, 0.02)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 4, 10, 15, -0.1, 15, 0.01)
 --	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 19.5)) do
--		if v:FindFirstChild("Head") then
--			Eviscerate(v)
--		end
--	end
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
--	M2.Scale = Vector3.new(1, 1, 1)
	attack = false
end


-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------

game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(k)
   -- if string.byte(key) == 48 then
   Swing = 2
     hum.WalkSpeed = 38.82
--	end
end)
mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 1
        hum.WalkSpeed = 16
	end
end)
mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 'e' then
			BigBan()
		elseif key == 'r' then
			BANN()
		elseif key == 't' then
			Cso("1450018171", hed, 10, 1)
		end
	end
end)
mouse.Button1Down:connect(function(key)
    

    
    
	if attack == false then
		Ban()
	end
end)
 






-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		--Aura(5, 0.15, "Add", root.CFrame * CFrame.new(math.random(-5, 5), -10, math.random(-5, 5)) * CFrame.Angles(math.rad(90), 0, 0), 1.5, 1.5, 10, -0.015, maincolor, 0, "Sphere")
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(190), Rad(-.6), Rad(13)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel > 2 and torvel < 25 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(6 - 6.5 * Sin(sine / 7)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8* Player_Size - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8* Player_Size + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(190) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-37)  * Cos(sine / 7) , Rad(8 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
			end
		elseif torvel >= 25 and hitfloor ~= nil then
			Anim = "Sprint"
			change = 1.35
			if attack == false then
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
			RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925* Player_Size - 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         	LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925* Player_Size + 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(215) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-75) , Rad(8 * Cos(sine / 7)) ,	Rad(-13) + la.RotVelocity.Y / 75), 0.15)
			end
		end
	end
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 1.5
	Music.Parent = tors
	Music:Resume()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
    end

---open chat space

if string.sub(msg, 1, 8) == (prefix.."shotgun") then
    
--//====================================================\\--
--||			   CREATED BY SHACKLUSTER shotgun script
--\\====================================================//--
--repeat wait() until script:WaitForChild'Owner'.Value

wait(0.1)

Bypass = "death"
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
        sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
    end
end)




loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(1)


local shottie = workspace.non["Type-12Accessory"].Handle
shottie.AccessoryWeld:Destroy()
shottie.BodyBackAttachment:Destroy()


local righthandlo = workspace.non["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = shottie
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true


attachment0.CFrame = CFrame.new(0.3,1.9,-.1)
attachment1.CFrame = CFrame.Angles(4,1.7,-10) 
	
wait(0.2)
Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = workspace.non
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local MOUSEPOS = RootPart.Position
local TIME = 0
local sick = Instance.new("Sound",Torso)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 3
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Type = "Ban"
local reason = "Ur damn skids nigga"
local Rooted = false
local SINE = 0
local SIZE = 1
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "BanishV3Gui"
local Characterb = IT("Model")
Characterb.Name = "shackisgaylol"
local CharacterA = IT("Model")
CharacterA.Name = "shackismegagaylol"
local Effects = IT("Folder", CharacterA)
Effects.Name = "Effects"
local Effects2 = IT("Folder", Characterb)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true
local TOBANISH = {}
script.Parent = PlayerGui

--//=================================\\
--\\=================================//


--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

local BODY = {}
for _, c in pairs(Character:GetDescendants()) do
	if c:IsA("BasePart") and c.Name ~= "Handle" then
		if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency})
	elseif c:IsA("JointInstance") then
		table.insert(BODY,{c,c.Parent,nil,nil,nil})
	end
end
for e = 1, #BODY do
	if BODY[e] ~= nil then
		local STUFF = BODY[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
		if PART.ClassName == "Part" and PART ~= RootPart then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)
	end
end

function refit()
	Character.Parent = workspace
	for e = 1, #BODY do
		if BODY[e] ~= nil then
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART:IsA("BasePart") and PART ~= RootPart then
				PART.Material = MATERIAL
				PART.Color = COLOR
				PART.Transparency = TRANSPARENCY+EXTRATRANS
			end
			if PART.Parent ~= PARENT then
				Humanoid:remove()
				PART.Parent = PARENT
				Humanoid = IT("Humanoid",Character)
			end
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end


function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "White", "Trail", VT(0,0,0))
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(0.5,DIST,0.5)
	else
		TRAIL.Size = VT(0.25,DIST,0.25)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.1
		end
		TRAIL:remove()
	end))
end

function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MagicSphereCo(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MagicBlock(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "ForceField", 0, 0.5, BRICKC(COLOR), "Effect", VT(SIZE,SIZE,SIZE), true)
	local mesh = IT("BlockMesh",wave)
	wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function CreateRing(SIZE, DOESROT, ROT, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
	local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "559831844", "", SIZE, VT(0, 0, 0))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
			end
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

local DECAL = IT("Decal")
function MagicRing()
	local RING = CreatePart(3, Effects, "Granite", 0, 1, "Maroon", "MagicRing", VT(0,0,0),true)
	local MESH = IT("BlockMesh",RING)
	local BOTTOMTEXTURE = DECAL:Clone()
	BOTTOMTEXTURE.Parent = RING
	BOTTOMTEXTURE.Face = "Bottom"
	BOTTOMTEXTURE.Name = "BottomTexture"
	local TOPTEXTURE = DECAL:Clone()
	TOPTEXTURE.Parent = RING
	TOPTEXTURE.Face = "Top"
	TOPTEXTURE.Name = "TopTexture"
	BOTTOMTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	TOPTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	BOTTOMTEXTURE.Color3 = C3(0,0,0)
	TOPTEXTURE.Color3 = C3(1,1,1)
	return RING,MESH,TOPTEXTURE,BOTTOMTEXTURE
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

--function SHAKECAM(POSITION, RANGE, INTENSITY, TIME)
--	local CHILDREN = workspace:GetDescendants()
--	for index, CHILD in pairs(CHILDREN) do
--		if CHILD.ClassName == "Model" then
	--		local HUM = CHILD:FindFirstChildOfClass("Humanoid")
		--	if HUM then
		--		local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
			--	if TORSO and RANGE >= (TORSO.Position - POSITION).Magnitude then
				--	local CAMSHAKER = script.CamShake:Clone()
				--	CAMSHAKER.Shake.Value = INTENSITY
				---	CAMSHAKER.Timer.Value = TIME
				--	CAMSHAKER.Parent = CHILD
				--	CAMSHAKER.Disabled = false
			--	end
	--		end
	--	end
--	end
--nd

--//=================================\\
--||	     WEAPON CREATION
--\\=================================//

--local Shotgun = script.Shotgun:Clone()
--Shotgun.Parent = RightArm
--CreateWeld(Shotgun.Handle,RightArm,Shotgun.Handle,0.2,-0.1,0.5,math.rad(90),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local Hole = shottie

local Particle = IT("ParticleEmitter",nil)
Particle.Enabled = false
Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
Particle.LightEmission = 0.5
Particle.Rate = 150
Particle.ZOffset = 0.2
Particle.Rotation = NumberRange.new(-180, 180)
Particle.RotSpeed = NumberRange.new(-180, 180)
Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
Particle.Color = ColorSequence.new(C3(0,1,0),C3(0,1.1,0))

--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
function ParticleEmitter(Table)
	local PRTCL = Particle:Clone()
	local Speed = Table.Speed or 5
	local Drag = Table.Drag or 0
	local Size1 = Table.Size1 or 1
	local Size2 = Table.Size2 or 5
	local Lifetime1 = Table.Lifetime1 or 1
	local Lifetime2 = Table.Lifetime2 or 1.5
	local Parent = Table.Parent or Torso
	local Emit = Table.Emit or 100
	local Offset = Table.Offset or 360
	local Acel = Table.Acel or VT(0,0,0)
	local Enabled = Table.Enabled or false
	PRTCL.Parent = Parent
	PRTCL.Size = NumberSequence.new(Size1,Size2)
	PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
	PRTCL.Speed = NumberRange.new(Speed)
	PRTCL.VelocitySpread = Offset
	PRTCL.Drag = Drag
	PRTCL.Acceleration = Acel
	if Enabled == false then
		PRTCL:Emit(Emit)
		Debris:AddItem(PRTCL,Lifetime2)
	else
		PRTCL.Enabled = true
	end
	return PRTCL
end

for _, c in pairs(CharacterA:GetChildren()) do
	if c.ClassName == "Part" then
		c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	end
end

CharacterA.Parent = Character

Characterb.Parent = Character


local SKILLTEXTCOLOR = C3(1,1,1)
local SKILLFONT = ""
local SKILLTEXTSIZE = 7

Humanoid.Died:connect(function()
	ATTACK = true
end)

--[[local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.1, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.63, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.215, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.525, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")
local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 5 Frame")
]]
--[[local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Banish Bullet", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 1")
local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B] Ability 2", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 2")
local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C] Ability 3", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 3")
local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V] Ability 4", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 4")
local SKILL5TEXT = CreateLabel(SKILL5FRAME, "[X] Mercy", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 5")
]]

function chatfunc(text)
	local chat = coroutine.wrap(function()
	if Character:FindFirstChild("TalkingBillBoard")~= nil then
		Character:FindFirstChild("TalkingBillBoard"):destroy()
	end
	local Bill = Instance.new("BillboardGui",Character)
	Bill.Size = UDim2.new(0,100,0,40)
	Bill.StudsOffset = Vector3.new(0,3,0)
	Bill.Adornee = Character.Head
	Bill.Name = "TalkingBillBoard"
	local Hehe = Instance.new("TextLabel",Bill)
	Hehe.BackgroundTransparency = 1
	Hehe.BorderSizePixel = 0
	Hehe.Text = ""
	Hehe.Font = "SourceSansItalic"
	Hehe.TextSize = 40
	Hehe.TextStrokeTransparency = 0
	Hehe.Size = UDim2.new(1,0,0.5,0)
	coroutine.resume(coroutine.create(function()
		while Hehe ~= nil do
			Swait()	
			Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
			Hehe.Rotation = math.random(-5,5)
			Hehe.TextColor3 = Color3.new(0,0,0)
			Hehe.TextStrokeColor3 = Color3.new(1,1,1)
		end
	end))
	for i = 1,string.len(text),1 do
		Swait()
		Hehe.Text = string.sub(text,1,i)
	end
	Swait(90)--Re[math.random(1, 93)]
	for i = 0, 1, .025 do
		Swait()
		Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
		Hehe.TextStrokeTransparency = i
		Hehe.TextTransparency = i
	end
	Bill:Destroy()
	end)
chat()
end

function onChatted(msg)
	chatfunc(msg)
end

Player.Chatted:connect(onChatted)

function printbye(Name)
	local MESSAGES = {"You cannot struggle, ","Your existance is an insult, ","Fade, ","Your existance is not desired, ","You are not permitted here, ","You are not to decide your fate, ","Be gone, ","You are already dead, ","Your live is an anomaly, ","Don't dare to return, ","Why are you resisting, ","You cannot exist here, ","Why are you struggling, ","Your fate was already decided, ","Goodbye, ","You cannot ignore my command, ","You cannot resist my command, ","You already died, "}
	chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
end

workspace.ChildAdded:connect(function(instance)
    for BANISH = 1, #TOBANISH do
		if TOBANISH[BANISH] ~= nil then
			if instance.Name == TOBANISH[BANISH] then
				coroutine.resume(coroutine.create(function()
					printbye(instance.Name)
					instance:ClearAllChildren()
					Debris:AddItem(instance,0.0005)
				end))
			end
		end
	end
end)

--//=================================\\
--||			DAMAGING
--\\=================================//

function Banish(Foe)
	if Foe then
		coroutine.resume(coroutine.create(function()
			--if game.Players:FindFirstChild(Foe.Name) then
				table.insert(TOBANISH,Foe.Name)
				printbye(Foe.Name)
			--end
			Foe.Archivable = true
			local CLONE = Foe:Clone()
			Foe:Destroy()
			CLONE.Parent = Effects
			CLONE:BreakJoints()
			local MATERIALS = {"Glass","Neon"}
			for _, c in pairs(CLONE:GetDescendants()) do
				if c:IsA("BasePart") then
					if c.Name == "Torso" or c.Name == "UpperTorso" or c == CLONE.PrimaryPart then
 						CreateSound(340722848, c, 10, 1, false)
					end
					c.Anchored = true
					c.Transparency = c.Transparency + 0.2
					c.Material = MATERIALS[MRANDOM(1,2)]
					c.Color = C3(1,1,1)
					if c.ClassName == "MeshPart" then
						c.TextureID = ""
					end
					if c:FindFirstChildOfClass("SpecialMesh") then
						c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
					end
					if c:FindFirstChildOfClass("Decal") then
						c:FindFirstChildOfClass("Decal"):remove()
					end
					c.Name = "Banished"
					c.CanCollide = false
				else
					c:remove()
				end
			end
			local A = false
			for i = 1, 35 do
				if A == false then
					A = true
				elseif A == true then
					A = false
				end
				for _, c in pairs(CLONE:GetDescendants()) do
					if c:IsA("BasePart") then
						c.Anchored = true
						c.Material = MATERIALS[MRANDOM(1,2)]
						c.Transparency = c.Transparency + 0.8/35
						if A == false then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)
						elseif A == true then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)						
						end
					end
				end
				Swait()
			end
			CLONE:remove()
		end))
	end
end

function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end


function ManualDamage(Humanoid,Damage,TorsoPart)
	local defence = Instance.new("BoolValue",Humanoid.Parent)
	defence.Name = ("HitBy"..Player.Name)
	game:GetService("Debris"):AddItem(defence, 0.001)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health ~= 0 then
		local CritChance = MRANDOM(1,100)
		if Damage > Humanoid.Health then
			Damage = math.ceil(Humanoid.Health)
			if Damage == 0 then
				Damage = 0.1
			end
		end
		Humanoid.Health = Humanoid.Health - Damage
	end
end

local asd = Instance.new("ParticleEmitter")
asd.Color = ColorSequence.new(Color3.new(0.5, 0, 0), Color3.new(.3, 0, 0))
asd.LightEmission = .1
asd.Texture = "http://www.roblox.com/asset/?ID=291880914"
aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6),NumberSequenceKeypoint.new(1, 2)})
bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
asd.Transparency = bbb
asd.Size = aaa
asd.ZOffset = .9
asd.Acceleration = Vector3.new(0, -15, 0)
asd.LockedToPart = false
asd.EmissionDirection = "Back"
asd.Lifetime = NumberRange.new(1, 2)
asd.Rotation = NumberRange.new(-100, 100)
asd.RotSpeed = NumberRange.new(-100, 100)
asd.Speed = NumberRange.new(10)
asd.Enabled = false
asd.VelocitySpread = 999

function getbloody(victim,amount)
	local PART = CreatePart(3, Effects, "Metal", 0, 1, "Mid gray", "Blood", victim.Size)
	PART.CFrame = victim.CFrame
	local HITPLAYERSOUNDS = {"356551938","264486467"}
	Debris:AddItem(PART,5)
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	local prtcl = asd:Clone()
	prtcl.Parent = PART
	prtcl:Emit(amount*10)
end

function ManualAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ManualDamage(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function KickThatNigga(CHARACTER)
	g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 1
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
	 CreateSound("527749592", CHARACTER, 600, 1, false)
	for i,v in ipairs(CHARACTER:GetChildren()) do
		if v.ClassName == "Part" or v.ClassName == "MeshPart" then
			if v.Name ~= "HumanoidRootPart" then
				local BOD = v:Clone()
				BOD.CanCollide = false
				BOD.Anchored = true
				BOD.CFrame = v.CFrame
				BOD.Parent = kickfolder
				BOD.Material = "Granite"
				BOD.Color = C3(.3,0,0)
				if BOD:FindFirstChildOfClass("Decal") then
					BOD:FindFirstChildOfClass("Decal"):remove()
				end
				if BOD.Name == "Head" then
					naeeym2.Adornee = BOD
				end
				if BOD.ClassName == "MeshPart" then
					BOD.TextureID = ""
				end
			end
		end
	end
	for i,v in pairs(g) do
	v:remove()
	end 
	if CHARACTER ~= Character then
	CHARACTER:remove()
	end
	if CHARACTER.Name == "Helkern" then
		Character:BreakJoints()
	end
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
end

function ApplyAoE(POSITION,RANGE,ISKICKED)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISKICKED == true then
							KickThatNigga(CHILD)
						else
							if ISKICKED == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISKICKED == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

local BEANED = {}

function Ban(bitch)	
if bitch then	
g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 0
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
-- CreateSound("2570187601", bitch, 600, 1, false)
local Players = game:GetService("Players")
local fag = Players:FindFirstChild(bitch.Name)
--faggut:Kick()
	if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
		if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
		end
			if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
			end
				if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
				end
					if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
					end
						if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
						end
												if Players:FindFirstChild("Drago_TH") then
						end
						table.insert(BEANED,bitch.name)
	--]]
			--CreateSound("527749592", game.Workspace, 700, 1, false)
	--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
	--wait(6)
	--bitch:Remove()
end
end

local function CheckForBan(player)
	for i = 1, #BEANED do
		if player.Name == BEANED[i] then
			player:Kick("Ur mom gay skids") --Ban Reason Change between the '' to change the reason!
		end
	end
end


game.Players.PlayerAdded:connect(function()
	for i,v in pairs(game.Players:GetPlayers())do
		CheckForBan(v)
	end  
end)


function Kick(bitch)
g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 0
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
-- CreateSound("2570187601", bitch, 600, 1, false)
local Players = game:GetService("Players")
local fag = Players:FindFirstChild(bitch.Name)
--faggut:Kick()
	if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
		if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
		end
			if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
			end
				if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
				end
					if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
					end
						if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
	--[[
		for i,v in pairs(fag.Name) do
		if (v:lower() == newPlayer.Name:lower()) then
			newPlayer:Remove()
		end
	end]]--
			--CreateSound("527749592", game.Workspace, 700, 1, false)
	--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
	--wait(6)
	--bitch:Remove()
end


function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

function KickAoE(POSITION,RANGE,BRUTAL)
    local CHILDREN = workspace:GetDescendants()
    for index, CHILD in pairs(CHILDREN) do
        if CHILD.ClassName == "Model" and CHILD ~= Character then
            local HUM = CHILD:FindFirstChildOfClass("Humanoid")
            if HUM then
                local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                if TORSO then
                    if (TORSO.Position - POSITION).Magnitude <= RANGE then
                        if BRUTAL == true then
	if Type == "Banish" then
                            KickThatNigger(CHILD)
	elseif Type == "Ban" then
		Ban(CHILD)
	elseif Type == "Kick" then
		Kick(CHILD)
			--elseif Type == "Tangle" then
		--Entangle(CHILD)
		end
                        else
                            CHILD:BreakJoints()
                        end
                    end
                end
            end
        end
    end
end

local PE=Instance.new("ParticleEmitter",art)
PE.LightEmission=.8
PE.Color = ColorSequence.new(BRICKC("Really red").Color)
PE.Lifetime=NumberRange.new(0.35,1.5)
PE.Rotation=NumberRange.new(0,360)
PE.Rate=999
PE.VelocitySpread = 10000
PE.Acceleration = Vector3.new(0,0,0)
PE.Drag = 5
PE.Speed = NumberRange.new(0,0,0)
PE.Texture="http://www.roblox.com/asset/?id=833874434"
PE.ZOffset = -1.5
PE.Name = "PE"
PE.Enabled = false

function particles(art)
	local PARTICLES = PE:Clone()
	PARTICLES.Parent = art
end

function KillChildren(v)
	v:BreakJoints()
	for _, c in pairs(v:GetChildren()) do
		if c.ClassName == "Part" or c.ClassName == "MesPart" then
			if c.Transparency < 1 then
				if c:FindFirstChildOfClass("Decal") then
					c:FindFirstChildOfClass("Decal"):remove()
				end
				particles(c)
				c.PE.Enabled = true
				c.Parent = Effects
				c.CanCollide = false
				c.Material = "Neon"
				c.Color = C3(1,0,0)
				c.Transparency = 0.5
				local grav = Instance.new("BodyPosition",c)
				grav.P = 20000
				grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
				grav.position = c.Position + VT(MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1))
				grav.Name = "GravityForce"
				coroutine.resume(coroutine.create(function()
				for i = 1, 50 do
					Swait()
					c.Transparency = c.Transparency + 0.01
				end
				c.PE.Enabled = false
				Debris:AddItem(c,2)
				end))
			end
		end
	end
end

function killnearest(position,range)
	for i,v in ipairs(workspace:GetChildren()) do
	local body = v:GetChildren()
		for part = 1, #body do
			if((body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character) then
				if(body[part].Position - position).Magnitude < range then
					if v.ClassName == "Model" then
						KillChildren(v)
					end
				end
			end
		end
	end
end

function Dismember(MAN,DOWHAT)
	for index, CHILD in pairs(MAN:GetDescendants()) do
		if CHILD:IsA("Script") or CHILD:IsA("LocalScript") then
			CHILD:Destroy()
		end
	end
	if DOWHAT == "Ragdoll" then
		local HUM = MAN:FindFirstChildOfClass("Humanoid")
		if HUM then
			HUM.Health = 0
		end
		if MAN:FindFirstChild("UpperTorso") then
			local SCRIPT = script.R15Ragdoll:Clone()
			SCRIPT.Parent = MAN
			SCRIPT.Disabled = false
		else
			local SCRIPT = script.R6Ragdoll:Clone()
			SCRIPT.Parent = MAN
			SCRIPT.Disabled = false
		end
		MAN:BreakJoints()
	else
		local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
		local HED = MAN:FindFirstChild("Head")
		if TORSO and HED then
			if DOWHAT == "Head" then
				if TORSO:FindFirstChild("TorsoA4") then
					TORSO:FindFirstChild("TorsoA4"):Remove()
				elseif MAN:FindFirstChild("RagdollConstraintHead") then
					MAN:FindFirstChild("RagdollConstraintHead"):Remove()
				end
				HED:BreakJoints()
			elseif DOWHAT == "RightArm" then
				if TORSO:FindFirstChild("TorsoA3") then
					TORSO:FindFirstChild("TorsoA3"):Remove()
				elseif MAN:FindFirstChild("RagdollConstraintRightUpperArm") then
					MAN:FindFirstChild("RagdollConstraintRightUpperArm"):Remove()
				end
			elseif DOWHAT == "LeftArm" then
				if TORSO:FindFirstChild("TorsoA2") then
					TORSO:FindFirstChild("TorsoA2")
				elseif MAN:FindFirstChild("RagdollConstraintLeftUpperArm") then
					MAN:FindFirstChild("RagdollConstraintLeftUpperArm"):Remove()
				end
			elseif DOWHAT == "Legs" then
				if TORSO.Name == "Torso" then
					if TORSO:FindFirstChild("TorsoA") then
						TORSO:FindFirstChild("TorsoA"):Remove()
					end
					if TORSO:FindFirstChild("TorsoA1") then
						TORSO:FindFirstChild("TorsoA1"):Remove()
					end
				elseif MAN:FindFirstChild("RagdollConstraintUpperTorso") then
					MAN:FindFirstChild("RagdollConstraintUpperTorso"):Remove()
				end
			end
		end
	end
end

function OofOuchBlood(LOCATION,TO,AMOUNT)
	local P = CreatePart(3, Effects, "Granite", 0, 1, BRICKC("Pearl"), "Blood", VT(0,0,0), true)
	P.CFrame = CF(LOCATION,TO)
	local BLOOD = MODULE.Blood:Clone()
	BLOOD.Parent = P
	BLOOD:Emit(AMOUNT)
	Debris:AddItem(P,2)
end

local DETECTKILL = function(HIT,POS,FORCE)
		if HIT.Parent:FindFirstChildOfClass("Humanoid") then
			if HIT.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
				local BV = IT("BodyVelocity")
				BV.MaxForce = BV.MaxForce * 500
				BV.Velocity = CF(RootPart.Position,HIT.Position+VT(0,5,0)).lookVector*(FORCE or 25)
				BV.Parent = HIT
				Debris:AddItem(BV,0.05)
				OofOuchBlood(POS,RootPart.Position,150)
			else
				OofOuchBlood(POS,RootPart.Position,2)
			end
		end
	end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

function Zone()
	ATTACK = true
	Rooted = true
	for i=0, 5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(-18)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-5), RAD(12), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function meme()
local TARGET = Mouse.Target
	if TARGET ~= nil then
		if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
			local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
			local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
			if ROOT and HUM.Health > 0 then
			local FOE = Mouse.Target.Parent
			RootPart.CFrame = ROOT.CFrame*CF(0.3,0,6)
			ROOT.Anchored = true
   local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
	if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
	 local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
	  local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
	   if TORSO and HUM.Health > 0 then
			ATTACK = true
			Rooted = false
			CreateSound(429459101, TORSO, 0.5, 1, false)
	for i=0, 2, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(85), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(90), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
		WACKYEFFECT({Time = 18, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(Hole.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = 136523485, SoundPitch = 1, SoundVolume = 5})
		for i=0, 0.5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.5, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(-6), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.2, -0.8) * ANGLES(RAD(85), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.4, -0.3) * ANGLES(RAD(90), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-25)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
		getbloody(TORSO,1)
	--	SHAKECAM(HITPOS, 15, 2, 130)
		killnearest(TORSO.Position, 5, 5)
		WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(10,10,10), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 0, SoundPitch = MRANDOM(13,15)/10, SoundVolume = 3})
		WACKYEFFECT({EffectType = "Sphere", Size = VT(6,6,6), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	ATTACK = false
	Rooted = false
		 end
	end
			end
		end
		end
			end

function Dance()
	ATTACK = true
	Rooted = true
	local LOOP = true
	KEY = Mouse.KeyDown:connect(function(NEWKEY)
		if NEWKEY == "t" then
			KEY:Disconnect()
			LOOP = false
		end
	end)
	repeat
		for i = 0, 0.4, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0.1 + ((1) - 1)) * ANGLES(RAD(-8), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.2, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(15)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(15)), 1 / Animation_Speed)
	end
		for i = 0, 1, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(26)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(26)), 1 / Animation_Speed)
	end
		for i = 0, 0.4, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0.1 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.2, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-15)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-15)), 1 / Animation_Speed)
	end
		for i = 0, 1, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-26)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-26)), 1 / Animation_Speed)
	end
	until LOOP == false
	ATTACK = false
	Rooted = false
end


--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//

-------------------------------------

Humanoid.Animator.Parent = nil

-------------------------------------


function MouseDown(Mouse)
	if ATTACK == false then
	end
end


function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "v" and ATTACK == false then
		meme()
		end
		
	if Key == "t" and ATTACK == false then
		Dance()
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

--//=================================\\
--\\=================================//


function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end


--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

local CONNECT = nil

while true do
	Swait()
	ANIMATE.Parent = nil
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.2 * COS(SINE / (WALKSPEEDVALUE))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 100, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 25), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1 - 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1 + 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
	end
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(15)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(45)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 0.15 / Animation_Speed)
			if MRANDOM(1,50) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-10,10)), RAD(MRANDOM(-10,10)), RAD(MRANDOM(-10,10))), 1 / Animation_Speed)
			end	
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.3, 0) * ANGLES(RAD(15 - 15 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 15 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.8, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(86), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-86), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
	end
	unanchor()
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	if sick.Parent ~= Torso then
	sick = IT("Sound", Torso)
	end
	sick.Parent = Torso
	sick.Playing = true
    sick.Looped = true
	sick.Volume = 2
	sick.Pitch = 1
	sick.SoundId = "rbxassetid://549162782"
	sick.Name = "Dead"
end

--//=================================\\
--\\=================================//




local basetpart = game.Workspace.non:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner()
--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--

    end


if string.sub(msg, 1, 10) == (prefix.."traprifle") then
------------------------
--Aiju Love Trap Rifle--
----------------------------------------------------------------
--By CKbackup (Sugarie Saffron)                               --
--YT: https://www.youtube.com/channel/UC8n9FFz7e6Zo13ob_5F9MJw--
--Discord: Sugarie Saffron#4705                               --
----------------------------------------------------------------
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


local pee = game.Players.LocalPlayer.Character["METALXLIGHTSEER77Accessory"]
local gold = game.Players.LocalPlayer.Character["METALXLIGHTSEER77Accessory"].Handle
gold.AccessoryWeld:Destroy()




local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = gold
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true

attachment1.CFrame = CFrame.Angles(-2,4.6,-.9) 
  attachment0.CFrame = CFrame.new(1.2,0,-.3)
  
  

 -- local toolgoflingfling = Instance.new("BodyVelocity", gold)
--toolgoflingfling.MaxForce = Vector3.new(90000,90000,90000)
--toolgoflingfling.Velocity = Vector3.new(90000,90000,90000)
 
 
function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end



--loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()

wait(10)


wait(1/60)
Effects = { }
local Player = game:service'Players'.localPlayer
loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()
playerss = workspace.non
local chara = workspace.non
local Humanoid = chara:FindFirstChildOfClass("Humanoid")
local Mouse = Player:GetMouse()
local LeftArm = chara["Left Arm"]
local RightArm = chara["Right Arm"]
local LeftLeg = chara["Left Leg"]
local RightLeg = chara["Right Leg"]
local Head = chara.Head
local Torso = chara.Torso
local Camera = workspace.CurrentCamera
local RootPart = chara.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local attack = false
local Anim = 'Idle'
local attacktype = 1
local delays = false
local play = true
local targetted = nil
local Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
local velocity = RootPart.Velocity.y
local sine = 0
local change = 1
local doe = 0
local Create = LoadLibrary("RbxUtility").Create
local debby = game:GetService("Debris")
Humanoid.WalkSpeed = 16

Humanoid.Animator.Parent = nil
chara.Animate.Parent = nil

local newMotor = function(part0, part1, c0, c1)
local w = Create('Motor'){
Parent = part0,
Part0 = part0,
Part1 = part1,
C0 = c0,
C1 = c1,
}
return w
end

function clerp(a, b, t)
return a:lerp(b, t)
end

RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

local RW = newMotor(Torso, RightArm, CFrame.new(1.5, 0, 0), CFrame.new(0, 0, 0)) 
local LW = newMotor(Torso, LeftArm, CFrame.new(-1.5, 0, 0), CFrame.new(0, 0, 0))
local RH = newMotor(Torso, RightLeg, CFrame.new(.5, -2, 0), CFrame.new(0, 0, 0))
local LH = newMotor(Torso, LeftLeg, CFrame.new(-.5, -2, 0), CFrame.new(0, 0, 0))
RootJoint.C1 = CFrame.new(0, 0, 0)
RootJoint.C0 = CFrame.new(0, 0, 0)
Torso.Neck.C1 = CFrame.new(0, 0, 0)
Torso.Neck.C0 = CFrame.new(0, 1.5, 0)

local rarmc1 = RW.C1
local larmc1 = LW.C1
local rlegc1 = RH.C1
local llegc1 = LH.C1

local resetc1 = false

function PlayAnimationFromTable(table, speed, bool)
RootJoint.C0 = clerp(RootJoint.C0, table[1], speed) 
Torso.Neck.C0 = clerp(Torso.Neck.C0, table[2], speed) 
RW.C0 = clerp(RW.C0, table[3], speed) 
LW.C0 = clerp(LW.C0, table[4], speed) 
RH.C0 = clerp(RH.C0, table[5], speed) 
LH.C0 = clerp(LH.C0, table[6], speed) 
if bool == true then
if resetc1 == false then
resetc1 = true
RootJoint.C1 = RootJoint.C1
Torso.Neck.C1 = Torso.Neck.C1
RW.C1 = rarmc1
LW.C1 = larmc1
RH.C1 = rlegc1
LH.C1 = llegc1
end
end
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")
frame = 0.03333333333333
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
tf = tf + s
if tf >= frame then
if allowframeloss then
script.Heartbeat:Fire()
lastframe = tick()
else
for i = 1, math.floor(tf / frame) do
script.Heartbeat:Fire()
end
lastframe = tick()
end
if tossremainder then
tf = 0
else
tf = tf - frame * math.floor(tf / frame)
end
end
end)
function swait(num)
if num == 0 or num == nil then
ArtificialHB.Event:wait()
else
for i = 0, num do
ArtificialHB.Event:wait()
end
end
end

function RemoveOutlines(part)
part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

function so(id,par,pit,vol)
local sou = Instance.new("Sound", par or workspace)
if par == chara then
sou.Parent = chara.Torso
end
sou.Volume = vol
sou.Pitch = pit or 1
sou.SoundId = "rbxassetid://" .. id
sou.PlayOnRemove = true
sou:Destroy()
end

--This is just for builds--
New = function(Object, Parent, Name, Data)
local Object = Instance.new(Object)
for Index, Value in pairs(Data or {}) do
Object[Index] = Value
end
Object.Parent = Parent
Object.Name = Name
return Object
end


function rayCast(Position, Direction, Range, Ignore)
return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) 
end 

function FindNearestTorso(Position, Distance, SinglePlayer)
if SinglePlayer then
return (SinglePlayer.Head.CFrame.p - Position).magnitude < Distance
end
local List = {}
for i, v in pairs(workspace:GetDescendants()) do
if v:IsA("Model") then
if v:findFirstChild("Head") then
if v ~= chara then
if (v.Head.Position - Position).magnitude <= Distance then
table.insert(List, v)
end 
end 
end 
end 
end
return List
end

EffectModel = Create("Model"){
Parent = chara,
Name = "Effects",
}

--Effect Functions--
Effects = {

Block = function(cf,partsize,meshstart,meshadd,matr,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("BlockMesh",p)
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
if spin == true then
p.CFrame = p.CFrame * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
end
end
p:Destroy()
end)()
return p
end,

Sphere = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshType = "Sphere"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Cylinder = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("CylinderMesh",p)
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Wave = function(cf,meshstart,meshadd,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://20329976"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Ring = function(cf,meshstart,meshadd,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://3270017"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Meshed = function(cf,meshstart,meshadd,colour,meshid,textid,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = meshid
m.TextureId = textid
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Explode = function(cf,partsize,meshstart,meshadd,matr,colour,move,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf * CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshType = "Sphere"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.new(0,move,0)
end
p:Destroy()
end)()
return p
end,

}

function GetDudesTorso(c)
local torsy = (c:findFirstChild("Torso") or c:findFirstChild("UpperTorso"))
if torsy ~= nil then
return torsy
end
end

function BodyVel(part,faws)
local bodyvel = Instance.new("BodyVelocity",part)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = faws
debby:AddItem(bodyvel,.2)
end

function Dmg(dude)
if dude and dude ~= chara and dude.Name ~= "CKbackup" then
if dude:FindFirstChild("TURAPPU") then return end
local debounce = Instance.new("BoolValue",dude)
debounce.Name = "TURAPPU"
coroutine.wrap(function()
local torsy = GetDudesTorso(dude)
if torsy then
local b = Instance.new("Part",dude)
b.BrickColor = BrickColor.new("Pink")
b.Size = Vector3.new(.1,.1,.1)
b.CanCollide = false
b.Transparency = 1
b.Material = "Neon"
b:BreakJoints()
so(113952851,b,1,3)
local bw = Instance.new("Weld",b)
bw.Part0 = b
bw.Part1 = torsy
local bm = Instance.new("SpecialMesh",b)
bm.MeshType = "Sphere"
bm.Scale = Vector3.new()
for i=0,1,.05 do
swait()
b.Transparency = 1-i
bm.Scale = Vector3.new(65*i,65*i,65*i)
end
coroutine.wrap(function()
swait(20)
for i=0,1,.05 do
swait()
b.Transparency = i
bm.Scale = Vector3.new(65+100*i,65+100*i,65+100*i)
end
b:Destroy()
end)()
end
for i,v in pairs(dude:children()) do
if v:IsA("Clothing") or v:IsA("BodyColors") or v:IsA("Accoutrement") then v:Destroy() end
end
local hedcol = dude:FindFirstChild("Head").BrickColor
local bcols = Instance.new("BodyColors",dude)
bcols.Name = "NeoCols"
bcols.HeadColor = hedcol
bcols.LeftArmColor = hedcol
bcols.RightArmColor = hedcol
bcols.TorsoColor = hedcol
bcols.LeftLegColor = hedcol
bcols.RightLegColor = hedcol
local Heiru = nil
local hacho = math.random(1,6)
if hacho == 1 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999847, 3.29998803, -42.2000351, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.075000003, 0.0599999987, 0.0599999987),MeshId = "rbxassetid://506240548",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(-7.62939453e-06, -1.19999862, 0.200000763, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 2 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.5, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.5499878, 4.29998732, -42.1000366, -1, 0, 0, 0, 1, 0, 0, 0, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(1.04999995, 1.04999995, 1.04999995),MeshId = "rbxassetid://398987591",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),C1 = CFrame.new(0.0499954224, -0.199999332, 0.100002289, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 3 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.5, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4499893, 3.89998746, -42.1000366, -1, 0, 0, 0, 1, 0, 0, 0, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{MeshId = "rbxassetid://164382853",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),C1 = CFrame.new(-0.0500030518, -0.599999189, 0.100002289, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 4 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999771, 2.79998851, -43.3000183, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.109999999, 0.0799999982, 0.0850000009),MeshId = "rbxassetid://561963999",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(-1.52587891e-05, -1.69999814, 1.29998398, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 5 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999847, 3.69998765, -42.600029, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.0450000018, 0.0450000018, 0.0450000018),MeshId = "rbxassetid://487000462",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(-7.62939453e-06, -0.799998999, 0.599994659, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 6 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.5, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.5499802, 3.29998803, -42.0000381, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.0649999976, 0.0599999987, 0.0599999987),MeshId = "rbxassetid://437152207",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(0.049987793, -1.19999862, 3.81469727e-06, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
end
local haircol = {"Pink","Baby blue","Magenta","Brown","Black","Really black","White","CGA brown","Cool yellow"}
Heiru.BrickColor = BrickColor.new(haircol[math.random(1,#haircol)])
local ercho = math.random(1,8)
if ercho == 1 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 4.59999943, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{Scale = Vector3.new(1.04999995, 1, 1.04999995),MeshId = "rbxassetid://10871984",TextureId = "rbxassetid://10871968",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.100012779, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 2 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 5.39999866, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{MeshId = "rbxassetid://1072759",TextureId = "rbxassetid://1072760",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.900012016, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 3 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.300000012, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.5499954, 5.29999876, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{Scale = Vector3.new(1.20000005, 1.20000005, 1.20000005),MeshId = "rbxassetid://1374148",TextureId = "rbxassetid://413143035",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0.0500030518, 0.800012112, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 4 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 5.29999876, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{Scale = Vector3.new(0.699999988, 0.5, 0.600000024),MeshId = "rbxassetid://361948302",TextureId = "rbxassetid://361948503",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.800012112, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 5 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 5.09999895, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{MeshId = "rbxassetid://1095510",TextureId = "rbxassetid://1095511",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.600012302, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
end
local oucho = math.random(1,6)
local sh = Instance.new("Shirt",dude)
local pn = Instance.new("Pants",dude)
if oucho == 1 then
pn.PantsTemplate = "rbxassetid://56903591"
sh:Destroy()
elseif oucho == 2 then
sh.ShirtTemplate = "rbxassetid://242933637"
pn.PantsTemplate = "rbxassetid://745334066"
elseif oucho == 3 then
sh.ShirtTemplate = "rbxassetid://1238151974"
pn.PantsTemplate = "rbxassetid://1340645290"
elseif oucho == 4 then
sh.ShirtTemplate = "rbxassetid://583471131"
pn.PantsTemplate = "rbxassetid://460147365"
elseif oucho == 5 then
pn.PantsTemplate = "rbxassetid://45541243"
sh:Destroy()
elseif oucho == 6 then
pn.PantsTemplate = "rbxassetid://41162775"
sh:Destroy()
end
Instance.new("Decal",dude:FindFirstChild("Head")).Texture = "rbxassetid://985062039"
coroutine.wrap(function()
swait(40)
local naeeym2 = Instance.new("BillboardGui",dude)
naeeym2.Size = UDim2.new(0,100,0,40)
naeeym2.StudsOffset = Vector3.new(0,3,0)
naeeym2.Adornee = dude:FindFirstChild("Head")
naeeym2.Name = "TalkingBillBoard"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.BorderSizePixel = 0
tecks2.Text = "Trapped! In another sense.."
tecks2.Font = "Cartoon"
tecks2.TextSize = 24
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(1,.6,.7)
tecks2.TextStrokeColor3 = Color3.new(1,1,1)
tecks2.Size = UDim2.new(1,0,0.5,0)
swait(10)
for i = 0,1,.05 do
swait()
tecks2.Position = tecks2.Position - UDim2.new(0,0,.005,0)
tecks2.TextStrokeTransparency = i
tecks2.TextTransparency = i
end
naeeym2:Destroy()
end)()
end)()
end
end

function MagnitudeDmg(par,magni)
for _, c in pairs(workspace:GetDescendants()) do
local hum = c:FindFirstChildOfClass("Humanoid")
if hum ~= nil and c:FindFirstChild("IsTeamMateOfCK")==nil then
local head = GetDudesTorso(c)
if head ~= nil then
local targ = head.Position - par.Position
local mag = targ.magnitude
if magni >= mag and c ~= chara then
Dmg(c)
end
end
end
end
end

local mus = Instance.new("Sound",Head)
mus.Name = "mus"
mus.SoundId = "rbxassetid://1131624146"
mus.Looped = true
mus.Volume = 1
mus:Play()

zhold = false
function shoot()
attack = true
for i=0,1,.3 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(0.0823832005, 1.55974865, -0.0981806219, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
CFrame.new(1.02804303, 0.5, -0.52656126, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
CFrame.new(-1.28728318, 0.203263342, -0.756378591, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
CFrame.new(0.499997735, -1.99999893, -1.11758709e-06, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
CFrame.new(-0.500001431, -1.99999893, -9.983778e-07, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
}, .4, false)
end
Humanoid.WalkSpeed = 2
local ref = Instance.new("Part",chara)
ref.Size = Vector3.new(0,0,0)
ref.Anchored = true
ref.CanCollide = false
ref.Transparency = 1
repeat
so(1145251796,ShotPt,math.random(95,105)/100,3)
ref.CFrame = Mouse.Hit
MagnitudeDmg(ref,2)
--Effects.Block(ShotPt.CFrame,Vector3.new(1,1,1),Vector3.new(),Vector3.new(.2,.2,.2),"Neon","Pink",true,false,.1)
--Effects.Block(CFrame.new((ShotPt.Position + Mouse.Hit.p)/2,Mouse.Hit.p),Vector3.new(1,1,(ShotPt.Position - Mouse.Hit.p).magnitude),Vector3.new(.2,.2,1),Vector3.new(.1,.1,0),"Neon","Pink",false,false,.1)
--Effects.Block(Mouse.Hit,Vector3.new(1,1,1),Vector3.new(),Vector3.new(.2,.2,.2),"Neon","Pink",true,false,.1)
for i=0,1,.5 do
swait()
PlayAnimationFromTable({		
CFrame.new(2.25380063e-06, 0, 0.100001052, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(0.0823859125, 1.55974913, -0.0981838703, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
CFrame.new(1.25785875, 0.5, -0.333723217, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
CFrame.new(-1.05747044, 0.203263938, -0.563540041, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
CFrame.new(0.423390329, -1.99999893, -0.0642812699, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
CFrame.new(-0.57660532, -1.99999893, -0.0642794371, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
}, .4, false)
end
for i=0,1,.5 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(0.0823832005, 1.55974865, -0.0981806219, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
CFrame.new(1.02804303, 0.5, -0.52656126, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
CFrame.new(-1.28728318, 0.203263342, -0.756378591, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
CFrame.new(0.499997735, -1.99999893, -1.11758709e-06, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
CFrame.new(-0.500001431, -1.99999893, -9.983778e-07, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
}, .4, false)
end
until zhold == false
ref:Destroy()
Humanoid.WalkSpeed = 16
attack = false
end

function doge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
local bodyvel = Instance.new("BodyVelocity",RootPart)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.413182259, -0.492409885, 1, 0, 0, 0, 0.173647001, 0.984807968, 0, -0.984807968, 0.173647001),
CFrame.new(0, 1.39017391, 0.409808099, 1, 0, 0, 0, 0.499998748, -0.866026163, 0, 0.866026163, 0.499998748),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(-0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -1.30470812, -0.622091293, 1, 0, 0, 0, -0.866025984, 0.499998987, 0, -0.499998987, -0.866025984),
CFrame.new(0, 1.47984993, -0.230206192, 1, 0, 0, 0, 0.939693034, 0.34201926, 0, -0.34201926, 0.939693034),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(-0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -2.22375727, 0.305265486, 1, 0, 0, 0, 0.500000238, -0.866025388, 0, 0.866025388, 0.500000238),
CFrame.new(0, 1.35128808, -0.383415997, 1, 0, 0, 0, 0.766043901, 0.642788529, 0, -0.64278847, 0.766043901),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999337, -0.599998593, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024),
CFrame.new(-0.500003815, -1.35979521, -0.923200667, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
bodyvel:Destroy()
Humanoid.WalkSpeed = 16
attack = false
end

function bdoge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
local bodyvel = Instance.new("BodyVelocity",RootPart)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = RootPart.CFrame.lookVector*-50
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -2.22375727, 0.305265486, 1, 0, 0, 0, 0.500000238, -0.866025388, 0, 0.866025388, 0.500000238),
CFrame.new(0, 1.35128808, -0.383415997, 1, 0, 0, 0, 0.766043901, 0.642788529, 0, -0.64278847, 0.766043901),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999337, -0.599998593, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024),
CFrame.new(-0.500003815, -1.35979521, -0.923200667, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*-50
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -1.30470812, -0.622091293, 1, 0, 0, 0, -0.866025984, 0.499998987, 0, -0.499998987, -0.866025984),
CFrame.new(0, 1.47984993, -0.230206192, 1, 0, 0, 0, 0.939693034, 0.34201926, 0, -0.34201926, 0.939693034),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(-0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*-50
end
bodyvel:Destroy()
Humanoid.WalkSpeed = 16
attack = false
end

function adoge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
Effects.Wave(RootPart.CFrame*CFrame.Angles(math.rad(90),0,0),Vector3.new(),Vector3.new(1,.1,1),"White",math.random(-10,10),false,.1)
BodyVel(RootPart,RootPart.CFrame.lookVector*50)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.095761165, -0.251516223, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
CFrame.new(0, 1.43075883, 0.149916381, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.96527231, 0.196966231, 1, 0, 0, 0, 0.984807789, 0.173648685, 0, -0.173648715, 0.984807789),
CFrame.new(-0.5, -1.43618584, -0.205210268, 1, 0, 0, 0, 0.939692438, 0.342020929, 0, -0.342020959, 0.939692438),
}, .4, false)
end
Humanoid.WalkSpeed = 16
attack = false
end

function badoge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
Effects.Wave(RootPart.CFrame*CFrame.Angles(math.rad(-90),0,0),Vector3.new(),Vector3.new(1,.1,1),"White",math.random(-10,10),false,.1)
BodyVel(RootPart,RootPart.CFrame.lookVector*-50)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.210508779, 0.312937856, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
CFrame.new(0, 1.4075644, -0.288293391, 1, 0, 0, 0, 0.866025388, 0.500000238, 0, -0.500000238, 0.866025388),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.9652698, 0.196958005, 1, 0, 0, 0, 0.984807789, 0.173648715, 0, -0.173648685, 0.984807789),
CFrame.new(-0.5, -1.43618536, -0.205215126, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676),
}, .4, false)
end
Humanoid.WalkSpeed = 16
attack = false
end

Mouse.Button1Down:connect(function()
if attack == false then
zhold = true
shoot()
end
end)

Mouse.Button1Up:connect(function()
zhold = false
end)

local sprintt = 0
Mouse.KeyDown:connect(function(k)
k = k:lower()
if k=='m' then
if mus.IsPlaying == true then
mus:Stop()
elseif mus.IsPaused == true then
mus:Play()
end
end
if attack == false then
if k == 'q' then
if Anim == "Fall" or Anim == "Jump" then
badoge()
else
bdoge()
end
elseif k == 'e' then
if Anim == "Fall" or Anim == "Jump" then
adoge()
else
doge()
end
end
end
end)

Mouse.KeyUp:connect(function(k)
k = k:lower()
if k == 'z' then
zhold = false
end
end)

coroutine.wrap(function()
while 1 do
swait()
if doe <= 360 then
doe = doe + 2
else
doe = 0
end
end
end)()
while true do
swait()
while true do
swait()
if Head:FindFirstChild("mus")==nil then
mus = Instance.new("Sound",Head)
mus.Name = "mus"
mus.SoundId = "rbxassetid://1131624146"
mus.Looped = true
mus.Volume = 1
mus:Play()
end
if sprintt >= 1 then
sprintt = sprintt - 1
end
Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
velocity = RootPart.Velocity.y
sine = sine + change
local hit, pos = rayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, chara)
if RootPart.Velocity.y > 1 and hit == nil then 
Anim = "Jump"
if attack == false then
PlayAnimationFromTable({
CFrame.new(0, 0.0382082276, -0.0403150208, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
CFrame.new(0, 1.46579528, 0.0939689279, 1, 0, 0, 0, 0.939692855, -0.342019796, 0, 0.342019796, 0.939692855),
CFrame.new(1.20945489, -0.213504896, 3.55388607e-07, 0.939692736, 0.342019916, 1.53461215e-07, -0.342019945, 0.939692736, 1.93715096e-07, -8.56816769e-08, -2.23517418e-07, 1.00000012),
CFrame.new(-1.20945573, -0.213503733, 5.0439985e-07, 0.939692736, -0.342019916, -1.53461215e-07, 0.342019945, 0.939692736, 1.93715096e-07, 8.56816769e-08, -2.23517418e-07, 1.00000012),
CFrame.new(0.5, -1.99739456, -0.0180913229, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
CFrame.new(-0.5, -1.30000103, -0.39999947, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676),
}, .3, false)
end
elseif RootPart.Velocity.y < -1 and hit == nil then 
Anim = "Fall"
if attack == false then
PlayAnimationFromTable({
CFrame.new(0, -0.0646628663, 0.0399149321, 1, 0, 0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849),
CFrame.new(0, 1.4913609, -0.128171027, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
CFrame.new(1.55285025, 0.466259956, -9.26282269e-08, 0.766043842, -0.642788351, -6.46188241e-08, 0.642788291, 0.766043961, -7.4505806e-08, 1.04308128e-07, 1.49011612e-08, 1.00000012),
CFrame.new(-1.5605253, 0.475036323, -2.10609159e-07, 0.766043842, 0.642788351, 6.46188241e-08, -0.642788291, 0.766043961, -7.4505806e-08, -1.04308128e-07, 1.49011612e-08, 1.00000012),
CFrame.new(0.500000954, -1.9973948, -0.0180922765, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
CFrame.new(-0.499999046, -1.30000043, -0.400000483, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
}, .3, false)
end
elseif Torsovelocity < 1 and hit ~= nil then
Anim = "Idle"
if attack == false then
change = 1
PlayAnimationFromTable({
CFrame.new(-0.0769465268, -7.7815578e-08, -0.031559173, 0.939695537, 1.01607293e-06, 0.342021346, 7.9855522e-07, 1.00000191, 5.12654879e-07, -0.342019558, 2.16066837e-07, 0.939692855) * CFrame.new(0,.05 * math.cos((sine)/10), 0),
CFrame.new(0.0615186803, 1.4999913, 0.0559706129, 0.939695537, 7.9855522e-07, -0.342019558, 1.01607293e-06, 1.00000191, 2.16066837e-07, 0.342021346, 5.12654879e-07, 0.939692855),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.500003159, -2.00000715, -1.98185444e-06, 0.939692736, 0, -0.342019916, 0, 1, 0, 0.342019886, 0, 0.939692736) * CFrame.new(0,-.05 * math.cos((sine)/10), 0),
CFrame.new(-0.500018835, -2.0000062, 2.08616257e-07, 0.939692438, 0, 0.342020929, 0, 1, 0, -0.342020959, 0, 0.939692438) * CFrame.new(0,-.05 * math.cos((sine)/10), 0),
}, .3, false)
end
elseif Torsovelocity > 2 and hit ~= nil then
Anim = "Walk"
if attack == false then
Humanoid.WalkSpeed = 16
PlayAnimationFromTable({
CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0, 0- .08 * math.cos((sine) / 2.5), 0) * CFrame.Angles(0, 0, 0),
CFrame.new(0, 1.48263013, -0.0984808952, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.540300786, -1.99793816, -9.82598067e-07, 0.998698533, -0.0510031395, 6.36324955e-07, 0.0510031395, 0.998698533, -1.00461093e-05, -8.35937328e-08, 1.08393433e-05, 1.00000024) * CFrame.new(0, 0, 0+ .5 * math.cos((sine) / 5)) * CFrame.Angles(math.rad(0 - 30 * math.cos((sine) / 5)), 0, 0), 
CFrame.new(-0.539563596, -1.99794078, 1.12228372e-06, 0.998635888, 0.0523072146, -1.77852357e-07, -0.0523072146, 0.998635888, -1.00715051e-05, -3.89727461e-07, 1.08406466e-05, 1.00000024) * CFrame.new(0, 0, 0- .5 * math.cos((sine) / 5)) * CFrame.Angles(math.rad(0 + 30 * math.cos((sine) / 5)), 0, 0), 
}, .3, false)
end
end
end
end
local basetpart = game.Players.Character:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
  sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end
end

if string.sub(msg, 1, 6) == (prefix.."sonic") then
       --[[KillerDarkness0105's/Codex's Sonic script]]--

 sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
       --sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)

function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end

loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()


wait(0.07)
Player=game:GetService("Players").LocalPlayer
Character=workspace.non
PlayerGui=Player.PlayerGui
Backpack=Player.Backpack
Torso=Character.Torso
Head=Character["Head"]
Humanoid=Character.Humanoid
LeftArm=Character["Left Arm"]
LeftLeg=Character["Left Leg"]
RightArm=Character["Right Arm"]
RightLeg=Character["Right Leg"]
LS=Torso["Left Shoulder"]
LH=Torso["Left Hip"]
RS=Torso["Right Shoulder"]
RH=Torso["Right Hip"]
Face = Head.face
Neck=Torso.Neck
it=Instance.new
attacktype=1
attacktype2=1
vt=Vector3.new
cf=CFrame.new
cn=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
combo = 0
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false
attackdebounce = false
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
stance = false
local ff = 2
noleg = false
evadecooldown = false
Humanoid.Animator.Parent = nil
equip = false
local Effects = {}
 attackspeed = 0.14 
 df = false
 Swing = 1
local sine = 0
local change = 1
local val = 0
local speed = 0
local rs = game:GetService("RunService").RenderStepped
cam = workspace.CurrentCamera
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create
deb = game:GetService("Debris")
Face.Transparency = 0
--Face.Texture = "rbxassetid://176217905" --176217905
Humanoid.WalkSpeed = 64
local freefall = 0

local boost = false
Humanoid.JumpPower = 88
local musicnum = 1
    
     local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
 local GravPoint = RootPart.Velocity.y
 local NV = Vector3.new(0,0,0)
print("Move list")
print("---------")
print("Shift = Boost")
print("Ctrl = Mach Speed Boost")
print("Q = Left QuickStep, E  = Right QuickStep")
print("C = Slide, in air to stomp")
print("Jump Then Hold B near a wall to wallrun")
print("M to change music, if you're standing still you'll do a special animation!")
print("Space near a wall to walljump, away from a wall homing attack")
		music = Instance.new("Sound",PlayerGui)
		music.Volume = 1
		music.TimePosition = 0
		music.Pitch = 1
		music.SoundId = "rbxassetid://1251555494"
		music.Looped = true
		music:Play()
		

		boostsound = Instance.new("Sound",PlayerGui)
		boostsound.Volume = .6
		boostsound.TimePosition = 0
		boostsound.Pitch = 1
		boostsound.SoundId = "rbxassetid://924922553"
		boostsound.Looped = false



		stompsound = Instance.new("Sound",PlayerGui)
		stompsound.Volume = 2
		stompsound.TimePosition = 0
		stompsound.Pitch = 1
		stompsound.SoundId = "rbxassetid://1295424184"
		stompsound.Looped = false



			       so = function(id,par,vol,pit)
		coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound",par or workspace)
		sou.Volume=vol
		sou.Pitch=pit or 1
		sou.SoundId=id
		sou:play()
		game:GetService("Debris"):AddItem(sou,8)
		end))
		end
		
		--save shoulders
		RSH, LSH=nil, nil
		--welds
		RW, LW=Instance.new("Weld"), Instance.new("Weld")
		RW.Name="Right Shoulder" LW.Name="Left Shoulder"
		LH=Torso["Left Hip"]
		RH=Torso["Right Hip"]
		TorsoColor=Torso.BrickColor
		function NoOutline(Part)
		Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
		end
		player=Player
		ch=Character
		RSH=ch.Torso["Right Shoulder"]
		LSH=ch.Torso["Left Shoulder"]
		--
		RSH.Parent=nil
		LSH.Parent=nil
		--
		RW.Name="Right Shoulder"
		RW.Part0=ch.Torso
		RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5)
		RW.C1=cf(0, 0.5, 0)
		RW.Part1=ch["Right Arm"]
		RW.Parent=ch.Torso
		--
		LW.Name="Left Shoulder"
		LW.Part0=ch.Torso
		LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8)
		LW.C1=cf(0, 0.5, 0)
		LW.Part1=ch["Left Arm"]
		LW.Parent=ch.Torso
		 
		 
		newWeld = function(wp0, wp1, wc0x, wc0y, wc0z)
		    local wld = Instance.new("Weld", wp1)
		    wld.Part0 = wp0
		    wld.Part1 = wp1
		    wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
		end
		 local rs = game:GetService("RunService").RenderStepped
		 
		newWeld(RootPart, Torso, 0, -1, 0)
		Torso.Weld.C1 = CFrame.new(0, -1, 0)
		newWeld(Torso, LeftLeg, -0.5, -1, 0)
		LeftLeg.Weld.C1 = CFrame.new(0, 1, 0)
		newWeld(Torso, RightLeg, 0.5, -1, 0)
		RightLeg.Weld.C1 = CFrame.new(0, 1, 0)
		
		    Player=game:GetService('Players').LocalPlayer
		    Character=Player.Character
		    mouse=Player:GetMouse()
		    m=Instance.new('Model',Character)
		 
		 
		    local function weldBetween(a, b)
		        local weldd = Instance.new("ManualWeld")
		        weldd.Part0 = a
		        weldd.Part1 = b
		        weldd.C0 = CFrame.new()
		        weldd.C1 = b.CFrame:inverse() * a.CFrame
		        weldd.Parent = a
		        return weldd
		    end
		   
		    ArtificialHB = Instance.new("BindableEvent", script)
		ArtificialHB.Name = "Heartbeat"
		 
		script:WaitForChild("Heartbeat")
		 
		frame = 1 / 80
		tf = 0
		allowframeloss = false
		tossremainder = false
		lastframe = tick()
		script.Heartbeat:Fire()
		game:GetService("RunService").Heartbeat:connect(function(s, p)
		    tf = tf + s
		    if tf >= frame then
		        if allowframeloss then
		            script.Heartbeat:Fire()
		            lastframe = tick()
		        else
		            for i = 1, math.floor(tf / frame) do
		                script.Heartbeat:Fire()
		            end
		            lastframe = tick()
		        end
		        if tossremainder then
		            tf = 0
		        else
		            tf = tf - frame * math.floor(tf / frame)
		        end
		    end
		end)
		 
--[[]
		function swait(num)
		    if num == 0 or num == nil then
		        ArtificialHB.Event:wait()
		    else
		        for i = 0, num do
		            ArtificialHB.Event:wait()
		        end
		    end
	end

	]]
	



	function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait()
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait()
		end
	end
end

		function RemoveOutlines(part)
		    part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
		end
		   
		
		part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
		  local fp = it("Part")
		  fp.formFactor = formfactor
		  fp.Parent = parent
		  fp.Reflectance = reflectance
		  fp.Transparency = transparency
		  fp.CanCollide = false
		  fp.Locked = true
		  fp.BrickColor = brickcolor
		  fp.Name = name
		  fp.Size = size
		  fp.Position = Torso.Position
		  NoOutline(fp)
		  if fp.BrickColor == BrickColor.new("Dark indigo") then
		    fp.Material = "Neon"
		  else
		    if fp.BrickColor == BrickColor.new("Really black") then
		      fp.BrickColor = BrickColor.new("Really black")
		      fp.Material = "Metal"
		    else
		      fp.Material = "Neon"
		    end
		  end
		  fp:BreakJoints()
		  return fp
		end
		
		mesh = function(Mesh, part, meshtype, meshid, offset, scale)
		  local mesh = it(Mesh)
		  mesh.Parent = part
		  if Mesh == "SpecialMesh" then
		    mesh.MeshType = meshtype
		    mesh.MeshId = meshid
		  end
		  mesh.Offset = offset
		  mesh.Scale = scale
		  return mesh
		end
		
		weld = function(parent, part0, part1, c0)
		  local weld = it("Weld")
		  weld.Parent = parent
		  weld.Part0 = part0
		  weld.Part1 = part1
		  weld.C0 = c0
		  return weld
		end
		
		F1 = Instance.new("Folder", Character)
		F1.Name = "Effects Folder"
		F2 = Instance.new("Folder", F1)
		F2.Name = "Effects"
		Triangle = function(a, b, c)
		end
		
		MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CanCollide = false
		  prt.CFrame = cframe
		  prt.Name = "prt"
		  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Block1", delay, x3, y3, z3})
		end
		
		
		
		MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CanCollide = false
		  prt.CFrame = cframe
		  prt.Name = "prt"
		  local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3})
		end
		
		MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CFrame = cframe
		  local msh = mesh("SpecialMesh", prt, "FileMesh", "http://www.roblox.com/asset/?id=20329976", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3})
		end
		
		MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt(0.2, 0.2, 0.2))
		  prt.Anchored = true
		  prt.CFrame = cframe
		  msh = mesh("SpecialMesh", prt, "Head", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  Effects[#Effects + 1] = {prt, "Cylinder", delay, x3, y3, z3}
		end
		
		MagicCylinder2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt(0.2, 0.2, 0.2))
		  prt.Anchored = true
		  prt.CFrame = cframe
		  msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  Effects[#Effects + 1] = {prt, "Cylinder", delay, x3, y3, z3}
		end
		
		MagicBlood = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CFrame = cframe
		  local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Blood", delay, x3, y3, z3})
		end
		
		ElecEffect = function(cff, x, y, z)
		  local prt = part(3, F2, 0, 0, BrickColor.new("Dark indigo"), "Part", vt(1, 1, 1))
		  prt.Anchored = true
		  prt.CFrame = cff * cf(math.random(-x, x), math.random(-y, y), math.random(-z, z))
		  prt.CFrame = cf(prt.Position)
		  game:GetService("Debris"):AddItem(prt, 2)
		  xval = math.random() / 2
		  yval = math.random() / 2
		  zval = math.random() / 2
		  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(xval, yval, zval))
		  Effects[#Effects + 1] = {prt, "Elec", 0.1, x, y, z, xval, yval, zval}
		end
		
		function FindNearestTorso(Position, Distance, SinglePlayer)
			if SinglePlayer then
				return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
			end
			local List = {}
			for i, v in pairs(workspace:GetChildren()) do
				if v:IsA("Model") then
					if v:findFirstChild("Torso") then
						if v ~= Character then
							if (v.Torso.Position - Position).magnitude <= Distance then
								table.insert(List, v)
							end 
						end 
					end 
				end 
			end
			return List
		end
		
		
		function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end
	
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh){
		Parent = Part,
		Offset = OffSet,
		Scale = Scale,
	}
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
		
		
		
function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {
			prt,
			"Block1",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 2 then
		table.insert(Effects, {
			prt,
			"Block2",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
end

function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay,material)
local prt=CreatePart(workspace,material,0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh,num) 
for i=0,1,delay do
swait()
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,(math.random(0,1)+math.random())/5)
end

function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end


function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function BreakEffect(brickcolor, cframe, x1, y1, z1)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	local num = math.random(10, 50) / 1000
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Shatter",
		num,
		prt.CFrame,
		math.random() - math.random(),
		0,
		math.random(50, 100) / 100
	})
end
		
		local lerp = function(a, b, t)
	return a * (1 - t) + b * t
end
		
		function clerp(a,b,t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1-t
		return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t))
		end
		 
		function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5/s
		return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5
		else
		local i = 0
		if m11 > m00 then
		i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
		i = 2
		end
		if i == 0 then
		local s = math.sqrt(m00-m11-m22+1)
		local recip = 0.5/s
		return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip
		elseif i == 1 then
		local s = math.sqrt(m11-m22-m00+1)
		local recip = 0.5/s
		return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip
		elseif i == 2 then
		local s = math.sqrt(m22-m00-m11+1)
		local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip
		end
		end
		end
		

		function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w*xs, w*ys, w*zs
		local xx = x*xs
		local xy = x*ys
		local xz = x*zs
		local yy = y*ys
		local yz = y*zs
		local zz = z*zs
		return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy))
		end
		function QuaternionSlerp(a, b, t)
		local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
		local theta = math.acos(cosTheta)
		local invSinTheta = 1/math.sin(theta)
		startInterp = math.sin((1-t)*theta)*invSinTheta
		finishInterp = math.sin(t*theta)*invSinTheta  
		else
		startInterp = 1-t
		finishInterp = t
		end
		else
		if (1+cosTheta) > 0.0001 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1/math.sin(theta)
		startInterp = math.sin((t-1)*theta)*invSinTheta
		finishInterp = math.sin(t*theta)*invSinTheta
		else
		startInterp = t-1
		finishInterp = t
		end
		end
		return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp
		end
		 
		function weld5(part0, part1, c0, c1)
		    weeld=Instance.new("Weld", part0)
		    weeld.Part0=part0
		    weeld.Part1=part1
		    weeld.C0=c0
		    weeld.C1=c1
		    return weeld
		end
		 
		--Example: Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
		 
		function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
	end
	
	
	



Character.Humanoid.MaxHealth = 120
Character.Humanoid.Health = 120
 
 local f = 0
 local b = Instance.new("BlurEffect",cam)
local    c = Instance.new('PointLight', Torso)
c.Range = 16
c.Color = Color3.new(0, 1,1)
c.Brightness = 1.5
 game:GetService("RunService"):BindToRenderStep("W0tT", 0, function()

b.Size = b.Size - 4
if boost == true then
c.Enabled = true
    cam.FieldOfView = lerp(cam.FieldOfView, 110, 0.5)
   -- cam.FieldOfView = 110
    freefall = 0
    Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,3),0.25)
 SphereEffect(BrickColor.new("Cyan"),RightLeg.CFrame*CFrame.new(0,-1,0)*angles(math.random(-180,180),math.random(-180,180),math.random(-180,180)),1.4,12,1.4,2.8,26,2.8,0.07)
  SphereEffect(BrickColor.new("Cyan"),LeftLeg.CFrame*CFrame.new(0,-1,0)*angles(math.random(-180,180),math.random(-180,180),math.random(-180,180)),1.4,12,1.4,2.8,26,2.8,0.07)
  if hitfloor ~= nil and Anim ~= "runIdle" then
  SpecialEffect(BrickColor.new("Cyan"),RootPart.CFrame*CFrame.new(0,-3.4,.78) ,2,2,2, 1.5,1.5,1.5,.09)
  end
end
if boost == false then
    cam.FieldOfView = lerp(cam.FieldOfView, 70, 0.076)
    --cam.FieldOfView = 70
    c.Enabled = false
end
end)



						 mouse.KeyDown:connect(function(key)
    if string.byte(key) == 48 then
        b.Size = 40
		Swing = 2
		freefall = 0
		
coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))
        Humanoid.WalkSpeed = 180
        RootPart.Velocity = RootPart.CFrame.lookVector*150
        RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-9.2) , 1, 1, 1, 8, 8, 8, 0.14,"Neon") 
        boost = true
        boostsound:Play()
end
end)

mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
		Swing = 1
        Humanoid.WalkSpeed = 64
        boost = false
        boostsound:Stop()

end
end)




						 mouse.KeyDown:connect(function(key)
    if string.byte(key) == 50 then
        b.Size = 40
        freefall = 0
		Swing = 2
		
coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.35*2.8,0.35*2.8),math.random(-0.35*2.8,0.35*2.8),math.random(-0.35*2.8,0.35*2.8)),0.48)
end
end))
		
        Humanoid.WalkSpeed = 320
        RootPart.Velocity = RootPart.CFrame.lookVector*550
        RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-9.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
        RingEffect(BrickColor.new("White"), RootPart.CFrame*CFrame.new(0,0,-11.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
        RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-13.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
        boost = true
        boostsound:Play()
end
end)

mouse.KeyUp:connect(function(key)
    if string.byte(key) == 50 then
		Swing = 1
        Humanoid.WalkSpeed = 64
        boost = false
        boostsound:Stop()

end
end)


local lastwall = nil
local jumped = false



		 
		 
		 
		 local vwall = false
		 
		 		 mouse.KeyDown:connect(function(key)
		     if key == 'b' and hitfloor == nil and attack == false then
	vrun()
end
 end)
 
 
 function vrun()
     		 	local ray = Ray.new(
		RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
	)
	local hit, position, normal = workspace:FindPartOnRay(ray, character)
	
	if hit then
	    if hit.Parent.Parent ~= Character and hit.Parent ~= Character and hit.Name ~= "prt" and hit.CanCollide == true then
	    vwall = true
	        local NV = Vector3.new(0,0,0)
	             local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
 local GravPoint = RootPart.Velocity.y
		local velo = Instance.new("BodyVelocity",Torso)
		velo.MaxForce = Vector3.new(400000,400000,400000)

		attack = true
while vwall == true and ray and hit do
swait()
change = 0.84+ Humanoid.WalkSpeed/132
if Humanoid.WalkSpeed > 40 and Humanoid.WalkSpeed < 70 then
velo.Velocity =  Vector3.new(0,40,0)
end
if Humanoid.WalkSpeed > 70 and Humanoid.WalkSpeed < 200 then
		velo.Velocity =  Vector3.new(0,80,0)
		end
		if Humanoid.WalkSpeed > 200 then
		velo.Velocity =  Vector3.new(0,130,0)
		end
		 ray = Ray.new(
		RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
	)
	hit, position, normal = workspace:FindPartOnRay(ray, character)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/2), .6) * angles(math.rad(96), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+20*math.sin(sine/2)),math.rad(0),math.rad(0+5*math.sin(sine/4)) + RootPart.RotVelocity.Y / 13),.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.1) * angles(math.rad(-90-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(15+2*math.sin(sine/4))- RootPart.RotVelocity.Y / 34),.15)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.1)*angles(math.rad(-90-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-15+2*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34),.15)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.28*math.cos(sine/4), 0-0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0+104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.3+ Humanoid.WalkSpeed/272)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.28*math.cos(sine/4),0+0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0-104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.3+ Humanoid.WalkSpeed/272)
end
		velo:Destroy()
		wait(0.07)

if vwall == false then

 RootPart.Velocity = -RootPart.CFrame.lookVector*68 + Vector3.new(0,86,0)

--[[]
		for i = 0,5,0.2 do
rs:wait()
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.79, 0) * CFrame.Angles(math.rad(0+100*i), math.rad(0), math.rad(0)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(0)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(180), math.rad(-60), math.rad(40)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(180), math.rad(60), math.rad(-40)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
end
]]


for i = 0,4,0.1 do
swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
end

 		attack = false


end


		if vwall == true then
 RootPart.Velocity = RootPart.CFrame.lookVector*38 + Vector3.new(0,86,0)

--[[]
		for i = 0,5,0.2 do
rs:wait()
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.79, 0) * CFrame.Angles(math.rad(0+100*i), math.rad(0), math.rad(0)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(0)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(180), math.rad(-60), math.rad(40)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(180), math.rad(60), math.rad(-40)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
end
]]


for i = 0,4,0.15 do
swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0-260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
end

 		attack = false

end


end
end
end
 
 

 
 	 mouse.KeyUp:connect(function(key)
		     if key == 'b' and vwall == true then
	         vwall = false
	         end
	         end)
		 


		 
		 
function Ldash()
    
    

evadecooldown = true
attack = true
k = math.random(1,2) 
if k == 1 then
so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
else
 so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
 end
 
 
 


 --+173.8*i
for i = 0,.7,0.1 do
swait()
Head.Velocity = Head.CFrame.rightVector * -135
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(32)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(-9),math.rad(-14)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.2) * angles(math.rad(27), math.rad(0), math.rad(30)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(30)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(12)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(8)), 0.2)
end

attack = false
wait(0.08)
evadecooldown = false
 
 
end





function Rdash()
    
    

evadecooldown = true
attack = true
k = math.random(1,2) 
if k == 1 then
so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
else
 so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
 end
 
 
 
 

 --+173.8*i
for i = 0,.7,0.1 do
swait()
Head.Velocity = Head.CFrame.rightVector * 135
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-32)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(9),math.rad(14)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(-30)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.2) * angles(math.rad(27), math.rad(0), math.rad(-30)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-8)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-12)), 0.2)
end

attack = false
wait(0.08)
evadecooldown = false
 
 
end
local sliding = false


function Slide()
    
     local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
     spd = spd + 30
local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
 local GravPoint = RootPart.Velocity.y
 if spd > 40 and hitfloor ~= nil then
noleg = true

attack = true
k = math.random(1,2) 
if k == 1 then
so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
else
 so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
 end
 
 
 

 
 
 

 
 
 local NV = Vector3.new(0,0,0)
local bv = Instance.new("BodyVelocity", Torso)
bv.maxForce = Vector3.new(1/0,1/0,1/0)
bv.velocity = dir*spd
	        local bg = Instance.new("BodyGyro", Torso)
bg.maxTorque = Vector3.new(1/0,1/0,1/0)
bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)
Head.Running.SoundId = "rbxassetid://1295468446"
Head.Running.TimePosition = 0

Humanoid.PlatformStand = true
while spd > 2 and hitfloor ~= nil and sliding == true do
swait()
spd = spd - 0.95
bv.velocity = dir*spd + Vector3.new(0,0,0)
bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -2.3, 0) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(12)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(34),math.rad(0),math.rad(12)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(110), math.rad(0), math.rad(70)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.2) * angles(math.rad(0), math.rad(0), math.rad(-60)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -0.56, -0.2) * CFrame.Angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
end
bv:Destroy()
bg:Destroy()
Head.Running.SoundId = "rbxassetid://758199523"
Head.Running.TimePosition = 0
Humanoid.PlatformStand = false
attack = false
sliding = false
wait(0.05)
evadecooldown = false
 
 
end
end

function land()
    attack = true
   RootPart.Velocity = Vector3.new(0,0,0)
    WaveEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,-1,0) , 1, 1, 1, 3, 0.8, 3, 0.06) 
     so("http://www.roblox.com/asset/?id=1295424585", Torso, 3.5, 1)

coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.55*2.8,0.55*2.8),math.random(-0.55*2.8,0.55*2.8),math.random(-0.55*2.8,0.55*2.8)),0.44)
        Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -2, 0) * CFrame.Angles(math.rad(-16), math.rad(0), math.rad(0)), 0.5)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(7),math.rad(0),math.rad(0)),.5)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(87)),.5)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0) * angles(math.rad(0), math.rad(0), math.rad(-87)),.5)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, 0, -0.5) * CFrame.Angles(math.rad(16), math.rad(0), math.rad(0)), 0.5)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1.14, 0.2) * CFrame.Angles(math.rad(-17), math.rad(0), math.rad(0)), 0.5)
       
end
attack = false


end))



end




function stomp()
    attack = true
    stompsound:Play()
    
   while hitfloor == nil do 
       swait()
       b.Size = 12
        WaveEffect(BrickColor.new("Cyan"), LeftLeg.CFrame*CFrame.new(0,-2.4,0) , 1, 1, 1, 0.8, 0.8, 0.8, 0.14) 
       RootPart.Velocity = Vector3.new(0,RootPart.Velocity.y/1.6,0) +Vector3.new(0,-150,0)
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(0+4*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(140+12*math.cos(sine/1.3))), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(-140+12*math.cos(sine/1.3))), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(60+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3), -0.13) * CFrame.Angles(math.rad(0+4*math.cos(sine/1.3)), math.rad(3), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, .27+0.17*math.cos(sine/1.3), -0.56) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(0), math.rad(0)), 0.1)

end
 stompsound:Stop()
land()


end


function changemusic()
    musicnum = musicnum + 1
    music.TimePosition = 0
    local osix = false
    local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude
    if musicnum > 14 then
        musicnum = 1
    end
    if musicnum == 1 then
        music.SoundId = "rbxassetid://179029173"
    end
    if musicnum == 2 then
        music.SoundId = "rbxassetid://146443855"
        end
        if musicnum == 3 then
           music.SoundId = "rbxassetid://1342408291" 
          end
          if musicnum == 4 then
            music.SoundId = "rbxassetid://201219416"  
        end
        if musicnum == 5 then
music.SoundId = "rbxassetid://1390472571" 
end
        if musicnum == 6 then
            osix = true
music.SoundId = "rbxassetid://249974783" 
end
if musicnum == 7 then
    music.SoundId = "rbxassetid://1851880603"
end
if musicnum == 8 then
 music.SoundId = "rbxassetid://412034984"
end
if musicnum == 9 then
   music.SoundId = "rbxassetid://536915629"
end
if musicnum == 10 then
music.SoundId = "rbxassetid://1200005861"
end
if musicnum == 11 then
    music.SoundId = "rbxassetid://1055930631"
end
if musicnum == 12 then
    music.SoundId = "rbxassetid://300269553"
end
if musicnum == 13 then
    music.SoundId = "rbxassetid://199897052"
end
if musicnum == 14 then
  music.SoundId = "rbxassetid://638115895"  
end

if spd < 14 then
Humanoid.Jump = true

if osix == false then
so("rbxassetid://537371462",PlayerGui,2,1)
end


RootPart.Velocity = Vector3.new(0,102,0)
attack = true
wait(0.08)
for i = 0,7,0.1 do
    swait()
    RootPart.Velocity = Vector3.new(0,2,0)
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0-260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)

end
b.Size = 40
MoonEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,0) , 1, 1, 1, 8, 8, 8, 0.06) 

if osix == true then
osix = false
so("rbxassetid://156821036",PlayerGui,2,1)
end

Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -3, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 1)
for i = 0,5,0.1 do
    swait()
RootPart.Velocity = Vector3.new(0,3.5,0)
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1+0.1*i, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.21)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(22-2*i),math.rad(0),math.rad(0)),.21)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.09*i, 0) * angles(math.rad(20-6*i), math.rad(0), math.rad(90+13*i)), 0.21)
LW.C0 = clerp(LW.C0, CFrame.new(-1.0-0.12*i, 0.5, -0.4+0.05*i) * angles(math.rad(20+13*i), math.rad(0), math.rad(20-13*i)), 0.21)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(-22-4*i)), 0.21)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(22+4*i)), 0.21)
end
attack = false
end
end


  mouse.KeyDown:connect(function(key)
if key == 'q' and attack == false and evadecooldown == false then
Ldash()
end
end)
 
 
 
   mouse.KeyDown:connect(function(key)
if key == 'e' and attack == false and evadecooldown == false then
Rdash()
end
end)

   mouse.KeyDown:connect(function(key)
if key == 'c' and attack == false and evadecooldown == false and hitfloor ~= nil then
     sliding = true
Slide()
end
end)

   mouse.KeyDown:connect(function(key)
if key == 'c' and attack == false and hitfloor == nil then
     stomp()
end
end)


local walljump = false


function walljumpp()
    	local ray = Ray.new(
		Torso.CFrame.p, RootPart.CFrame.lookVector *5
	)
	local hit, position, normal = workspace:FindPartOnRay(ray, character)
	
	if hit then
	    if  hit.Parent.Parent ~= Character and hit.Parent ~= Character then
	    local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
	    GravPoint = 0
 	    freefall = 0
	    walljump = true 
	    Humanoid.AutoRotate = false
		local velo = Instance.new("BodyVelocity",Torso)
		velo.MaxForce = Vector3.new(400000,400000,400000)
		--game.Debris:AddItem(velo,0.1)
		attack = true
while hitfloor == nil and walljump == true and ray and hit  do
swait()
freefall = 0
GravPoint = GravPoint - 0.36
		 ray = Ray.new(
		RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
	)
	hit, position, normal = workspace:FindPartOnRay(ray, character)
velo.Velocity = vt(0,GravPoint,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.9) * CFrame.Angles(math.rad(5), math.rad(90), math.rad(8)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(7),math.rad(0),math.rad(86)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(120)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-60)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-6), math.rad(14), math.rad(-12)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(23)), 0.2)
end
if walljump == false then
    k = math.random(1,3) 
if k == 1 then
so("http://www.roblox.com/asset/?id=800121776", Head, 2.5, 1)
else if k == 2 then
 so("http://www.roblox.com/asset/?id=804889329", Head, 2.5, 1)
else if k == 3 then
     so("http://www.roblox.com/asset/?id=804907617", Head, 2.5, 1)
     end
     end
end
 
    velo:Destroy()
        attack = false
    coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
end
end))
    
    Humanoid.AutoRotate = true
    RootPart.Velocity = RootPart.CFrame.lookVector * -137 + Vector3.new(0,136,0)
    wait(0.07)
     RootPart.CFrame = CFrame.new(RootPart.CFrame.p,-RootPart.CFrame.lookVector)
end
if walljump == true then
 		attack = false
walljump = false
Humanoid.AutoRotate = true
velo:Destroy()
end
end
end
end

    
    local homed = nil
    function home()
        if walljump ~= true then
        		    	for i, v in pairs(FindNearestTorso(Torso.CFrame.p, 80)) do
				if v:FindFirstChild('Head') then
					Grabbed = true
					homed = v
				end
			end
    
    if homed ~= nil and homed:FindFirstChildOfClass("Humanoid").Health > 1 and walljump == false then
        					    so("http://www.roblox.com/asset/?id=162460823", Head, 1, .8)
        					    	   local SBall = Instance.new("Part",Character)
	SBall.Name = "Homing Ball"
	SBall.CanCollide = false
	SBall.Anchored = false
	SBall.Transparency = 0.64
	SBall.CFrame = CFrame.new(RootPart.CFrame.p)
	SBall.BrickColor = BrickColor.new("Toothpaste")
	SBall.Size = Vector3.new(1,1,1)
	SBall.Material = "Neon"
	SBallweld = Instance.new("Weld")
SBallweld.Parent = SBall
SBallweld.Part0 = RootPart
SBallweld.Part1 = SBall
SBallweld.C1 = CFrame.new(0, 1, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
        SBallweld.Part0 = RootPart
	local SBallmesh = Instance.new("SpecialMesh",SBall)
	SBallmesh.MeshType = "Sphere"
	SBallmesh.Scale = Vector3.new(6,6,6)
        	trail = Instance.new("Trail", Character)
a2 = Instance.new("Attachment", Torso) a2.Position = Vector3.new(0,2,0)
a3 = Instance.new("Attachment", Torso)a3.Position = Vector3.new(0,-2.5,0)
trail.Texture = "rbxassetid://0"
trail.Attachment0 = a2
trail.Attachment1 = a3
trail.Lifetime  =  0.353
trail.MinLength = 0.03
trail.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,1)})
trail.Color = ColorSequence.new(Color3.new(0,1,1), Color3.new(0, 0,0))
trail.LightEmission = 4.8
trail.TextureLength = 0.034
        trail.Enabled = true
 attack = true
	local position = Instance.new("BodyPosition",Torso)
	position.P = 68350
	position.maxForce = Vector3.new(math.huge,math.huge,math.huge)
	
        while homed ~= nil and (homed.Torso.Position-RootPart.Position).magnitude > 8 do
        swait()
        SBall.CFrame = CFrame.new(RootPart.CFrame.p)
    Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+420*math.abs(sine/3.2)), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
    position.Position = homed.Torso.Position + Vector3.new(0,2,0) 
end
		local bodvol=Instance.new("BodyVelocity")
bodvol.velocity= RootPart.CFrame.lookVector*240 + Vector3.new(0,30,0)
bodvol.P= 35200
bodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
bodvol.Parent=homed.Head
game:GetService("Debris"):AddItem(bodvol, 0.2)
homed:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(10,30))

position:Destroy()
trail.Enabled = false
SBall:Destroy()
RootPart.Velocity = Vector3.new(0,93.5,0)
    coroutine.resume(coroutine.create(function()
for i = 0,5,0.26 do
    swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1+0.1*i, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.21)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(22-2*i),math.rad(0),math.rad(0)),.21)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.09*i, 0) * angles(math.rad(20-6*i), math.rad(0), math.rad(90+13*i)), 0.21)
LW.C0 = clerp(LW.C0, CFrame.new(-1.0-0.12*i, 0.5, -0.4+0.05*i) * angles(math.rad(20+13*i), math.rad(0), math.rad(20-13*i)), 0.21)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(-22-4*i)), 0.21)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(22+4*i)), 0.21)
end
homed = nil
attack = false
end))

end
    
end


end











    










    
		 		 mouse.KeyDown:connect(function(key)
		 		     wait(0.16)
		     if string.byte(key) == 32 and hitfloor == nil and attack == false and walljump == false and Humanoid.Jump == true then
		 walljumpp()
	 end
	 		     if string.byte(key) == 32 and hitfloor == nil and attack == false and walljump == false and Humanoid.Jump == true then
		 home()
	 end
	 
if string.byte(key) == 32 and hitfloor == nil and attack == true and walljump == true then
walljump = false
end
	 end)
		 



   mouse.KeyDown:connect(function(key)
if key == 'm' and attack == false then
changemusic()
end
end)






   mouse.KeyUp:connect(function(key)
       wait(0.05)
if key == 'c' and sliding == true then
     sliding = false
end
end)
local look = 0



				while true do
    swait()
sine = sine + change
--speed = speed + music.PlaybackLoudness/90
local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
	
    local TiltVelocity = CFrame.new(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity))

local rlegray = Ray.new(RightLeg.Position+Vector3.new(0,0.54,0),Vector3.new(0, -1.75, 0))
local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, Character)

local llegray = Ray.new(LeftLeg.Position+Vector3.new(0,0.54,0),Vector3.new(0, -1.75, 0))
local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, Character)

    	local waterthing = Ray.new(RootPart.CFrame.p,Vector3.new(0,-1,0))
	local start, position = workspace:FindPartOnRay(waterthing, character)
	
	if start ~= nil and start.Material == "Water" then
	
    RootPart.Velocity = RootPart.Velocity + Vector3.new(0,6,0)
    
    end

if torvel<1  and Swing == 2 then
    boost = false
elseif torvel>1   and Swing == 2 then
    boost = true
    freefall = 0
end
if hitfloor ~= nil and freefall < 150 then
    freefall = 0
end
if freefall > 150 and hitfloor ~= nil then
land()
freefall = 0
end







		if RootPart.Velocity.y > 1 and hitfloor==nil then
Anim="Jump"





if attack==false then
change = 1
look = 0
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(4), math.rad(0), math.rad(0)), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10+2.05*math.cos(sine/5)),math.rad(0),math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20+2.05*math.cos(sine/5)), math.rad(-10), math.rad(50-2.05*math.cos(sine/5))), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20+2.05*math.cos(sine/5)), math.rad(-10), math.rad(-50+2.05*math.cos(sine/5))), 0.07)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, -0.6) * CFrame.Angles(math.rad(-25+3.05*math.cos(sine/5)), math.rad(-3), math.rad(0)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.47, -0.7) * CFrame.Angles(math.rad(-12+3.05*math.cos(sine/5)), math.rad(0), math.rad(0)), 0.1)
end

elseif RootPart.Velocity.y < -1 and freefall <150 and hitfloor==nil then
Anim="Fall"
change = 1
freefall = freefall +0.77


if attack==false then
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(7+4*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(140+12*math.cos(sine/1.3))), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(-140+12*math.cos(sine/1.3))), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(40+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3), -0.13) * CFrame.Angles(math.rad(18+7*math.cos(sine/1.3)), math.rad(3), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.37+0.17*math.cos(sine/1.3), -0.2) * CFrame.Angles(math.rad(32+7*math.cos(sine/1.3)), math.rad(0), math.rad(0)), 0.1)
end



elseif RootPart.Velocity.y < -1 and freefall > 150 and hitfloor==nil then
Anim="FreeFall"
change = 1


if attack==false then
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(-90+3*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(14+12*math.cos(sine/1.3)), math.rad(0), math.rad(110)), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(14+12*math.cos(sine/1.3)), math.rad(0), math.rad(-110)), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-12+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3),0.2) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(3), math.rad(-46)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.17*math.cos(sine/1.3), 0.2) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(0), math.rad(46)), 0.1)
end

elseif torvel<1 and hitfloor~=nil then
Anim="Idle"
change = 1
if attack==false and equip == false then
  
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.04*math.cos(sine/40), -0) * CFrame.Angles(math.rad(0-0.81*math.cos(sine/40)), math.rad(-40), math.rad(0)), 0.1)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0+2.6*math.sin(sine/40)),math.rad(0),math.rad(40)),0.1)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.55+0.04*math.sin(sine/40), 0-0.04*math.cos(sine/40)) * angles(math.rad(-2+1.3*math.cos(sine/40)), math.rad(0+4*math.sin(sine/40)), math.rad(6.3+2.2*math.cos(sine/40))),0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.55+0.04*math.sin(sine/40), 0-0.04*math.cos(sine/40)) * angles(math.rad(2+1.3*math.cos(sine/40)), math.rad(0-4*math.sin(sine/40)), math.rad(-6.3-2.2*math.cos(sine/40))),0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, llegendPoint.Y-LeftLeg.Position.Y+0.04*math.cos(sine/40), 0) * CFrame.Angles(math.rad(0+0.81*math.cos(sine/40)), math.rad(18+0.81*math.cos(sine/40)), math.rad(-2-0.81*math.cos(sine/40))),0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.57, rlegendPoint.Y-RightLeg.Position.Y+0.04*math.cos(sine/40), 0)  * CFrame.Angles(math.rad(0+0.81*math.cos(sine/40)), math.rad(-2+0.81*math.cos(sine/40)), math.rad(3-0.81*math.cos(sine/40))),0.1)
end


	
elseif torvel>1.5 and torvel<70 and hitfloor~=nil then
Anim="Walk"
change = 0.84+ Character.Humanoid.WalkSpeed/132
look = 0
if attack==false and equip == false then
					       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/2), -.8) * angles(math.rad(-26), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+20*math.sin(sine/2)),math.rad(0),math.rad(0+5*math.sin(sine/4)) + RootPart.RotVelocity.Y / 13),.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.1) * angles(math.rad(-60-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(15+2*math.sin(sine/4))- RootPart.RotVelocity.Y / 34),.15)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.1)*angles(math.rad(-60-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-15+2*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34),.15)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.28*math.cos(sine/4), 0-0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0+104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.3)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.28*math.cos(sine/4),0+0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0-104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.3)
end


		elseif torvel>=70 and torvel<200 and hitfloor~=nil then
		Anim="Run"
		change = 0.84+ Character.Humanoid.WalkSpeed/142
		if attack==false and equip == false then
					       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/1.5), -.8) * angles(math.rad(-37), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+25*math.sin(sine/1.5)),math.rad(0),math.rad(0+5*math.sin(sine/3)) + RootPart.RotVelocity.Y / 13),.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.3) * angles(math.rad(-72-8*math.sin(sine/1.5))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(1+0*math.cos(sine/3))- RootPart.RotVelocity.Y / 34),.25)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.3)*angles(math.rad(-72-8*math.sin(sine/1.5))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-1+0*math.cos(sine/3))+ RootPart.RotVelocity.Y / -34),.25)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.32*math.cos(sine/3), 0-0.42*math.cos(sine/3)) * CFrame.Angles(math.rad(0+134*math.sin(sine/3)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.44)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.32*math.cos(sine/3),0+0.42*math.cos(sine/3)) * CFrame.Angles(math.rad(0-134*math.sin(sine/3)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.44)
		end
		
		--[[
		if attack==false then
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1-0.4*math.cos(sine/5.5)/2, 0 *math.sin(sine/6.6)/2) * CFrame.Angles(math.rad(0) + -math.sin(sine/5.5)/1.2, math.rad(0), 0), .8)
		RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.4*math.cos(sine/5.5)/2,0 *-math.sin(sine/6.6)/2) * CFrame.Angles(math.rad(0) + math.sin(sine/5.5)/1.2, math.rad(0), 0), .8)
		end
		]]
		if attack==true and noleg == false then
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1-0.24*math.cos(sine/5), 0.+0.24*math.cos(sine/5)) * CFrame.Angles(math.rad(0-74*math.sin(sine/5)), math.rad(0), math.rad(0)), 0.3)
		   RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.24*math.cos(sine/5),0.-0.24*math.cos(sine/5)) * CFrame.Angles(math.rad(0+74*math.sin(sine/5)), math.rad(0), math.rad(0)), 0.3)
		end
		
		
		
				elseif torvel>=200 and hitfloor~=nil then
		Anim="MachRun"
		change = 0.84+ Character.Humanoid.WalkSpeed/182
		if attack==false and equip == false then
					       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/1), -3.8) * angles(math.rad(-44), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .2)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+25*math.sin(sine/1)),math.rad(0),math.rad(0+5*math.sin(sine/2)) + RootPart.RotVelocity.Y / 13),.2)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.5) * angles(math.rad(-78-12*math.sin(sine/1))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(-24+0*math.cos(sine/2))- RootPart.RotVelocity.Y / 34),.35)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.5)*angles(math.rad(-78-12*math.sin(sine/1))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(24+0*math.cos(sine/2))+ RootPart.RotVelocity.Y / -34),.35)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.42*math.cos(sine/2), 0-0.62*math.cos(sine/2)) * CFrame.Angles(math.rad(0+134*math.sin(sine/2)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.52)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.42*math.cos(sine/2),0+0.62*math.cos(sine/2)) * CFrame.Angles(math.rad(0-134*math.sin(sine/2)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.52)
		end
		
		

end









 if 0 < #Effects then
      for e = 1, #Effects do
        if Effects[e] ~= nil then
          local Thing = Effects[e]
          if Thing ~= nil then
            local Part = Thing[1]
            local Mode = Thing[2]
            local Delay = Thing[3]
            local IncX = Thing[4]
            local IncY = Thing[5]
            local IncZ = Thing[6]
            if Thing[1].Transparency <= 1 then
              if Thing[2] == "Block1" then
                Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                Mesh = Thing[1]:FindFirstChild("Mesh")
                if not Mesh then
                  Mesh = Instance.new("BlockMesh")
                end
                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
              elseif Thing[2] == "Cylinder" then
                  Mesh = Thing[1]:FindFirstChild("Mesh")
                  if not Mesh then
                    Mesh = Instance.new("BlockMesh")
                  end
                  Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                elseif Thing[2] == "Blood" then
                    Mesh = Thing[1]:FindFirstChild("Mesh")
                    if not Mesh then
                      Mesh = Instance.new("BlockMesh")
                    end
                    Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
                    Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                    Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                  elseif Thing[2] == "Elec" then
                      Mesh = Thing[1]:FindFirstChild("Mesh")
                      if not Mesh then
                        Mesh = Instance.new("BlockMesh")
                      end
                      Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                    elseif Thing[2] == "Disappear" then
                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                      end
            else
              Part.Parent = nil
              game:GetService("Debris"):AddItem(Part, 0)
              table.remove(Effects, e)
            end
          end
        end
      end
    end

end
local basetpart = game.workspace.non:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end
end







end)

-- end chat command



Mouse.KeyDown:connect(function(Key)
	if Key == prefix then
		BAR:CaptureFocus()
	end
end)

BAR.FocusLost:connect(function(enterPressed)
	if enterPressed then
	if string.sub(BAR.Text, 1, 6) == ("hammer") then
			

Bypass = "death"
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)




local pee = game.Players.LocalPlayer.Character["MARTILLO"]
local gold = game.Players.LocalPlayer.Character["MARTILLO"].Handle
gold.AccessoryWeld:Destroy()




local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = gold
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true

attachment1.CFrame = CFrame.Angles(-25.7,5,20) 
  attachment0.CFrame = CFrame.new(1,-3,-.1)
  
  




  
  ----fling attachments
  
 
--  local toolgoflingfling = Instance.new("BodyVelocity", gold)
--toolgoflingfling.MaxForce = Vector3.new(90000,90000,90000)
--toolgoflingfling.Velocity = Vector3.new(90000,90000,90000)

  

wait(0.1)

warn([[Have fun with sangWARE!]])

--loadstring(game:GetObjects("rbxassetid://4480871791")[1].Source)()
--wait(5)

-- 5325226148
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(0.1)



playerss = workspace.non

local ToolName = pee

Bypass = "death"


local IsDead = false
local StateMover = true



Bypass = "death"
plr = game.Players.LocalPlayer
--dead = false
char = plr.Character




wait(4)




--



-- game:GetService("Workspace").GoldAxe.Handle.Rotation = Vector3.new(-0,0,-50)


 --local lol = Instance.new("Attachment",Right Arm)

--The reality of my life isn't real but a Universe -makhail07
wait()
local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name)
print('God Loaded')
print('hahahAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')
char = playerss
local hum = char.Humanoid
local hed = char.Head
local lol = Instance.new("Attachment",char["Right Arm"])
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")



function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end

function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end






-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end


function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end


local kan = Instance.new("Sound",char)
kan.Volume = 1.25
kan.TimePosition = 0
kan.PlaybackSpeed = 1
kan.Pitch = 1
kan.SoundId = "rbxassetid://853707984"
kan.Name = "wrecked"
kan.Looped = true
kan:Play()

local currentThemePlaying = kan.SoundId
local currentPitch = kan.Pitch
local currentVol = kan.Volume
function newTheme(ID,timepos,pitch,vol)
local kanz = kan
--kanz:Stop()
kanz.Volume = vol
--kanz.TimePosition = timepos
kanz.PlaybackSpeed = pitch
kanz.Pitch = pitch
kanz.SoundId = ID
kanz.Name = "wrecked"
kanz.Looped = true
currentThemePlaying = kanz.SoundId
currentVol = kanz.Volume
currentPitch = kanz.Pitch
--kanz:Play()
--coroutine.resume(coroutine.create(function()
--wait(0.05)
--end))
end

--newTheme("rbxassetid://853707984",0,1.01,0.85)

function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end


--local RbxUtility = LoadLibrary("RbxUtility")
--local Create = RbxUtility.Create

local function Create(A)
local A = Instance.new(A)
return function(B)
for i,v in pairs(B) do
A[i] = v
end
return A
end
end
-------------------------------------------------------
-----------------------hammer--------------------------
---- WEAPON OR STUFF
local rarmor = CreateParta(m,1,0,"SmoothPlastic",BrickColor.Random())
----local weaponweld = CreateWeld(rarmor,tors,rarmor,-3,0,-0.5,math.rad(0),math.rad(0),math.rad(-40),0,0,0,math.rad(0),math.rad(0),math.rad(0))
--local MainWeldS = CreateWeld(Part475,rarmor,Part475,0,0,0,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local A0 = Instance.new("Attachment",rarmor)
local A1 = Instance.new("Attachment",rarmor)
tl1 = Instance.new('Trail',rarmor)
tl1.Attachment0 = A0
tl1.Attachment1 = A1
tl1.LightEmission = 1
tl1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
tl1.Lifetime = 0.6
tl1.Enabled = false


rarmor.Attachment.Name = "Attachment2"


-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
    --    if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
 --       hit.Parent:FindFirstChild("Head"):BreakJoints()
  --     end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
   --     if insta == true then
--      hit.Parent:FindFirstChild("Head"):BreakJoints()
  --      end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:service("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end


function Eviscerate(dude)
	if dude.Name ~= char then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
	--	d//ude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
				end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
					v:Destroy()
				end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
					for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
							o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							v.Color = maincolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.08
								end
								wait(0.5)
								PartEmmit1.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
function chatfunc(text, color)
	local chat = coroutine.wrap(function()
		if char:FindFirstChild("TalkingBillBoard") ~= nil then
			char:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local naeeym2 = Instance.new("BillboardGui", char)
		naeeym2.Size = UDim2.new(0, 100, 0, 40)
		naeeym2.StudsOffset = Vector3.new(0, 5, 0)
		naeeym2.Adornee = hed
		naeeym2.Name = "TalkingBillBoard"
		local tecks2 = Instance.new("TextLabel", naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SciFi"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 0
		tecks2.TextColor3 = color
		tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
		tecks2.Size = UDim2.new(1, 0, 0.5, 0)
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
				tecks2.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
				tecks2.Rotation = math.random(-5, 5)
			end
		end))
		for i = 1, string.len(text) do
			CFuncs.Sound.Create("rbxassetid://274118116", hed, 5.25, 0.115)
			tecks2.Text = string.sub(text, 1, i)
			swait(1)
		end
		wait(1)
		naeeym2:Destroy()
	end)
	chat()
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 703597239
local SONG2 = 853707984
local Music = Instance.new("Sound",tors)
Music.Volume = 2.5
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
----------------------------------------------------------------------------------
hum.WalkSpeed = 16
hum.JumpPower = 57
hum.Animator.Parent = nil
----------------------------------------------------------------------------------
--local Blobby = Instance.new("Part", char)
--Blobby.Name = "Blob"
--Blobby.CanCollide = false
--Blobby.BrickColor = BrickColor.new("Really black")
--Blobby.Transparency = 0
--Blobby.Material = "Plastic"
--Blobby.Size = Vector3.new(1, 1, 2)
--Blobby.TopSurface = Enum.SurfaceType.Smooth
--Blobby.BottomSurface = Enum.SurfaceType.Smooth

--local Weld = Instance.new("Weld", Blobby)
--Weld.Part0 = ra
--Weld.Part1 = Blobby
--Weld.C1 = CFrame.new(0, -2, 1.1)
--Weld.C0 = CFrame.Angles(Rad(-86),0,0)

--local M2 = Instance.new("SpecialMesh")
--M2.Parent = Blobby
--M2.MeshId = "http://www.roblox.com/asset/?id=10604848"
--M2.TextureId = "http://www.roblox.com/asset/?id=10605252"
--M2.Scale = Vector3.new(1, 1, 1)

--[[local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0, 3.5, 0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"
--naeeym2.PlayerToHideFrom = Player
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Fight Me"
tecks2.Font = Enum.Font.Bodoni
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(0, 0, 0)
tecks2.TextStrokeColor3 = Color3.new(1, 1, 1)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2]]
-------------------------------------------------------
--End Customization--
-------------------------------------------------------


-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
function Ban()
	attack = true
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
 --	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 9.5)) do
--		if v:FindFirstChild("Head") then
--			Eviscerate(v)
--		end
--	end
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
	attack = false
end
function BigBan()
	attack = true
--	Weld.C0 = CFrame.Angles(Rad(-90), Rad(-25), Rad(0))
	for i = 0, 3.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-6), Rad(45)), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
 --	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 14.5)) do
--		if v:FindFirstChild("Head") then
--			Eviscerate(v)
---		end
--	end
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(75), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-6), Rad(45)), 0.2)
	end
--	Weld.C0 = CFrame.Angles(Rad(-86),0,0)
	attack = false
end
function BANN()
	attack = true
--	M2.Scale = Vector3.new(2, 2, 2)
	for i = 0, 4.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(-20)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(.6* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-.8* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(156), Rad(-.6), Rad(45)), 0.2)
	end
	Cso("147722910", char, 10, 1)
	CameraEnshaking(2, 35)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
	Effects.Ring.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0) * angles(math.rad(90), math.rad(0), math.rad(0)), 0.5, 0.5, 0.1, 2, 2, 0, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 7, 10, 15, -0.1, 15, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 6, 10, 15, -0.1, 15, 0.02)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 4, 10, 15, -0.1, 15, 0.01)
 --	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 19.5)) do
--		if v:FindFirstChild("Head") then
--			Eviscerate(v)
--		end
--	end
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
--	M2.Scale = Vector3.new(1, 1, 1)
	attack = false
end


-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------

game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(k)
   -- if string.byte(key) == 48 then
   Swing = 2
     hum.WalkSpeed = 38.82
--	end
end)
mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 1
        hum.WalkSpeed = 16
	end
end)
mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 'e' then
			BigBan()
		elseif key == 'r' then
			BANN()
		elseif key == 't' then
			Cso("1450018171", hed, 10, 1)
		end
	end
end)
mouse.Button1Down:connect(function(key)
    

    
    
	if attack == false then
		Ban()
	end
end)
 






-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		--Aura(5, 0.15, "Add", root.CFrame * CFrame.new(math.random(-5, 5), -10, math.random(-5, 5)) * CFrame.Angles(math.rad(90), 0, 0), 1.5, 1.5, 10, -0.015, maincolor, 0, "Sphere")
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(190), Rad(-.6), Rad(13)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel > 2 and torvel < 25 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(6 - 6.5 * Sin(sine / 7)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8* Player_Size - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8* Player_Size + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(190) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-37)  * Cos(sine / 7) , Rad(8 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
			end
		elseif torvel >= 25 and hitfloor ~= nil then
			Anim = "Sprint"
			change = 1.35
			if attack == false then
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
			RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925* Player_Size - 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         	LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925* Player_Size + 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(215) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-75) , Rad(8 * Cos(sine / 7)) ,	Rad(-13) + la.RotVelocity.Y / 75), 0.15)
			end
		end
	end
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 1.5
	Music.Parent = tors
	Music:Resume()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
	end
	if string.sub(BAR.Text, 1, 7) == ("shotgun") then
			
--//====================================================\\--
--||			   CREATED BY SHACKLUSTER shotgun script
--\\====================================================//--
--repeat wait() until script:WaitForChild'Owner'.Value

wait(0.1)

Bypass = "death"
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
        sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
        sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


local shottie = game.Players.LocalPlayer.Character["Type-12Accessory"].Handle
shottie.AccessoryWeld:Destroy()
shottie.BodyBackAttachment:Destroy()


local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = shottie
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true


attachment0.CFrame = CFrame.new(0.3,1.9,-.1)
attachment1.CFrame = CFrame.Angles(4,1.7,-10) 


loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(1)



	
wait(0.2)
Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = workspace.non
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local MOUSEPOS = RootPart.Position
local TIME = 0
local sick = Instance.new("Sound",Torso)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 3
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Type = "Ban"
local reason = "Ur damn skids nigga"
local Rooted = false
local SINE = 0
local SIZE = 1
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "BanishV3Gui"
local Characterb = IT("Model")
Characterb.Name = "shackisgaylol"
local CharacterA = IT("Model")
CharacterA.Name = "shackismegagaylol"
local Effects = IT("Folder", CharacterA)
Effects.Name = "Effects"
local Effects2 = IT("Folder", Characterb)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true
local TOBANISH = {}
script.Parent = PlayerGui

--//=================================\\
--\\=================================//


--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

local BODY = {}
for _, c in pairs(Character:GetDescendants()) do
	if c:IsA("BasePart") and c.Name ~= "Handle" then
		if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency})
	elseif c:IsA("JointInstance") then
		table.insert(BODY,{c,c.Parent,nil,nil,nil})
	end
end
for e = 1, #BODY do
	if BODY[e] ~= nil then
		local STUFF = BODY[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
		if PART.ClassName == "Part" and PART ~= RootPart then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)
	end
end

function refit()
	Character.Parent = workspace
	for e = 1, #BODY do
		if BODY[e] ~= nil then
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART:IsA("BasePart") and PART ~= RootPart then
				PART.Material = MATERIAL
				PART.Color = COLOR
				PART.Transparency = TRANSPARENCY+EXTRATRANS
			end
			if PART.Parent ~= PARENT then
				Humanoid:remove()
				PART.Parent = PARENT
				Humanoid = IT("Humanoid",Character)
			end
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end


function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "White", "Trail", VT(0,0,0))
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(0.5,DIST,0.5)
	else
		TRAIL.Size = VT(0.25,DIST,0.25)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.1
		end
		TRAIL:remove()
	end))
end

function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MagicSphereCo(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MagicBlock(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "ForceField", 0, 0.5, BRICKC(COLOR), "Effect", VT(SIZE,SIZE,SIZE), true)
	local mesh = IT("BlockMesh",wave)
	wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function CreateRing(SIZE, DOESROT, ROT, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
	local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "559831844", "", SIZE, VT(0, 0, 0))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
			end
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

local DECAL = IT("Decal")
function MagicRing()
	local RING = CreatePart(3, Effects, "Granite", 0, 1, "Maroon", "MagicRing", VT(0,0,0),true)
	local MESH = IT("BlockMesh",RING)
	local BOTTOMTEXTURE = DECAL:Clone()
	BOTTOMTEXTURE.Parent = RING
	BOTTOMTEXTURE.Face = "Bottom"
	BOTTOMTEXTURE.Name = "BottomTexture"
	local TOPTEXTURE = DECAL:Clone()
	TOPTEXTURE.Parent = RING
	TOPTEXTURE.Face = "Top"
	TOPTEXTURE.Name = "TopTexture"
	BOTTOMTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	TOPTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	BOTTOMTEXTURE.Color3 = C3(0,0,0)
	TOPTEXTURE.Color3 = C3(1,1,1)
	return RING,MESH,TOPTEXTURE,BOTTOMTEXTURE
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

--function SHAKECAM(POSITION, RANGE, INTENSITY, TIME)
--	local CHILDREN = workspace:GetDescendants()
--	for index, CHILD in pairs(CHILDREN) do
--		if CHILD.ClassName == "Model" then
	--		local HUM = CHILD:FindFirstChildOfClass("Humanoid")
		--	if HUM then
		--		local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
			--	if TORSO and RANGE >= (TORSO.Position - POSITION).Magnitude then
				--	local CAMSHAKER = script.CamShake:Clone()
				--	CAMSHAKER.Shake.Value = INTENSITY
				---	CAMSHAKER.Timer.Value = TIME
				--	CAMSHAKER.Parent = CHILD
				--	CAMSHAKER.Disabled = false
			--	end
	--		end
	--	end
--	end
--nd

--//=================================\\
--||	     WEAPON CREATION
--\\=================================//

--local Shotgun = script.Shotgun:Clone()
--Shotgun.Parent = RightArm
--CreateWeld(Shotgun.Handle,RightArm,Shotgun.Handle,0.2,-0.1,0.5,math.rad(90),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local Hole = shottie

local Particle = IT("ParticleEmitter",nil)
Particle.Enabled = false
Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
Particle.LightEmission = 0.5
Particle.Rate = 150
Particle.ZOffset = 0.2
Particle.Rotation = NumberRange.new(-180, 180)
Particle.RotSpeed = NumberRange.new(-180, 180)
Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
Particle.Color = ColorSequence.new(C3(0,1,0),C3(0,1.1,0))

--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
function ParticleEmitter(Table)
	local PRTCL = Particle:Clone()
	local Speed = Table.Speed or 5
	local Drag = Table.Drag or 0
	local Size1 = Table.Size1 or 1
	local Size2 = Table.Size2 or 5
	local Lifetime1 = Table.Lifetime1 or 1
	local Lifetime2 = Table.Lifetime2 or 1.5
	local Parent = Table.Parent or Torso
	local Emit = Table.Emit or 100
	local Offset = Table.Offset or 360
	local Acel = Table.Acel or VT(0,0,0)
	local Enabled = Table.Enabled or false
	PRTCL.Parent = Parent
	PRTCL.Size = NumberSequence.new(Size1,Size2)
	PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
	PRTCL.Speed = NumberRange.new(Speed)
	PRTCL.VelocitySpread = Offset
	PRTCL.Drag = Drag
	PRTCL.Acceleration = Acel
	if Enabled == false then
		PRTCL:Emit(Emit)
		Debris:AddItem(PRTCL,Lifetime2)
	else
		PRTCL.Enabled = true
	end
	return PRTCL
end

for _, c in pairs(CharacterA:GetChildren()) do
	if c.ClassName == "Part" then
		c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	end
end

CharacterA.Parent = Character

Characterb.Parent = Character


local SKILLTEXTCOLOR = C3(1,1,1)
local SKILLFONT = ""
local SKILLTEXTSIZE = 7

Humanoid.Died:connect(function()
	ATTACK = true
end)

--[[local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.1, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.63, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.215, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.525, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")
local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 5 Frame")
]]
--[[local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Banish Bullet", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 1")
local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B] Ability 2", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 2")
local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C] Ability 3", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 3")
local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V] Ability 4", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 4")
local SKILL5TEXT = CreateLabel(SKILL5FRAME, "[X] Mercy", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 5")
]]

function chatfunc(text)
	local chat = coroutine.wrap(function()
	if Character:FindFirstChild("TalkingBillBoard")~= nil then
		Character:FindFirstChild("TalkingBillBoard"):destroy()
	end
	local Bill = Instance.new("BillboardGui",Character)
	Bill.Size = UDim2.new(0,100,0,40)
	Bill.StudsOffset = Vector3.new(0,3,0)
	Bill.Adornee = Character.Head
	Bill.Name = "TalkingBillBoard"
	local Hehe = Instance.new("TextLabel",Bill)
	Hehe.BackgroundTransparency = 1
	Hehe.BorderSizePixel = 0
	Hehe.Text = ""
	Hehe.Font = "SourceSansItalic"
	Hehe.TextSize = 40
	Hehe.TextStrokeTransparency = 0
	Hehe.Size = UDim2.new(1,0,0.5,0)
	coroutine.resume(coroutine.create(function()
		while Hehe ~= nil do
			Swait()	
			Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
			Hehe.Rotation = math.random(-5,5)
			Hehe.TextColor3 = Color3.new(0,0,0)
			Hehe.TextStrokeColor3 = Color3.new(1,1,1)
		end
	end))
	for i = 1,string.len(text),1 do
		Swait()
		Hehe.Text = string.sub(text,1,i)
	end
	Swait(90)--Re[math.random(1, 93)]
	for i = 0, 1, .025 do
		Swait()
		Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
		Hehe.TextStrokeTransparency = i
		Hehe.TextTransparency = i
	end
	Bill:Destroy()
	end)
chat()
end

function onChatted(msg)
	chatfunc(msg)
end

Player.Chatted:connect(onChatted)

function printbye(Name)
	local MESSAGES = {"You cannot struggle, ","Your existance is an insult, ","Fade, ","Your existance is not desired, ","You are not permitted here, ","You are not to decide your fate, ","Be gone, ","You are already dead, ","Your live is an anomaly, ","Don't dare to return, ","Why are you resisting, ","You cannot exist here, ","Why are you struggling, ","Your fate was already decided, ","Goodbye, ","You cannot ignore my command, ","You cannot resist my command, ","You already died, "}
	chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
end

workspace.ChildAdded:connect(function(instance)
    for BANISH = 1, #TOBANISH do
		if TOBANISH[BANISH] ~= nil then
			if instance.Name == TOBANISH[BANISH] then
				coroutine.resume(coroutine.create(function()
					printbye(instance.Name)
					instance:ClearAllChildren()
					Debris:AddItem(instance,0.0005)
				end))
			end
		end
	end
end)

--//=================================\\
--||			DAMAGING
--\\=================================//

function Banish(Foe)
	if Foe then
		coroutine.resume(coroutine.create(function()
			--if game.Players:FindFirstChild(Foe.Name) then
				table.insert(TOBANISH,Foe.Name)
				printbye(Foe.Name)
			--end
			Foe.Archivable = true
			local CLONE = Foe:Clone()
			Foe:Destroy()
			CLONE.Parent = Effects
			CLONE:BreakJoints()
			local MATERIALS = {"Glass","Neon"}
			for _, c in pairs(CLONE:GetDescendants()) do
				if c:IsA("BasePart") then
					if c.Name == "Torso" or c.Name == "UpperTorso" or c == CLONE.PrimaryPart then
 						CreateSound(340722848, c, 10, 1, false)
					end
					c.Anchored = true
					c.Transparency = c.Transparency + 0.2
					c.Material = MATERIALS[MRANDOM(1,2)]
					c.Color = C3(1,1,1)
					if c.ClassName == "MeshPart" then
						c.TextureID = ""
					end
					if c:FindFirstChildOfClass("SpecialMesh") then
						c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
					end
					if c:FindFirstChildOfClass("Decal") then
						c:FindFirstChildOfClass("Decal"):remove()
					end
					c.Name = "Banished"
					c.CanCollide = false
				else
					c:remove()
				end
			end
			local A = false
			for i = 1, 35 do
				if A == false then
					A = true
				elseif A == true then
					A = false
				end
				for _, c in pairs(CLONE:GetDescendants()) do
					if c:IsA("BasePart") then
						c.Anchored = true
						c.Material = MATERIALS[MRANDOM(1,2)]
						c.Transparency = c.Transparency + 0.8/35
						if A == false then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)
						elseif A == true then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)						
						end
					end
				end
				Swait()
			end
			CLONE:remove()
		end))
	end
end

function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end


function ManualDamage(Humanoid,Damage,TorsoPart)
	local defence = Instance.new("BoolValue",Humanoid.Parent)
	defence.Name = ("HitBy"..Player.Name)
	game:GetService("Debris"):AddItem(defence, 0.001)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health ~= 0 then
		local CritChance = MRANDOM(1,100)
		if Damage > Humanoid.Health then
			Damage = math.ceil(Humanoid.Health)
			if Damage == 0 then
				Damage = 0.1
			end
		end
		Humanoid.Health = Humanoid.Health - Damage
	end
end

local asd = Instance.new("ParticleEmitter")
asd.Color = ColorSequence.new(Color3.new(0.5, 0, 0), Color3.new(.3, 0, 0))
asd.LightEmission = .1
asd.Texture = "http://www.roblox.com/asset/?ID=291880914"
aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6),NumberSequenceKeypoint.new(1, 2)})
bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
asd.Transparency = bbb
asd.Size = aaa
asd.ZOffset = .9
asd.Acceleration = Vector3.new(0, -15, 0)
asd.LockedToPart = false
asd.EmissionDirection = "Back"
asd.Lifetime = NumberRange.new(1, 2)
asd.Rotation = NumberRange.new(-100, 100)
asd.RotSpeed = NumberRange.new(-100, 100)
asd.Speed = NumberRange.new(10)
asd.Enabled = false
asd.VelocitySpread = 999

function getbloody(victim,amount)
	local PART = CreatePart(3, Effects, "Metal", 0, 1, "Mid gray", "Blood", victim.Size)
	PART.CFrame = victim.CFrame
	local HITPLAYERSOUNDS = {"356551938","264486467"}
	Debris:AddItem(PART,5)
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	local prtcl = asd:Clone()
	prtcl.Parent = PART
	prtcl:Emit(amount*10)
end

function ManualAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ManualDamage(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function KickThatNigga(CHARACTER)
	g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 1
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
	 CreateSound("527749592", CHARACTER, 600, 1, false)
	for i,v in ipairs(CHARACTER:GetChildren()) do
		if v.ClassName == "Part" or v.ClassName == "MeshPart" then
			if v.Name ~= "HumanoidRootPart" then
				local BOD = v:Clone()
				BOD.CanCollide = false
				BOD.Anchored = true
				BOD.CFrame = v.CFrame
				BOD.Parent = kickfolder
				BOD.Material = "Granite"
				BOD.Color = C3(.3,0,0)
				if BOD:FindFirstChildOfClass("Decal") then
					BOD:FindFirstChildOfClass("Decal"):remove()
				end
				if BOD.Name == "Head" then
					naeeym2.Adornee = BOD
				end
				if BOD.ClassName == "MeshPart" then
					BOD.TextureID = ""
				end
			end
		end
	end
	for i,v in pairs(g) do
	v:remove()
	end 
	if CHARACTER ~= Character then
	CHARACTER:remove()
	end
	if CHARACTER.Name == "Helkern" then
		Character:BreakJoints()
	end
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
end

function ApplyAoE(POSITION,RANGE,ISKICKED)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISKICKED == true then
							KickThatNigga(CHILD)
						else
							if ISKICKED == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISKICKED == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

local BEANED = {}

function Ban(bitch)	
if bitch then	
g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 0
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
-- CreateSound("2570187601", bitch, 600, 1, false)
local Players = game:GetService("Players")
local fag = Players:FindFirstChild(bitch.Name)
--faggut:Kick()
	if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
		if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
		end
			if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
			end
				if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
				end
					if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
					end
						if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
						end
												if Players:FindFirstChild("Drago_TH") then
						end
						table.insert(BEANED,bitch.name)
	--]]
			--CreateSound("527749592", game.Workspace, 700, 1, false)
	--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
	--wait(6)
	--bitch:Remove()
end
end

local function CheckForBan(player)
	for i = 1, #BEANED do
		if player.Name == BEANED[i] then
			player:Kick("Ur mom gay skids") --Ban Reason Change between the '' to change the reason!
		end
	end
end


game.Players.PlayerAdded:connect(function()
	for i,v in pairs(game.Players:GetPlayers())do
		CheckForBan(v)
	end  
end)


function Kick(bitch)
g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 0
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
-- CreateSound("2570187601", bitch, 600, 1, false)
local Players = game:GetService("Players")
local fag = Players:FindFirstChild(bitch.Name)
--faggut:Kick()
	if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
		if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
		end
			if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
			end
				if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
				end
					if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
					end
						if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
	--[[
		for i,v in pairs(fag.Name) do
		if (v:lower() == newPlayer.Name:lower()) then
			newPlayer:Remove()
		end
	end]]--
			--CreateSound("527749592", game.Workspace, 700, 1, false)
	--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
	--wait(6)
	--bitch:Remove()
end


function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

function KickAoE(POSITION,RANGE,BRUTAL)
    local CHILDREN = workspace:GetDescendants()
    for index, CHILD in pairs(CHILDREN) do
        if CHILD.ClassName == "Model" and CHILD ~= Character then
            local HUM = CHILD:FindFirstChildOfClass("Humanoid")
            if HUM then
                local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                if TORSO then
                    if (TORSO.Position - POSITION).Magnitude <= RANGE then
                        if BRUTAL == true then
	if Type == "Banish" then
                            KickThatNigger(CHILD)
	elseif Type == "Ban" then
		Ban(CHILD)
	elseif Type == "Kick" then
		Kick(CHILD)
			--elseif Type == "Tangle" then
		--Entangle(CHILD)
		end
                        else
                            CHILD:BreakJoints()
                        end
                    end
                end
            end
        end
    end
end

local PE=Instance.new("ParticleEmitter",art)
PE.LightEmission=.8
PE.Color = ColorSequence.new(BRICKC("Really red").Color)
PE.Lifetime=NumberRange.new(0.35,1.5)
PE.Rotation=NumberRange.new(0,360)
PE.Rate=999
PE.VelocitySpread = 10000
PE.Acceleration = Vector3.new(0,0,0)
PE.Drag = 5
PE.Speed = NumberRange.new(0,0,0)
PE.Texture="http://www.roblox.com/asset/?id=833874434"
PE.ZOffset = -1.5
PE.Name = "PE"
PE.Enabled = false

function particles(art)
	local PARTICLES = PE:Clone()
	PARTICLES.Parent = art
end

function KillChildren(v)
	v:BreakJoints()
	for _, c in pairs(v:GetChildren()) do
		if c.ClassName == "Part" or c.ClassName == "MesPart" then
			if c.Transparency < 1 then
				if c:FindFirstChildOfClass("Decal") then
					c:FindFirstChildOfClass("Decal"):remove()
				end
				particles(c)
				c.PE.Enabled = true
				c.Parent = Effects
				c.CanCollide = false
				c.Material = "Neon"
				c.Color = C3(1,0,0)
				c.Transparency = 0.5
				local grav = Instance.new("BodyPosition",c)
				grav.P = 20000
				grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
				grav.position = c.Position + VT(MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1))
				grav.Name = "GravityForce"
				coroutine.resume(coroutine.create(function()
				for i = 1, 50 do
					Swait()
					c.Transparency = c.Transparency + 0.01
				end
				c.PE.Enabled = false
				Debris:AddItem(c,2)
				end))
			end
		end
	end
end

function killnearest(position,range)
	for i,v in ipairs(workspace:GetChildren()) do
	local body = v:GetChildren()
		for part = 1, #body do
			if((body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character) then
				if(body[part].Position - position).Magnitude < range then
					if v.ClassName == "Model" then
						KillChildren(v)
					end
				end
			end
		end
	end
end

function Dismember(MAN,DOWHAT)
	for index, CHILD in pairs(MAN:GetDescendants()) do
		if CHILD:IsA("Script") or CHILD:IsA("LocalScript") then
			CHILD:Destroy()
		end
	end
	if DOWHAT == "Ragdoll" then
		local HUM = MAN:FindFirstChildOfClass("Humanoid")
		if HUM then
			HUM.Health = 0
		end
		if MAN:FindFirstChild("UpperTorso") then
			local SCRIPT = script.R15Ragdoll:Clone()
			SCRIPT.Parent = MAN
			SCRIPT.Disabled = false
		else
			local SCRIPT = script.R6Ragdoll:Clone()
			SCRIPT.Parent = MAN
			SCRIPT.Disabled = false
		end
		MAN:BreakJoints()
	else
		local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
		local HED = MAN:FindFirstChild("Head")
		if TORSO and HED then
			if DOWHAT == "Head" then
				if TORSO:FindFirstChild("TorsoA4") then
					TORSO:FindFirstChild("TorsoA4"):Remove()
				elseif MAN:FindFirstChild("RagdollConstraintHead") then
					MAN:FindFirstChild("RagdollConstraintHead"):Remove()
				end
				HED:BreakJoints()
			elseif DOWHAT == "RightArm" then
				if TORSO:FindFirstChild("TorsoA3") then
					TORSO:FindFirstChild("TorsoA3"):Remove()
				elseif MAN:FindFirstChild("RagdollConstraintRightUpperArm") then
					MAN:FindFirstChild("RagdollConstraintRightUpperArm"):Remove()
				end
			elseif DOWHAT == "LeftArm" then
				if TORSO:FindFirstChild("TorsoA2") then
					TORSO:FindFirstChild("TorsoA2")
				elseif MAN:FindFirstChild("RagdollConstraintLeftUpperArm") then
					MAN:FindFirstChild("RagdollConstraintLeftUpperArm"):Remove()
				end
			elseif DOWHAT == "Legs" then
				if TORSO.Name == "Torso" then
					if TORSO:FindFirstChild("TorsoA") then
						TORSO:FindFirstChild("TorsoA"):Remove()
					end
					if TORSO:FindFirstChild("TorsoA1") then
						TORSO:FindFirstChild("TorsoA1"):Remove()
					end
				elseif MAN:FindFirstChild("RagdollConstraintUpperTorso") then
					MAN:FindFirstChild("RagdollConstraintUpperTorso"):Remove()
				end
			end
		end
	end
end

function OofOuchBlood(LOCATION,TO,AMOUNT)
	local P = CreatePart(3, Effects, "Granite", 0, 1, BRICKC("Pearl"), "Blood", VT(0,0,0), true)
	P.CFrame = CF(LOCATION,TO)
	local BLOOD = MODULE.Blood:Clone()
	BLOOD.Parent = P
	BLOOD:Emit(AMOUNT)
	Debris:AddItem(P,2)
end

local DETECTKILL = function(HIT,POS,FORCE)
		if HIT.Parent:FindFirstChildOfClass("Humanoid") then
			if HIT.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
				local BV = IT("BodyVelocity")
				BV.MaxForce = BV.MaxForce * 500
				BV.Velocity = CF(RootPart.Position,HIT.Position+VT(0,5,0)).lookVector*(FORCE or 25)
				BV.Parent = HIT
				Debris:AddItem(BV,0.05)
				OofOuchBlood(POS,RootPart.Position,150)
			else
				OofOuchBlood(POS,RootPart.Position,2)
			end
		end
	end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

function Zone()
	ATTACK = true
	Rooted = true
	for i=0, 5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(-18)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-5), RAD(12), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function meme()
local TARGET = Mouse.Target
	if TARGET ~= nil then
		if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
			local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
			local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
			if ROOT and HUM.Health > 0 then
			local FOE = Mouse.Target.Parent
			RootPart.CFrame = ROOT.CFrame*CF(0.3,0,6)
			ROOT.Anchored = true
   local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
	if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
	 local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
	  local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
	   if TORSO and HUM.Health > 0 then
			ATTACK = true
			Rooted = false
			CreateSound(429459101, TORSO, 0.5, 1, false)
	for i=0, 2, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(85), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(90), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
		WACKYEFFECT({Time = 18, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(Hole.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = 136523485, SoundPitch = 1, SoundVolume = 5})
		for i=0, 0.5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.5, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(-6), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.2, -0.8) * ANGLES(RAD(85), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.4, -0.3) * ANGLES(RAD(90), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-25)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
		getbloody(TORSO,1)
	--	SHAKECAM(HITPOS, 15, 2, 130)
		killnearest(TORSO.Position, 5, 5)
		WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(10,10,10), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 0, SoundPitch = MRANDOM(13,15)/10, SoundVolume = 3})
		WACKYEFFECT({EffectType = "Sphere", Size = VT(6,6,6), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	ATTACK = false
	Rooted = false
		 end
	end
			end
		end
		end
			end

function Dance()
	ATTACK = true
	Rooted = true
	local LOOP = true
	KEY = Mouse.KeyDown:connect(function(NEWKEY)
		if NEWKEY == "t" then
			KEY:Disconnect()
			LOOP = false
		end
	end)
	repeat
		for i = 0, 0.4, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0.1 + ((1) - 1)) * ANGLES(RAD(-8), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.2, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(15)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(15)), 1 / Animation_Speed)
	end
		for i = 0, 1, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(26)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(26)), 1 / Animation_Speed)
	end
		for i = 0, 0.4, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0.1 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.2, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-15)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-15)), 1 / Animation_Speed)
	end
		for i = 0, 1, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-26)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-26)), 1 / Animation_Speed)
	end
	until LOOP == false
	ATTACK = false
	Rooted = false
end


--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//

-------------------------------------

Humanoid.Animator.Parent = nil

-------------------------------------


function MouseDown(Mouse)
	if ATTACK == false then
	end
end


function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "v" and ATTACK == false then
		meme()
		end
		
	if Key == "t" and ATTACK == false then
		Dance()
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

--//=================================\\
--\\=================================//


function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end


--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

local CONNECT = nil

while true do
	Swait()
	ANIMATE.Parent = nil
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.2 * COS(SINE / (WALKSPEEDVALUE))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 100, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 25), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1 - 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1 + 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
	end
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(15)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(45)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 0.15 / Animation_Speed)
			if MRANDOM(1,50) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-10,10)), RAD(MRANDOM(-10,10)), RAD(MRANDOM(-10,10))), 1 / Animation_Speed)
			end	
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.3, 0) * ANGLES(RAD(15 - 15 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 15 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.8, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(86), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-86), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
	end
	unanchor()
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	if sick.Parent ~= Torso then
	sick = IT("Sound", Torso)
	end
	sick.Parent = Torso
	sick.Playing = true
    sick.Looped = true
	sick.Volume = 2
	sick.Pitch = 1
	sick.SoundId = "rbxassetid://549162782"
	sick.Name = "Dead"
end

--//=================================\\
--\\=================================//





--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--

	end
	
	if string.sub(BAR.Text, 1, 4) == ("exit") then
    	    
    	    sangiscool.Frame:TweenPosition(UDim2.new(-0.409, 0,0.288, 0), 'Out', 'Elastic', 1, true)
    	    wait(7)
	    game.CoreGui.sangiscool:Destroy()
	    
	    end
	
	if string.sub(BAR.Text, 1, 3) == ("rpg") then
	wait(0.1)

--//====================================================\\--
--||                       BASIS
--\\====================================================//--


 sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
       --sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


local rpg = game.Players.LocalPlayer.Character["Back Attack Missle Launcher"].Handle
rpg.AccessoryWeld:Destroy()



local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = rpg
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true


attachment0.CFrame = CFrame.new(1.8,.5,-.3)
attachment1.CFrame = CFrame.Angles(.4,5,20) 

loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(1)




local MODULE = script
local CHARACTER = workspace.non
local PLAYER = game:GetService("Players"):GetPlayerFromCharacter(CHARACTER)
local HUM = CHARACTER.Humanoid
--local REMOTE = MODULE.Event
local ROOT = HUM.Torso
local HEAD = CHARACTER.Head
local TORSO = CHARACTER.Torso
local RIGHTARM = CHARACTER["Right Arm"]
local LEFTARM = CHARACTER["Left Arm"]
local RIGHTLEG = CHARACTER["Right Leg"]
local LEFTLEG = CHARACTER["Left Leg"]
local ROOTJOINT = ROOT["RootJoint"]
local NECK = TORSO["Neck"]
local RIGHTSHOULDER = TORSO["Right Shoulder"]
local LEFTSHOULDER = TORSO["Left Shoulder"]
local RIGHTHIP = TORSO["Right Hip"]
local LEFTHIP = TORSO["Left Hip"]
local MOUSEPOS = ROOT.Position
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor


--//====================================================\\--
--||                  BACKGROUND VALUES
--\\====================================================//--
local ANIM_SPEED = 3
local MOUSE = game.Players.LocalPlayer:GetMouse()
local Mouse = game.Players.LocalPlayer:GetMouse()
local MOUSEPOS = Mouse.Hit.p
local FRAME_SPEED = 1 / 60 -- (1 / 30) OR (1 / 60)
local CHANGE = 2 / ANIM_SPEED
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local KEYHOLD = false
local MOUSEHOLD = false
local SINE = 0
local ATTACKING = false
local Debris = game:GetService("Debris")
local Effects = IT("Folder",CHARACTER)
Effects.Name = "FXFolder"
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local BGM = 213546066
local BOMB = 2671146857
local STORED = 9999999999999
--//====================================================\\--
--||                     HEARTBEAT
--\\====================================================//--
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = FRAME_SPEED
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end
--//====================================================\\--
--||                       CLERP
--\\====================================================//--
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
--//====================================================\\--
--||                     FUNCTIONS
--\\====================================================//--
function WeldParts(A,B)
	local WLD = IT("ManualWeld")
	WLD.Part0 = A
	WLD.Part1 = B
	WLD.C1 = B.CFrame:inverse() * A.CFrame
	WLD.Parent = A
	return WLD
end
--NewSound({ID = 0,PARENT = ROOT,VOLUME = 0.5,PITCH = 1,LOOP = false,MAXDISTANCE = 1000,EMITTERSIZE = 10,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
function NewSound(TABLE)
	local ID = "rbxassetid://"..(TABLE.ID or 0)
	local PARENT = (TABLE.PARENT or ROOT)
	local VOLUME = (TABLE.VOLUME or 0.5)
	local PITCH = (TABLE.PITCH or 1)
	local LOOP = (TABLE.LOOP or false)
	local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
	local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
	local PLAYING = (TABLE.PLAYING or true)
	local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
	local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
	if ID ~= "rbxassetid://0" then
		local SOUND = IT("Sound",PARENT)
		SOUND.SoundId = ID
		SOUND.Volume = VOLUME
		SOUND.Pitch = PITCH
		SOUND.Looped = LOOP
		SOUND.MaxDistance = MAXDISTANCE
		SOUND.EmitterSize = EMITTERSIZE
		SOUND.PlayOnRemove = PLAYONREMOVE
		if DOESDEBRIS == true and PLAYING == true and LOOP == false then
			Debris:AddItem(SOUND,SOUND.TimeLength+5)
		end
		if PLAYING == true then
			SOUND:Play()
		end
		return SOUND
	end
end
function ManSlaughter(MAN)
	if MAN then
		local ROOT = MAN:FindFirstChild("HumanoidRootPart")
		if ROOT then
			ROOT:Remove()
		end
		local MANHUM = MAN:FindFirstChildOfClass("Humanoid")
		if MANHUM then
			MANHUM.BreakJointsOnDeath = false
			MANHUM.Health = 0
		end
		if MAN:FindFirstChild("R6Ragdoll") == nil and MAN:FindFirstChild("R15Ragdoll") == nil then
			if MAN:FindFirstChild("UpperTorso") then
				local SCRIPT = script.R15Ragdoll:Clone()
				SCRIPT.Parent = MAN
				SCRIPT.Disabled = false
			else
				local SCRIPT = script.R6Ragdoll:Clone()
				SCRIPT.Parent = MAN
				SCRIPT.Disabled = false
			end
			local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
			if TORSO then
				NewSound({ID = 146594648,PARENT = TORSO,VOLUME = 1,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 75,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
			end
		end
		MAN:BreakJoints()
		if MAN:FindFirstChild("Slaughtered") == nil then
			local MARK = IT("Folder",MAN)
			MARK.Name = "Slaughtered"
		else
			if MAN:FindFirstChild("Slaughtered") then
				local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
				if TORSO then
					TORSO.RotVelocity = VT(0,MRANDOM(-25,25),0)
				end
			end
		end
	end
end
function AreaOfEffect(AREA,RANGE,FLING,RETURN)
	local HIT = {}
	for index, CHILD in pairs(workspace:GetChildren()) do
		if CHILD:FindFirstChildOfClass("Humanoid") then
			local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
			local ROOT = HUMAN.Torso
			if ROOT then
				if (ROOT.Position - AREA).Magnitude <= RANGE then
					if RETURN == true then
						if CHILD ~= CHARACTER then
							table.insert(HIT,{CHILD,HUMAN,ROOT})
						end
					else
						if CHILD ~= CHARACTER then
							ManSlaughter(CHILD)
						end
						local BV = IT("BodyVelocity")
						BV.MaxForce = BV.MaxForce * 500
						BV.Velocity = CF(AREA,ROOT.Position+VT(0,0.5,0)).lookVector*FLING
						BV.Parent = ROOT
						Debris:AddItem(BV,0.05)
					end
				end
			end
		end
	end
	if RETURN == true then
		return HIT
	end
end
function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = ROOT.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end
function CameraShake(AREA,RANGE,SHAKE,TIMER)
	for index, CHILD in pairs(workspace:GetChildren()) do
		if CHILD:FindFirstChildOfClass("Humanoid") then
			local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
			local ROOT = HUMAN.Torso
			if ROOT and game.Players:GetPlayerFromCharacter(CHILD) then
				if (ROOT.Position - AREA).Magnitude <= RANGE then
					if CHILD:FindFirstChild("CamShake") then
						Debris:AddItem(CHILD:FindFirstChild("CamShake"),0.05)
					end
					local CAMSHAKE = script.CamShake:Clone()
					CAMSHAKE.Parent = CHILD
					local TIMER_V = IT("NumberValue",CAMSHAKE)
					TIMER_V.Name = "Timer"
					TIMER_V.Value = TIMER
					local SHAKE_V = IT("NumberValue",CAMSHAKE)
					SHAKE_V.Name = "Shake"
					SHAKE_V.Value = SHAKE
					CAMSHAKE.Disabled = false
					Debris:AddItem(CAMSHAKE,15)
				end
			end
		end
	end
end
--//====================================================\\--
--||                     CHARACTER
--\\====================================================//--

for index, CHILD in pairs(CHARACTER:GetChildren()) do
	if CHILD ~= ROOT then
		if CHILD:IsA("Accessory") then
			CHILD:Remove()
		end
	end
end
local FACE = HEAD.face
FACE.Texture = "rbxassetid://559113097"
--HELMET.CFrame = HEAD.CFrame*CF(0,0.5,0)
--HELMET.Anchored = false
--WeldParts(HEAD,HELMET)
--local BAZOOKA = MODULE.Bazooka
--.Parent = CHARACTER
--BAZOOKA.Anchored = false
--local GRIP = IT("Motor6D")
--GRIP.Part0 = RIGHTARM
--GRIP.Part1 = BAZOOKA
--GRIP.C0 = CF(0,-1,-0.5)*ANGLES(RAD(-90),0,0)*CF(0,0,1.85)
--local G_C0 = GRIP.C0
--GRIP.Parent = RIGHTARM
for i = 1, 15 do
	local FACE = CreatePart(3, CHARACTER, "Fabric", 0, 0+(i-1)/15.2, "Dark stone grey", "FaceGradient", VT(1.01,0.58,1.01),false)
	FACE.Color = C3(0,0,0)
	HEAD:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
	FACE.CFrame = HEAD.CFrame*CF(0,0.3-(i-1)/35,0)
	WeldParts(HEAD,FACE)
end
--local MISSILE = MODULE.Missile
--MISSILE.Parent = nil

--//====================================================\\--
--||                     ABILITIES
--\\====================================================//--
function Fire_in_the_hole()
	if STORED > 0 then
		ATTACKING = true
		local GYRO = IT("BodyGyro")
		GYRO.D = 50
		GYRO.P = 5000
		GYRO.MaxTorque = VT(0,4000000,0)
		GYRO.CFrame = CF(ROOT.Position,Mouse.Hit.p)
		GYRO.Parent = ROOT
		ATTACKING = true
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				GYRO.CFrame = CF(ROOT.Position,Mouse.Hit.p)
			until ATTACKING == false
			GYRO:Remove()
		end))
		repeat
			for i=0, 0.06, 0.1 / ANIM_SPEED do
				Swait()
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
			end
		--	AddTo(-1)
			coroutine.resume(coroutine.create(function()
				local GOTO = Mouse.Hit.p
				local ROCKET = MISSILE:Clone()
				ROCKET.Parent = Effects
				ROCKET.CFrame = CF(BAZOOKA.CFrame*CF(0,0,-2).p,GOTO)
				NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				NewSound({ID = 440145223,PARENT = ROCKET,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for i = 1, 200 do
					Swait()
					local HIT,POS = Raycast(ROCKET.Position,ROCKET.CFrame.lookVector,5,CHARACTER)
					if HIT then
						ROCKET.CFrame = CF(POS)
						break
					end
					ROCKET.CFrame = ROCKET.CFrame*CF(0,0,-4)
				end
				ROCKET.Transparency = 1
				ROCKET.Hind:Remove()
				ROCKET.CFrame = CF(ROCKET.Position)
				ROCKET.Size = VT(0,0,0)
				NewSound({ID = 142070127,PARENT = ROCKET,VOLUME = 7,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 300,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for index, CHILD in pairs(script.Grenade:GetChildren()) do
					local C = CHILD:Clone()
					C.Parent = ROCKET
					C:Emit(125)
				end
				CameraShake(ROCKET.Position,50,125,70)
				AreaOfEffect(ROCKET.Position,35,200,false)
				Debris:AddItem(ROCKET,2)
			end))
			for i=0, 0.025, 0.1 / ANIM_SPEED do
				Swait()
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(200), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
			end
		until MOUSEHOLD == false or STORED <= 0
		if STORED <= 0 then
			STORED = 0
			STOREDGUI.Text = "STORED: 0"
		end
		ATTACKING = false
	end
end
function Store()
	HUM.WalkSpeed = 0
	HUM.JumpPower = 0
	ATTACKING = true
	repeat
		for i=0, 0.01, 0.1 / ANIM_SPEED do
			Swait()
	--		GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
	
		for i=0, 0.02, 0.1 / ANIM_SPEED do
			Swait()
		--	GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.675, 0.45, 0.3) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
		for i=0, 0.02, 0.1 / ANIM_SPEED do
			Swait()
		--	GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
		NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 1,PITCH = MRANDOM(9,11)/6,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		for i=0, 0.05, 0.1 / ANIM_SPEED do
			Swait()
		--	GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.75, 0.45, -0.1) * ANGLES(RAD(45), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-0.9, 0.5, -0.75) * ANGLES(RAD(60), RAD(0), RAD(37.5)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
		end
	--	ROCKET:Remove()
	--	BAZOOKA.Face.Pop:Emit(5)
	--	AddTo(1)
	until KEYHOLD == false
	ATTACKING = false
	HUM.WalkSpeed = 100
	HUM.JumpPower = 50
end
function Dance()
	HUM.WalkSpeed = 0
	HUM.JumpPower = 0
	ATTACKING = true
	local REMOVETRACK = false
	local TRACK = nil
	if ROOT:FindFirstChild("BGM_MUSIC") then
		TRACK = ROOT:FindFirstChild("BGM_MUSIC")
		TRACK.Volume = 5
	else
		TRACK = NewSound({ID = BOMB,PARENT = ROOT,VOLUME = 5,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		REMOVETRACK = true
	end
	TRACK.SoundId = "rbxassetid://"..BOMB
	TRACK:Play()
	local DONEWITHDANCING = false
	local NC = mouse.KeyDown:connect(function(key)
		key=key:lower()
		local V2 = key
		if V2 == "m" then
			DONEWITHDANCING = true
			ATTACKING = false
			if REMOVETRACK == true then
				TRACK:Remove()
			else
				TRACK:Play()
				TRACK.Volume = 1.25
				TRACK.SoundId = "rbxassetid://"..BGM
			end
		end
	end)
	local I = 0
	local RAVE = IT("PointLight",ROOT)
	RAVE.Brightness = 25
	RAVE.Color = BrickColor.random().Color
	repeat
		I = I + 2
		Swait()
		RAVE.Color = BrickColor.random().Color
		ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0 - 0.32 * SIN(I / 10), 0, -0.55 - 0.05 * COS(I / 5)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
		NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
		RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(170), RAD(10), RAD(-35 * COS(I/10)))  *CF(0,-1,0) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
		LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(170), RAD(-10), RAD(-35 * COS(I/10))) * CF(0,-1,0) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
		RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1.35, -0.475 + 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-12 - 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
		LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.35, -0.475 - 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-12 + 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
	until DONEWITHDANCING == true
	RAVE:Remove()
	NC:Disconnect()
	if REMOVETRACK == true then
		TRACK:Remove()
	else
		TRACK:Play()
		TRACK.Volume = 1.25
		TRACK.SoundId = "rbxassetid://"..BGM
	end
	ATTACKING = false
	HUM.WalkSpeed = 100
	HUM.JumpPower = 50
end
--//====================================================\\--
--||                       WRAP
--\\====================================================//--
game.Players.LocalPlayer:GetMouse().Button1Down:connect(function()
	MOUSEHOLD = true
	if ATTACKING == false then
		Fire_in_the_hole()
	end
end)
game.Players.LocalPlayer:GetMouse().Button1Up:connect(function()
	MOUSEHOLD = false
end)
game.Players.LocalPlayer:GetMouse().KeyDown:connect(function(key)
	key=key:lower()
	local V2 = key
	KEYHOLD = true
				if V2 == "z" then
					Store()
				elseif V2 == "m" then
					Dance()
				elseif V2 == "t" then
					NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				elseif V2 == "e" then
					if ROOT:FindFirstChild("BGM_MUSIC") then
						ROOT:FindFirstChild("BGM_MUSIC"):Remove()
					else
						local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						M.Name = "BGM_MUSIC"
					end
				end
end)
game.Players.LocalPlayer:GetMouse().KeyUp:connect(function()
	KEYHOLD = false
end)
--[[
REMOTE.OnServerEvent:Connect(function(PLR,V1,V2)
	if PLR == PLAYER and ANIM ~= "Sit" then
		--if V1 == "MousePositionUpdate" then
			--MOUSEPOS = V2
		if V1 == "KeyUp" then
			KEYHOLD = false
		elseif V1 == "MouseUp" then
			MOUSEHOLD = false
		end
		if ATTACKING == false then
			if V1 == "MouseDown" then
				MOUSEHOLD = true
				Fire_in_the_hole()
			elseif V1 == "KeyDown" then
				KEYHOLD = true
				if V2 == "z" then
					Store()
				elseif V2 == "m" then
					Dance()
				elseif V2 == "t" then
					NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				elseif V2 == "e" then
					if ROOT:FindFirstChild("BGM_MUSIC") then
						ROOT:FindFirstChild("BGM_MUSIC"):Remove()
					else
						local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						M.Name = "BGM_MUSIC"
					end
				end
			end
		end
	end
end)
]]--
local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
M.Name = "BGM_MUSIC"
HUM.WalkSpeed = 100
while true do
	Swait()
	local MOUSEPOS = Mouse.Hit.p
	SINE = SINE + CHANGE
	if CHARACTER:FindFirstChild("Animate") then
		CHARACTER:FindFirstChild("Animate"):Destroy()
	end
	if CHARACTER:FindFirstChild("Sound") then
		CHARACTER:FindFirstChild("Sound"):Destroy()
	end
	for _,v in next, HUM:GetPlayingAnimationTracks() do
		v:Stop();
	end
	local TORSOVELOCITY = (ROOT.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = ROOT.Velocity.y
	local HITFLOOR = Raycast(ROOT.Position, (CF(ROOT.Position, ROOT.Position + VT(0, -1, 0))).lookVector, 4+HUM.HipHeight, CHARACTER)
	local WALKSPEEDVALUE = 0.5
	local SITTING = HUM.Sit
	if ANIM == "Walk" and TORSOVELOCITY > 1 and SITTING == false then
		RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 0.875 - 0.3 * SIN(SINE / WALKSPEEDVALUE), -0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RIGHTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
		LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 0.875 + 0.3 * SIN(SINE / WALKSPEEDVALUE), 0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LEFTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) or SITTING == true then
		RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
		LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
	end
---	if ATTACKING == false then
--		GRIP.C0 = Clerp(GRIP.C0, G_C0, 1.5 / ANIM_SPEED)
--	end
	if SITTING == false then
		if HITFLOOR then
			if TORSOVELOCITY < 1 and HITFLOOR ~= nil then
				ANIM = "Idle"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 6)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(100), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25 - 2.5 * COS(SINE / 6))) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
				end
			elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
				ANIM = "Walk"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.05 + 0.05 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(135), RAD(0), RAD(5 + 2.5 * COS(SINE / WALKSPEEDVALUE))) * RIGHTSHOULDERC0, 2 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(0), RAD(-25 - 2.5 * COS(SINE / WALKSPEEDVALUE))) * LEFTSHOULDERC0, 2 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1 , -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-15)), 2 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(15)), 2 / ANIM_SPEED)
				end
			end
		else
			if TORSOVERTICALVELOCITY > 0 then
				ANIM = "Jump"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(10)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 1 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
			    end
			else
				ANIM = "Fall"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(150), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / ANIM_SPEED)
				end
			end
		end
	else
		ANIM = "Sit"
		if ATTACKING == false then
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.65, 0) * ANGLES(RAD(50), RAD(-10), RAD(45))*CF(0,-0.25,0) * LEFTSHOULDERC0, 1.25 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.25, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.25 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -0.25, -1) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1.25 / ANIM_SPEED)
		end
	end
end
local basetpart = game.workspace.non:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end

	end
	if string.sub(BAR.Text, 1, 6) == ("insane") then
			

spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
        sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
        sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(5)

Ply = game.Players.LocalPlayer
--FIXED WITH TRIGECTORY's CheatSheet--
cheatsheetplr = game.Players.LocalPlayer
i = Instance.new("NumberValue", cheatsheetplr )
i.Name = "FPSCH"
Bin = Instance.new("HopperBin", cheatsheetplr .Backpack)
script.Parent = Bin
local cf = CFrame.new
local function Create(A)
local A = Instance.new(A)
return function(B)
for i,v in pairs(B) do
A[i] = v
end
return A
end
end
RW = Create("Weld")({Name = "Right Shoulder", Part0 = Tor, C0 = CFrame.new(1.5, 0.5, 0), C1 = CFrame.new(0, 0.5, 

0), Part1 = RA, Parent = Tor})
LW = Create("Weld")({Name = "Left Shoulder", Part0 = Tor, C0 = CFrame.new(-1.5, 0.5, 0), C1 = CFrame.new(0, 0.5, 

0), Part1 = LA, Parent = Tor})
wait(.05)
--Saz

debounce=true
etime=0
etimem=20
down=false

vPlayer=game.Players.LocalPlayer
cPlayer=nil
Humanoid=nil

Welds={}

stopVictoly=function()
	
	for _,v in pairs(Welds) do
		v.Parent = cPlayer.Torso
	end
	
	wait(.2)
	
	g1:Remove() g2:Remove() g3:Remove() g4:Remove() g5:Remove()
	
	b1:Remove() b2:Remove()
	
	p1:Remove() p2:Remove()
	
	bpos:Remove()
	brot:Remove()
	
	Head.Anchored=false
	
	Humanoid.PlatformStand=false
	
end
startVictoly=function()
	
	Welds={}

	cPlayer=workspace.non
	Humanoid = nil
	for _,v in pairs(cPlayer:children()) do
		if v.className=="Humanoid" then
			Humanoid=v
		end
		if v.Name=="Torso" then
			for __,vv in pairs(v:children()) do
				if vv:IsA("JointInstance") then
					table.insert(Welds,vv)
				end
			end
		end
	end
	
	Torso = cPlayer.Torso
	Head = cPlayer.Head
	RightArm = cPlayer["Right Arm"]
	LeftArm = cPlayer["Left Arm"]
	RightLeg = cPlayer["Right Leg"]
	LeftLeg = cPlayer["Left Leg"]
	
	Head.Anchored=true
	
	headpos = Head.CFrame.p
	
	print("DEAD")
	
	Humanoid.PlatformStand=true
	
	Torso.Anchored=true
	
	p1=Instance.new("Part",cPlayer)
	p1.Anchored=true
	p1.formFactor="Custom"
	p1.Size=Vector3.new(1,1,1)
	p1.TopSurface=0
	p1.BottomSurface=0
	p1.CanCollide=false
	p1.Name="AnchorR"
	p1.CFrame = Torso.CFrame * CFrame.new(.5,-3.5,0)
	p1.Transparency=1
	
	p2=Instance.new("Part",cPlayer)
	p2.Anchored=true
	p2.formFactor="Custom"
	p2.Size=Vector3.new(1,1,1)
	p2.TopSurface=0
	p2.BottomSurface=0
	p2.CanCollide=false
	p2.Name="AnchorL"
	p2.CFrame = Torso.CFrame * CFrame.new(-.5,-3.5,0)
	p2.Transparency=1
	
	g1=Instance.new("Glue",RightLeg)
	g1.Part0 = Torso
	g1.Part1 = RightLeg
	g1.C0 = CFrame.new(.5,-2,0)
	g1.C1 = CFrame.new(0,0,0)
	g1.F0 = Vector3.new(0,1,0)
	g1.F1 = Vector3.new(0,1,0)
	g1.F2 = Vector3.new(0,1,0)
	g1.F3 = Vector3.new(0,1,0)
	
	g2=Instance.new("Glue",p1)
	g2.Part0 = p1
	g2.Part1 = RightLeg
	g2.C0 = CFrame.new(0,1.5,0)
	g2.C1 = CFrame.new(0,0,0)
	g2.F0 = Vector3.new(.25,-1,.25)
	g2.F1 = Vector3.new(.25,-1,-.25)
	g2.F2 = Vector3.new(-.25,-1,.25)
	g2.F3 = Vector3.new(-.25,-1,-.25)
	
	g3=Instance.new("Glue",LeftLeg)
	g3.Part0 = Torso
	g3.Part1 = LeftLeg
	g3.C0 = CFrame.new(-.5,-2,0)
	g3.C1 = CFrame.new(0,0,0)
	g3.F0 = Vector3.new(0,1,0)
	g3.F1 = Vector3.new(0,1,0)
	g3.F2 = Vector3.new(0,1,0)
	g3.F3 = Vector3.new(0,1,0)
	
	g4=Instance.new("Glue",p2)
	g4.Part0 = p2
	g4.Part1 = LeftLeg
	g4.C0 = CFrame.new(0,1.5,0)
	g4.C1 = CFrame.new(0,0,0)
	g4.F0 = Vector3.new(.25,-1,.25)
	g4.F1 = Vector3.new(.25,-1,-.25)
	g4.F2 = Vector3.new(-.25,-1,.25)
	g4.F3 = Vector3.new(-.25,-1,-.25)
	
	g5=Instance.new("Glue",Torso)
	g5.Part0 = Head
	g5.Part1 = Torso
	g5.C0 = CFrame.new(0,0,0)
	g5.C1 = CFrame.new(0,1.5,0)
	g5.F0 = Vector3.new(0,0,0)
	g5.F1 = Vector3.new(0,0,0)
	g5.F2 = Vector3.new(0,0,0)
	g5.F3 = Vector3.new(0,0,0)
	
	for _,v in pairs(Welds) do
		if v.Name~="Neck" then
			print(v.Name)
			v.Parent = nil
			if v.Name=="Right Shoulder" then
				RSC0 = v.C0
				RSC1 = v.C1
			elseif v.Name=="Left Shoulder" then
				LSC0 = v.C0
				LSC1 = v.C1				
			end
		end
	end
	
	b1=Instance.new("Motor6D",RightArm)
	b1.Part0 = Torso
	b1.Part1 = RightArm
	b1.C0 = RSC0
	b1.C1 = RSC1 * CFrame.new(0,.25,0)
	
	b2=Instance.new("Motor6D",LeftArm)
	b2.Part0 = Torso
	b2.Part1 = LeftArm
	b2.C0 = LSC0
	b2.C1 = LSC1 * CFrame.new(0,.25,0)
	
	pos=Torso.Position
	brot=Instance.new("BodyAngularVelocity",Torso)
	brot.P=2250
	brot.maxTorque=Vector3.new(8000000,8000000,8000000)
	bpos=Instance.new("BodyPosition",Torso)
	bpos.P=4250
	bpos.D=150
	bpos.maxForce=Vector3.new(8000000000,0,8000000000)
	bpos.position=Torso.Position
	
	Torso.RotVelocity=Vector3.new()
	Torso.Velocity=Vector3.new()
	
	
	for i=1, 5 do
		for _,v in pairs(cPlayer:children()) do
			if v:IsA("BasePart") then
				v.Velocity=Vector3.new()
				v.RotVelocity=Vector3.new()
			end
		end
		wait(.05)
	end
	
	Torso.Neck.Parent=nil
	Torso.Anchored=false
	
	ex=0
	em = 0
	elo = 0
	
	local mus = Instance.new("Sound",Torso)
	mus.Volume = 1
	mus.SoundId="http://www.roblox.com/asset/?id=230597205"
	mus:Play()
	
	ded=false
	
	wait()
	
	li=Instance.new("PointLight",Torso)
	li.Range=25
	li.Brightness=5
	li.Shadows=true
	
	pos=Torso.CFrame
	
	while down do
		game:GetService("RunService").Heartbeat:wait()
		em = em+1
		elo = elo+1
		if em == 11 then
			brot.angularvelocity=Vector3.new(math.random(-26,26),math.random(-20,20)/6,math.random(-26,26)/2)
			bpos.position = (pos * CFrame.new(math.random(-20,20)/10,0,math.random(-20,20)/20)).p
			em = math.random(0,4)
			li.Color=Color3.new(math.random(100,255)/255,math.random(100,255)/255,math.random(100,255)/255)
		end
		
		b1.C0 = RSC0 * CFrame.new(math.cos(math.rad(elo*15))/20,.5,math.sin(math.rad(elo*15))/30) * CFrame.Angles(math.rad(ex/8)*elo - math.pi/3,math.cos(math.rad(elo*15))/100,math.sin(elo/8)*7)
		b2.C0 = LSC0 * CFrame.new(math.cos(math.rad(elo*15))/20,.5,math.sin(math.rad(elo*15))/30) * CFrame.Angles(math.rad(-ex/8)*elo - math.pi/3,math.sin(math.rad(elo*15))/100,-math.cos(elo/8)*7)
		
		ex = ex + math.random(-5,5)/5
		if ex > 50 then
			ex = 50
		elseif ex < 10 then
			ex = 20
		end
		
		if elo > 15 then
		
			if g1.Parent==nil or g2.Parent==nil or g3.Parent==nil or g4.Parent==nil or g5.Parent==nil or Humanoid.Health <= 0 then
				ded = true
				break
			end
			if g1.Part0==nil or g2.Part0==nil or g3.Part0==nil or g4.Part0==nil or g5.Part0==nil then
				ded = true
				break
			end
			if RightArm.Parent == nil or LeftArm.Parent == nil or LeftLeg.Parent==nil or RightLeg.Parent==nil then
				ded=true
				break
			end
		
		end
		
	end
	
	li:Remove()
	
	mus:Stop()
	
	if ded then
		Head.Anchored=false
		
		for _,v in pairs(cPlayer:children()) do
			if v:IsA("BasePart") then
				v:BreakJoints()
				v.CFrame = CFrame.new(Torso.Position + Vector3.new(math.random(-2,2),math.random(-1,2),math.random(-2,2))) * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				v.Velocity=Vector3.new(0,0,0)
			end
		end
		
		e=Instance.new("Explosion",workspace)
		e.BlastRadius=10
		e.BlastPressure=0
		e.Position=Torso.Position
		e.Hit:connect(function(hit) if hit.Parent == cPlayer and hit.Name~="AnchorR" and hit.Name~="AnchorL" then if hit:FindFirstChild("Fire") == nil then Instance.new("Fire",hit) end hit:BreakJoints() hit.Velocity = (e.Position - hit.Position).unit * 80 hit.RotVelocity = hit.Velocity end end)
		
		s=Instance.new("Sound",Head)
		s.SoundId="http://www.roblox.com/asset/?id=230597277"
		s.Volume=1
		s:Play()
		
		s=Instance.new("Sound",p1)
		s.SoundId="http://www.roblox.com/asset/?id=221920821"
		s.Volume=1
		s.Pitch=1.25
		s:Play()
	end
	
	wait(.5)
	mus:Remove()
	
end

onEquip=function(mouse)
	mouse.Button1Down:connect(function() down=true startVictoly() end)
	mouse.Button1Up:connect(function() down=false stopVictoly() end)
end
script.Parent.Selected:connect(onEquip)



	end
	
		if string.sub(BAR.Text, 1, 9) == ("traprifle") then
------------------------
--Aiju Love Trap Rifle--
----------------------------------------------------------------
--By CKbackup (Sugarie Saffron)                               --
--YT: https://www.youtube.com/channel/UC8n9FFz7e6Zo13ob_5F9MJw--
--Discord: Sugarie Saffron#4705                               --
----------------------------------------------------------------
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


local pee = game.Players.LocalPlayer.Character["METALXLIGHTSEER77Accessory"]
local gold = game.Players.LocalPlayer.Character["METALXLIGHTSEER77Accessory"].Handle
gold.AccessoryWeld:Destroy()




local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = gold
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true

attachment1.CFrame = CFrame.Angles(-2,4.6,-.9) 
  attachment0.CFrame = CFrame.new(1.2,0,-.3)
  
  

 -- local toolgoflingfling = Instance.new("BodyVelocity", gold)
--toolgoflingfling.MaxForce = Vector3.new(90000,90000,90000)
--toolgoflingfling.Velocity = Vector3.new(90000,90000,90000)
  plr = game.Players.LocalPlayer
dead = false
char = plr.Character
 
bullet = char["LongStraightHair"]
bhandle = bullet.Handle
bhandle.Mesh:Destroy()
wait()
bullet.Parent = workspace
 
mouse = plr:GetMouse()
head = char.Head
camera = workspace.CurrentCamera
lt = true
ltt = false
 
local function IsFirstPerson()
     return (head.CFrame.p - camera.CFrame.p).Magnitude < 1
end
 
     bbv = Instance.new("BodyVelocity",bhandle)
     
     mouse.Button1Down:Connect(function()
         if dead == false then
        lt = false
        ltt = true
      ltt = false
             bbav = Instance.new("BodyAngularVelocity",bhandle)
     bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
     bbav.P = 1000000000000000000000000000
     bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
        if game.Players:GetPlayerFromCharacter(mouse.Target.Parent) then
              repeat 
            game:GetService("RunService").RenderStepped:Wait()
            bhandle.Position = mouse.Target.Parent.HumanoidRootPart.CFrame.p
          print("haha no")
            wait(0.23)
           until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
        elseif game.Players:GetPlayerFromCharacter(mouse.Target.Parent.Parent) then
            repeat 
            game:GetService("RunService").RenderStepped:Wait()
            bhandle.Position = mouse.Target.Parent.Parent.HumanoidRootPart.CFrame.p
            wait(0.23)
            until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
 
            else
        repeat 
        game:GetService("RunService").RenderStepped:Wait()
        bhandle.Position = mouse.Hit.p
        wait(0.23)
        until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
        end
        wait()
        lt = true
         end
         end)
 
     char.Humanoid.Died:Connect(function()
         dead = true
     end)
     repeat 
         game:GetService("RunService").RenderStepped:Wait()
         if dead == false and bhandle.CanCollide == true then
         bhandle.CanCollide = false
         end
         if lt == true and dead == false then
         bhandle.CFrame = char.Head.CFrame + Vector3.new(0,-15,0)
         elseif ltt == true and dead == false then
        bhandle.CFrame = ghandle.CFrame * CFrame.new(-1.7,-2,0)
        bhandle.Rotation = char.HumanoidRootPart.Rotation
         end
    until char.Humanoid.Health == 0
 
function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end



--loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()

wait(10)


wait(1/60)
Effects = { }
local Player = game:service'Players'.localPlayer
loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()
playerss = workspace.non
local chara = workspace.non
local Humanoid = chara:FindFirstChildOfClass("Humanoid")
local Mouse = Player:GetMouse()
local LeftArm = chara["Left Arm"]
local RightArm = chara["Right Arm"]
local LeftLeg = chara["Left Leg"]
local RightLeg = chara["Right Leg"]
local Head = chara.Head
local Torso = chara.Torso
local Camera = workspace.CurrentCamera
local RootPart = chara.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local attack = false
local Anim = 'Idle'
local attacktype = 1
local delays = false
local play = true
local targetted = nil
local Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
local velocity = RootPart.Velocity.y
local sine = 0
local change = 1
local doe = 0
local Create = LoadLibrary("RbxUtility").Create
local debby = game:GetService("Debris")
Humanoid.WalkSpeed = 16

Humanoid.Animator.Parent = nil
chara.Animate.Parent = nil

local newMotor = function(part0, part1, c0, c1)
local w = Create('Motor'){
Parent = part0,
Part0 = part0,
Part1 = part1,
C0 = c0,
C1 = c1,
}
return w
end

function clerp(a, b, t)
return a:lerp(b, t)
end

RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

local RW = newMotor(Torso, RightArm, CFrame.new(1.5, 0, 0), CFrame.new(0, 0, 0)) 
local LW = newMotor(Torso, LeftArm, CFrame.new(-1.5, 0, 0), CFrame.new(0, 0, 0))
local RH = newMotor(Torso, RightLeg, CFrame.new(.5, -2, 0), CFrame.new(0, 0, 0))
local LH = newMotor(Torso, LeftLeg, CFrame.new(-.5, -2, 0), CFrame.new(0, 0, 0))
RootJoint.C1 = CFrame.new(0, 0, 0)
RootJoint.C0 = CFrame.new(0, 0, 0)
Torso.Neck.C1 = CFrame.new(0, 0, 0)
Torso.Neck.C0 = CFrame.new(0, 1.5, 0)

local rarmc1 = RW.C1
local larmc1 = LW.C1
local rlegc1 = RH.C1
local llegc1 = LH.C1

local resetc1 = false

function PlayAnimationFromTable(table, speed, bool)
RootJoint.C0 = clerp(RootJoint.C0, table[1], speed) 
Torso.Neck.C0 = clerp(Torso.Neck.C0, table[2], speed) 
RW.C0 = clerp(RW.C0, table[3], speed) 
LW.C0 = clerp(LW.C0, table[4], speed) 
RH.C0 = clerp(RH.C0, table[5], speed) 
LH.C0 = clerp(LH.C0, table[6], speed) 
if bool == true then
if resetc1 == false then
resetc1 = true
RootJoint.C1 = RootJoint.C1
Torso.Neck.C1 = Torso.Neck.C1
RW.C1 = rarmc1
LW.C1 = larmc1
RH.C1 = rlegc1
LH.C1 = llegc1
end
end
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")
frame = 0.03333333333333
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
tf = tf + s
if tf >= frame then
if allowframeloss then
script.Heartbeat:Fire()
lastframe = tick()
else
for i = 1, math.floor(tf / frame) do
script.Heartbeat:Fire()
end
lastframe = tick()
end
if tossremainder then
tf = 0
else
tf = tf - frame * math.floor(tf / frame)
end
end
end)
function swait(num)
if num == 0 or num == nil then
ArtificialHB.Event:wait()
else
for i = 0, num do
ArtificialHB.Event:wait()
end
end
end

function RemoveOutlines(part)
part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

function so(id,par,pit,vol)
local sou = Instance.new("Sound", par or workspace)
if par == chara then
sou.Parent = chara.Torso
end
sou.Volume = vol
sou.Pitch = pit or 1
sou.SoundId = "rbxassetid://" .. id
sou.PlayOnRemove = true
sou:Destroy()
end

--This is just for builds--
New = function(Object, Parent, Name, Data)
local Object = Instance.new(Object)
for Index, Value in pairs(Data or {}) do
Object[Index] = Value
end
Object.Parent = Parent
Object.Name = Name
return Object
end


function rayCast(Position, Direction, Range, Ignore)
return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) 
end 

function FindNearestTorso(Position, Distance, SinglePlayer)
if SinglePlayer then
return (SinglePlayer.Head.CFrame.p - Position).magnitude < Distance
end
local List = {}
for i, v in pairs(workspace:GetDescendants()) do
if v:IsA("Model") then
if v:findFirstChild("Head") then
if v ~= chara then
if (v.Head.Position - Position).magnitude <= Distance then
table.insert(List, v)
end 
end 
end 
end 
end
return List
end

EffectModel = Create("Model"){
Parent = chara,
Name = "Effects",
}

--Effect Functions--
Effects = {

Block = function(cf,partsize,meshstart,meshadd,matr,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("BlockMesh",p)
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
if spin == true then
p.CFrame = p.CFrame * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
end
end
p:Destroy()
end)()
return p
end,

Sphere = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshType = "Sphere"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Cylinder = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("CylinderMesh",p)
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Wave = function(cf,meshstart,meshadd,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://20329976"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Ring = function(cf,meshstart,meshadd,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://3270017"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Meshed = function(cf,meshstart,meshadd,colour,meshid,textid,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = meshid
m.TextureId = textid
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Explode = function(cf,partsize,meshstart,meshadd,matr,colour,move,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf * CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshType = "Sphere"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.new(0,move,0)
end
p:Destroy()
end)()
return p
end,

}

function GetDudesTorso(c)
local torsy = (c:findFirstChild("Torso") or c:findFirstChild("UpperTorso"))
if torsy ~= nil then
return torsy
end
end

function BodyVel(part,faws)
local bodyvel = Instance.new("BodyVelocity",part)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = faws
debby:AddItem(bodyvel,.2)
end

function Dmg(dude)
if dude and dude ~= chara and dude.Name ~= "CKbackup" then
if dude:FindFirstChild("TURAPPU") then return end
local debounce = Instance.new("BoolValue",dude)
debounce.Name = "TURAPPU"
coroutine.wrap(function()
local torsy = GetDudesTorso(dude)
if torsy then
local b = Instance.new("Part",dude)
b.BrickColor = BrickColor.new("Pink")
b.Size = Vector3.new(.1,.1,.1)
b.CanCollide = false
b.Transparency = 1
b.Material = "Neon"
b:BreakJoints()
so(113952851,b,1,3)
local bw = Instance.new("Weld",b)
bw.Part0 = b
bw.Part1 = torsy
local bm = Instance.new("SpecialMesh",b)
bm.MeshType = "Sphere"
bm.Scale = Vector3.new()
for i=0,1,.05 do
swait()
b.Transparency = 1-i
bm.Scale = Vector3.new(65*i,65*i,65*i)
end
coroutine.wrap(function()
swait(20)
for i=0,1,.05 do
swait()
b.Transparency = i
bm.Scale = Vector3.new(65+100*i,65+100*i,65+100*i)
end
b:Destroy()
end)()
end
for i,v in pairs(dude:children()) do
if v:IsA("Clothing") or v:IsA("BodyColors") or v:IsA("Accoutrement") then v:Destroy() end
end
local hedcol = dude:FindFirstChild("Head").BrickColor
local bcols = Instance.new("BodyColors",dude)
bcols.Name = "NeoCols"
bcols.HeadColor = hedcol
bcols.LeftArmColor = hedcol
bcols.RightArmColor = hedcol
bcols.TorsoColor = hedcol
bcols.LeftLegColor = hedcol
bcols.RightLegColor = hedcol
local Heiru = nil
local hacho = math.random(1,6)
if hacho == 1 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999847, 3.29998803, -42.2000351, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.075000003, 0.0599999987, 0.0599999987),MeshId = "rbxassetid://506240548",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(-7.62939453e-06, -1.19999862, 0.200000763, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 2 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.5, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.5499878, 4.29998732, -42.1000366, -1, 0, 0, 0, 1, 0, 0, 0, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(1.04999995, 1.04999995, 1.04999995),MeshId = "rbxassetid://398987591",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),C1 = CFrame.new(0.0499954224, -0.199999332, 0.100002289, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 3 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.5, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4499893, 3.89998746, -42.1000366, -1, 0, 0, 0, 1, 0, 0, 0, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{MeshId = "rbxassetid://164382853",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),C1 = CFrame.new(-0.0500030518, -0.599999189, 0.100002289, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 4 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999771, 2.79998851, -43.3000183, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.109999999, 0.0799999982, 0.0850000009),MeshId = "rbxassetid://561963999",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(-1.52587891e-05, -1.69999814, 1.29998398, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 5 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999847, 3.69998765, -42.600029, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.0450000018, 0.0450000018, 0.0450000018),MeshId = "rbxassetid://487000462",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(-7.62939453e-06, -0.799998999, 0.599994659, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 6 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.5, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.5499802, 3.29998803, -42.0000381, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.0649999976, 0.0599999987, 0.0599999987),MeshId = "rbxassetid://437152207",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(0.049987793, -1.19999862, 3.81469727e-06, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
end
local haircol = {"Pink","Baby blue","Magenta","Brown","Black","Really black","White","CGA brown","Cool yellow"}
Heiru.BrickColor = BrickColor.new(haircol[math.random(1,#haircol)])
local ercho = math.random(1,8)
if ercho == 1 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 4.59999943, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{Scale = Vector3.new(1.04999995, 1, 1.04999995),MeshId = "rbxassetid://10871984",TextureId = "rbxassetid://10871968",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.100012779, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 2 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 5.39999866, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{MeshId = "rbxassetid://1072759",TextureId = "rbxassetid://1072760",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.900012016, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 3 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.300000012, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.5499954, 5.29999876, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{Scale = Vector3.new(1.20000005, 1.20000005, 1.20000005),MeshId = "rbxassetid://1374148",TextureId = "rbxassetid://413143035",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0.0500030518, 0.800012112, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 4 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 5.29999876, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{Scale = Vector3.new(0.699999988, 0.5, 0.600000024),MeshId = "rbxassetid://361948302",TextureId = "rbxassetid://361948503",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.800012112, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 5 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 5.09999895, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{MeshId = "rbxassetid://1095510",TextureId = "rbxassetid://1095511",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.600012302, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
end
local oucho = math.random(1,6)
local sh = Instance.new("Shirt",dude)
local pn = Instance.new("Pants",dude)
if oucho == 1 then
pn.PantsTemplate = "rbxassetid://56903591"
sh:Destroy()
elseif oucho == 2 then
sh.ShirtTemplate = "rbxassetid://242933637"
pn.PantsTemplate = "rbxassetid://745334066"
elseif oucho == 3 then
sh.ShirtTemplate = "rbxassetid://1238151974"
pn.PantsTemplate = "rbxassetid://1340645290"
elseif oucho == 4 then
sh.ShirtTemplate = "rbxassetid://583471131"
pn.PantsTemplate = "rbxassetid://460147365"
elseif oucho == 5 then
pn.PantsTemplate = "rbxassetid://45541243"
sh:Destroy()
elseif oucho == 6 then
pn.PantsTemplate = "rbxassetid://41162775"
sh:Destroy()
end
Instance.new("Decal",dude:FindFirstChild("Head")).Texture = "rbxassetid://985062039"
coroutine.wrap(function()
swait(40)
local naeeym2 = Instance.new("BillboardGui",dude)
naeeym2.Size = UDim2.new(0,100,0,40)
naeeym2.StudsOffset = Vector3.new(0,3,0)
naeeym2.Adornee = dude:FindFirstChild("Head")
naeeym2.Name = "TalkingBillBoard"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.BorderSizePixel = 0
tecks2.Text = "Trapped! In another sense.."
tecks2.Font = "Cartoon"
tecks2.TextSize = 24
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(1,.6,.7)
tecks2.TextStrokeColor3 = Color3.new(1,1,1)
tecks2.Size = UDim2.new(1,0,0.5,0)
swait(10)
for i = 0,1,.05 do
swait()
tecks2.Position = tecks2.Position - UDim2.new(0,0,.005,0)
tecks2.TextStrokeTransparency = i
tecks2.TextTransparency = i
end
naeeym2:Destroy()
end)()
end)()
end
end

function MagnitudeDmg(par,magni)
for _, c in pairs(workspace:GetDescendants()) do
local hum = c:FindFirstChildOfClass("Humanoid")
if hum ~= nil and c:FindFirstChild("IsTeamMateOfCK")==nil then
local head = GetDudesTorso(c)
if head ~= nil then
local targ = head.Position - par.Position
local mag = targ.magnitude
if magni >= mag and c ~= chara then
Dmg(c)
end
end
end
end
end

local mus = Instance.new("Sound",Head)
mus.Name = "mus"
mus.SoundId = "rbxassetid://1131624146"
mus.Looped = true
mus.Volume = 1
mus:Play()

zhold = false
function shoot()
attack = true
for i=0,1,.3 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(0.0823832005, 1.55974865, -0.0981806219, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
CFrame.new(1.02804303, 0.5, -0.52656126, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
CFrame.new(-1.28728318, 0.203263342, -0.756378591, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
CFrame.new(0.499997735, -1.99999893, -1.11758709e-06, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
CFrame.new(-0.500001431, -1.99999893, -9.983778e-07, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
}, .4, false)
end
Humanoid.WalkSpeed = 2
local ref = Instance.new("Part",chara)
ref.Size = Vector3.new(0,0,0)
ref.Anchored = true
ref.CanCollide = false
ref.Transparency = 1
repeat
so(1145251796,ShotPt,math.random(95,105)/100,3)
ref.CFrame = Mouse.Hit
MagnitudeDmg(ref,2)
--Effects.Block(ShotPt.CFrame,Vector3.new(1,1,1),Vector3.new(),Vector3.new(.2,.2,.2),"Neon","Pink",true,false,.1)
--Effects.Block(CFrame.new((ShotPt.Position + Mouse.Hit.p)/2,Mouse.Hit.p),Vector3.new(1,1,(ShotPt.Position - Mouse.Hit.p).magnitude),Vector3.new(.2,.2,1),Vector3.new(.1,.1,0),"Neon","Pink",false,false,.1)
--Effects.Block(Mouse.Hit,Vector3.new(1,1,1),Vector3.new(),Vector3.new(.2,.2,.2),"Neon","Pink",true,false,.1)
for i=0,1,.5 do
swait()
PlayAnimationFromTable({		
CFrame.new(2.25380063e-06, 0, 0.100001052, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(0.0823859125, 1.55974913, -0.0981838703, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
CFrame.new(1.25785875, 0.5, -0.333723217, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
CFrame.new(-1.05747044, 0.203263938, -0.563540041, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
CFrame.new(0.423390329, -1.99999893, -0.0642812699, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
CFrame.new(-0.57660532, -1.99999893, -0.0642794371, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
}, .4, false)
end
for i=0,1,.5 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(0.0823832005, 1.55974865, -0.0981806219, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
CFrame.new(1.02804303, 0.5, -0.52656126, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
CFrame.new(-1.28728318, 0.203263342, -0.756378591, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
CFrame.new(0.499997735, -1.99999893, -1.11758709e-06, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
CFrame.new(-0.500001431, -1.99999893, -9.983778e-07, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
}, .4, false)
end
until zhold == false
ref:Destroy()
Humanoid.WalkSpeed = 16
attack = false
end

function doge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
local bodyvel = Instance.new("BodyVelocity",RootPart)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.413182259, -0.492409885, 1, 0, 0, 0, 0.173647001, 0.984807968, 0, -0.984807968, 0.173647001),
CFrame.new(0, 1.39017391, 0.409808099, 1, 0, 0, 0, 0.499998748, -0.866026163, 0, 0.866026163, 0.499998748),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(-0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -1.30470812, -0.622091293, 1, 0, 0, 0, -0.866025984, 0.499998987, 0, -0.499998987, -0.866025984),
CFrame.new(0, 1.47984993, -0.230206192, 1, 0, 0, 0, 0.939693034, 0.34201926, 0, -0.34201926, 0.939693034),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(-0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -2.22375727, 0.305265486, 1, 0, 0, 0, 0.500000238, -0.866025388, 0, 0.866025388, 0.500000238),
CFrame.new(0, 1.35128808, -0.383415997, 1, 0, 0, 0, 0.766043901, 0.642788529, 0, -0.64278847, 0.766043901),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999337, -0.599998593, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024),
CFrame.new(-0.500003815, -1.35979521, -0.923200667, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
bodyvel:Destroy()
Humanoid.WalkSpeed = 16
attack = false
end

function bdoge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
local bodyvel = Instance.new("BodyVelocity",RootPart)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = RootPart.CFrame.lookVector*-50
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -2.22375727, 0.305265486, 1, 0, 0, 0, 0.500000238, -0.866025388, 0, 0.866025388, 0.500000238),
CFrame.new(0, 1.35128808, -0.383415997, 1, 0, 0, 0, 0.766043901, 0.642788529, 0, -0.64278847, 0.766043901),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999337, -0.599998593, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024),
CFrame.new(-0.500003815, -1.35979521, -0.923200667, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*-50
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -1.30470812, -0.622091293, 1, 0, 0, 0, -0.866025984, 0.499998987, 0, -0.499998987, -0.866025984),
CFrame.new(0, 1.47984993, -0.230206192, 1, 0, 0, 0, 0.939693034, 0.34201926, 0, -0.34201926, 0.939693034),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(-0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*-50
end
bodyvel:Destroy()
Humanoid.WalkSpeed = 16
attack = false
end

function adoge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
Effects.Wave(RootPart.CFrame*CFrame.Angles(math.rad(90),0,0),Vector3.new(),Vector3.new(1,.1,1),"White",math.random(-10,10),false,.1)
BodyVel(RootPart,RootPart.CFrame.lookVector*50)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.095761165, -0.251516223, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
CFrame.new(0, 1.43075883, 0.149916381, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.96527231, 0.196966231, 1, 0, 0, 0, 0.984807789, 0.173648685, 0, -0.173648715, 0.984807789),
CFrame.new(-0.5, -1.43618584, -0.205210268, 1, 0, 0, 0, 0.939692438, 0.342020929, 0, -0.342020959, 0.939692438),
}, .4, false)
end
Humanoid.WalkSpeed = 16
attack = false
end

function badoge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
Effects.Wave(RootPart.CFrame*CFrame.Angles(math.rad(-90),0,0),Vector3.new(),Vector3.new(1,.1,1),"White",math.random(-10,10),false,.1)
BodyVel(RootPart,RootPart.CFrame.lookVector*-50)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.210508779, 0.312937856, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
CFrame.new(0, 1.4075644, -0.288293391, 1, 0, 0, 0, 0.866025388, 0.500000238, 0, -0.500000238, 0.866025388),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.9652698, 0.196958005, 1, 0, 0, 0, 0.984807789, 0.173648715, 0, -0.173648685, 0.984807789),
CFrame.new(-0.5, -1.43618536, -0.205215126, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676),
}, .4, false)
end
Humanoid.WalkSpeed = 16
attack = false
end

Mouse.Button1Down:connect(function()
if attack == false then
zhold = true
shoot()
end
end)

Mouse.Button1Up:connect(function()
zhold = false
end)

local sprintt = 0
Mouse.KeyDown:connect(function(k)
k = k:lower()
if k=='m' then
if mus.IsPlaying == true then
mus:Stop()
elseif mus.IsPaused == true then
mus:Play()
end
end
if attack == false then
if k == 'q' then
if Anim == "Fall" or Anim == "Jump" then
badoge()
else
bdoge()
end
elseif k == 'e' then
if Anim == "Fall" or Anim == "Jump" then
adoge()
else
doge()
end
end
end
end)

Mouse.KeyUp:connect(function(k)
k = k:lower()
if k == 'z' then
zhold = false
end
end)

coroutine.wrap(function()
while 1 do
swait()
if doe <= 360 then
doe = doe + 2
else
doe = 0
end
end
end)()
while true do
swait()
while true do
swait()
if Head:FindFirstChild("mus")==nil then
mus = Instance.new("Sound",Head)
mus.Name = "mus"
mus.SoundId = "rbxassetid://1131624146"
mus.Looped = true
mus.Volume = 1
mus:Play()
end
if sprintt >= 1 then
sprintt = sprintt - 1
end
Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
velocity = RootPart.Velocity.y
sine = sine + change
local hit, pos = rayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, chara)
if RootPart.Velocity.y > 1 and hit == nil then 
Anim = "Jump"
if attack == false then
PlayAnimationFromTable({
CFrame.new(0, 0.0382082276, -0.0403150208, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
CFrame.new(0, 1.46579528, 0.0939689279, 1, 0, 0, 0, 0.939692855, -0.342019796, 0, 0.342019796, 0.939692855),
CFrame.new(1.20945489, -0.213504896, 3.55388607e-07, 0.939692736, 0.342019916, 1.53461215e-07, -0.342019945, 0.939692736, 1.93715096e-07, -8.56816769e-08, -2.23517418e-07, 1.00000012),
CFrame.new(-1.20945573, -0.213503733, 5.0439985e-07, 0.939692736, -0.342019916, -1.53461215e-07, 0.342019945, 0.939692736, 1.93715096e-07, 8.56816769e-08, -2.23517418e-07, 1.00000012),
CFrame.new(0.5, -1.99739456, -0.0180913229, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
CFrame.new(-0.5, -1.30000103, -0.39999947, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676),
}, .3, false)
end
elseif RootPart.Velocity.y < -1 and hit == nil then 
Anim = "Fall"
if attack == false then
PlayAnimationFromTable({
CFrame.new(0, -0.0646628663, 0.0399149321, 1, 0, 0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849),
CFrame.new(0, 1.4913609, -0.128171027, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
CFrame.new(1.55285025, 0.466259956, -9.26282269e-08, 0.766043842, -0.642788351, -6.46188241e-08, 0.642788291, 0.766043961, -7.4505806e-08, 1.04308128e-07, 1.49011612e-08, 1.00000012),
CFrame.new(-1.5605253, 0.475036323, -2.10609159e-07, 0.766043842, 0.642788351, 6.46188241e-08, -0.642788291, 0.766043961, -7.4505806e-08, -1.04308128e-07, 1.49011612e-08, 1.00000012),
CFrame.new(0.500000954, -1.9973948, -0.0180922765, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
CFrame.new(-0.499999046, -1.30000043, -0.400000483, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
}, .3, false)
end
elseif Torsovelocity < 1 and hit ~= nil then
Anim = "Idle"
if attack == false then
change = 1
PlayAnimationFromTable({
CFrame.new(-0.0769465268, -7.7815578e-08, -0.031559173, 0.939695537, 1.01607293e-06, 0.342021346, 7.9855522e-07, 1.00000191, 5.12654879e-07, -0.342019558, 2.16066837e-07, 0.939692855) * CFrame.new(0,.05 * math.cos((sine)/10), 0),
CFrame.new(0.0615186803, 1.4999913, 0.0559706129, 0.939695537, 7.9855522e-07, -0.342019558, 1.01607293e-06, 1.00000191, 2.16066837e-07, 0.342021346, 5.12654879e-07, 0.939692855),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.500003159, -2.00000715, -1.98185444e-06, 0.939692736, 0, -0.342019916, 0, 1, 0, 0.342019886, 0, 0.939692736) * CFrame.new(0,-.05 * math.cos((sine)/10), 0),
CFrame.new(-0.500018835, -2.0000062, 2.08616257e-07, 0.939692438, 0, 0.342020929, 0, 1, 0, -0.342020959, 0, 0.939692438) * CFrame.new(0,-.05 * math.cos((sine)/10), 0),
}, .3, false)
end
elseif Torsovelocity > 2 and hit ~= nil then
Anim = "Walk"
if attack == false then
Humanoid.WalkSpeed = 16
PlayAnimationFromTable({
CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0, 0- .08 * math.cos((sine) / 2.5), 0) * CFrame.Angles(0, 0, 0),
CFrame.new(0, 1.48263013, -0.0984808952, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.540300786, -1.99793816, -9.82598067e-07, 0.998698533, -0.0510031395, 6.36324955e-07, 0.0510031395, 0.998698533, -1.00461093e-05, -8.35937328e-08, 1.08393433e-05, 1.00000024) * CFrame.new(0, 0, 0+ .5 * math.cos((sine) / 5)) * CFrame.Angles(math.rad(0 - 30 * math.cos((sine) / 5)), 0, 0), 
CFrame.new(-0.539563596, -1.99794078, 1.12228372e-06, 0.998635888, 0.0523072146, -1.77852357e-07, -0.0523072146, 0.998635888, -1.00715051e-05, -3.89727461e-07, 1.08406466e-05, 1.00000024) * CFrame.new(0, 0, 0- .5 * math.cos((sine) / 5)) * CFrame.Angles(math.rad(0 + 30 * math.cos((sine) / 5)), 0, 0), 
}, .3, false)
end
end
end
end
local basetpart = game.Players.Character:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
  sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end
		end
    
    	if string.sub(BAR.Text, 1, 4) == ("gale") then
	    

--cal hm  = sethiddenproperty(game.Players.CurbYismm.SimulationRadius            )
--int(hm)
---thiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end

loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()

print("cool")




--[[ Name : Gale Fighter ]]--
-------------------------------------------------------
--A Collaboration Between makhail07 and KillerDarkness0105

--Base Animaion by makhail07, attacks by KillerDarkness0105
-------------------------------------------------------


local FavIDs = {
	340106355, --Nefl Crystals
	927529620, --Dimension
	876981900, --Fantasy
	398987889, --Ordinary Days
	1117396305, --Oh wait, it's you.
	885996042, --Action Winter Journey
	919231299, --Sprawling Idiot Effigy
	743466274, --Good Day Sunshine
	727411183, --Knife Fight
	1402748531, --The Earth Is Counting On You!
	595230126 --Robot Language
	}



--The reality of my life isn't real but a Universe -makhail07
wait(0.2)
local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name)
print('yankee with no')
print('brim')
local char = workspace.non
local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")
hum.MaxHealth = 200
hum.Health = 200

-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
vt = Vector3.new
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 90
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------



-------------------------------------------------------
--Start Combo Function--
-------------------------------------------------------
local comboing = false
local combohits = 0
local combotime = 0
local maxtime = 65



function sandbox(var,func)
	local env = getfenv(func)
	local newenv = setmetatable({},{
		__index = function(self,k)
			if k=="script" then
				return var
			else
				return env[k]
			end
		end,
	})
	setfenv(func,newenv)
	return func
end
cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
comboframe = Instance.new("ScreenGui")
Frame1 = Instance.new("Frame")
Frame2 = Instance.new("Frame")
TextLabel3 = Instance.new("TextLabel")
comboframe.Name = "combinserter"
comboframe.Parent = mas
Frame1.Name = "combtimegui"
Frame1.Parent = comboframe
Frame1.Size = UDim2.new(0, 300, 0, 14)
Frame1.Position = UDim2.new(0, 900, 0.629999971, 0)
Frame1.BackgroundColor3 = Color3.new(0, 0, 0)
Frame1.BorderColor3 = Color3.new(0.0313726, 0.0470588, 0.0627451)
Frame1.BorderSizePixel = 5
Frame2.Name = "combtimeoverlay"
Frame2.Parent = Frame1
Frame2.Size = UDim2.new(0, 0, 0, 14)
Frame2.BackgroundColor3 = Color3.new(0, 1, 0)
Frame2.ZIndex = 2
TextLabel3.Parent = Frame2
TextLabel3.Transparency = 0
TextLabel3.Size = UDim2.new(0, 300, 0, 50)
TextLabel3.Text ="Hits:  "..combohits
TextLabel3.Position = UDim2.new(0, 0, -5.5999999, 0)
TextLabel3.BackgroundColor3 = Color3.new(1, 1, 1)
TextLabel3.BackgroundTransparency = 1
TextLabel3.Font = Enum.Font.Bodoni
TextLabel3.FontSize = Enum.FontSize.Size60
TextLabel3.TextColor3 = Color3.new(0, 1, 0)
TextLabel3.TextStrokeTransparency = 0
gui = game:GetService("Players").LocalPlayer.PlayerGui
for i,v in pairs(mas:GetChildren()) do
	v.Parent = game:GetService("Players").LocalPlayer.PlayerGui
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
	spawn(function()
		pcall(v)
	end)
end





coroutine.resume(coroutine.create(function()
	while true do
		wait()
		
		
		if combotime>65 then
		    combotime = 65
	    end
	    
	    
	    
	    
	    
		if combotime>.1 and comboing == true then
		    TextLabel3.Transparency = 0
		    TextLabel3.TextStrokeTransparency = 0
		    TextLabel3.BackgroundTransparency = 1
		    Frame1.Transparency = 0
		    Frame2.Transparency = 0
		       TextLabel3.Text ="Hits:  "..combohits
		    combotime = combotime - .34
Frame2.Size = Frame2.Size:lerp(UDim2.new(0, combotime/maxtime*300, 0, 14),0.42)
    end
    
    
    
    
	    if combotime<.1 then
	        		    TextLabel3.BackgroundTransparency = 1
	        		    TextLabel3.Transparency = 1
		    TextLabel3.TextStrokeTransparency = 1

Frame2.Size = UDim2.new(0, 0, 0, 14)
	        combotime = 0
	        comboing = false
	       		    Frame1.Transparency = 1
		    Frame2.Transparency = 1
		   combohits = 0 
	        
	        end
end
end))



-------------------------------------------------------
--End Combo Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
         if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
         if insta == true then
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:service("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end




	kDamagefunc=function(hit,minim,maxim,knockback,Type,Property,Delay,KnockbackType,decreaseblock)
        if hit.Parent==nil then
                return
        end
        h=hit.Parent:FindFirstChild("Humanoid")
        for _,v in pairs(hit.Parent:children()) do
        if v:IsA("Humanoid") then
        h=v
        end
        end
        if hit.Parent.Parent:FindFirstChild("Torso")~=nil then
        h=hit.Parent.Parent:FindFirstChild("Humanoid")
        end
        if hit.Parent.className=="Hat" then
        hit=hit.Parent.Parent:findFirstChild("Head")
        end
        if h~=nil and hit.Parent.Name~=char.Name and hit.Parent:FindFirstChild("Torso")~=nil then
        if hit.Parent:findFirstChild("DebounceHit")~=nil then if hit.Parent.DebounceHit.Value==true then return end end
        --[[                if game.Players:GetPlayerFromCharacter(hit.Parent)~=nil then
                        return
                end]]
--                        hs(hit,1.2) 
                        c=Instance.new("ObjectValue")
                        c.Name="creator"
                        c.Value=game:service("Players").LocalPlayer
                        c.Parent=h
                        game:GetService("Debris"):AddItem(c,.5)
                Damage=math.random(minim,maxim)
--                h:TakeDamage(Damage)
                blocked=false
                block=hit.Parent:findFirstChild("Block")
                if block~=nil then
                print(block.className)
                if block.className=="NumberValue" then
                if block.Value>0 then
                blocked=true
                if decreaseblock==nil then
                block.Value=block.Value-1
                end
                end
                end
                if block.className=="IntValue" then
                if block.Value>0 then
                blocked=true
                if decreaseblock~=nil then
                block.Value=block.Value-1
                end
                end
                end
                end
                if blocked==false then
--                h:TakeDamage(Damage)
                h.Health=h.Health-Damage
                kshowDamage(hit.Parent,Damage,.5,BrickColor.new("White"))
                else
                h.Health=h.Health-(Damage/2)
                kshowDamage(hit.Parent,Damage/2,.5,BrickColor.new("White"))
                end
                if Type=="Knockdown" then
                hum=hit.Parent.Humanoid
hum.PlatformStand=true
coroutine.resume(coroutine.create(function(HHumanoid)
swait(1)
HHumanoid.PlatformStand=false
end),hum)
                local angle=(hit.Position-(Property.Position+Vector3.new(0,0,0))).unit
--hit.CFrame=CFrame.new(hit.Position,Vector3.new(angle.x,hit.Position.y,angle.z))*CFrame.fromEulerAnglesXYZ(math.pi/4,0,0)
local bodvol=Instance.new("BodyVelocity")
bodvol.velocity=angle*knockback
bodvol.P=5000
bodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
bodvol.Parent=hit
rl=Instance.new("BodyAngularVelocity")
rl.P=3000
rl.maxTorque=Vector3.new(500,500,500)
rl.angularvelocity=Vector3.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))
rl.Parent=hit
game:GetService("Debris"):AddItem(bodvol,.5)
game:GetService("Debris"):AddItem(rl,.5)
                elseif Type=="Normal" then
                vp=Instance.new("BodyVelocity")
                vp.P=500
                vp.maxForce=Vector3.new(math.huge,0,math.huge)
--                vp.velocity=Character.Torso.CFrame.lookVector*Knockback
                if KnockbackType==1 then
                vp.velocity=Property.CFrame.lookVector*knockback+Property.Velocity/1.05
                elseif KnockbackType==2 then
                vp.velocity=Property.CFrame.lookVector*knockback
                end
                if knockback>0 then
                        vp.Parent=hit.Parent.Torso
                end
                game:GetService("Debris"):AddItem(vp,.5)
            elseif Type=="Up" then
                hit.Parent.Humanoid.PlatformStand = true
                local bodyVelocity=Instance.new("BodyVelocity")
                bodyVelocity.velocity=vt(0,15,0)
                bodyVelocity.P=5000
                bodyVelocity.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
                bodyVelocity.Parent=hit
                game:GetService("Debris"):AddItem(bodyVelocity,1)
                rl=Instance.new("BodyAngularVelocity")
                rl.P=3000
rl.AngularVelocity = Vector3.new(2000,2000,2000)
rl.MaxTorque = Vector3.new(40000,40000,40000)
                rl.Parent=hit
                hit.Parent.Humanoid.PlatformStand = false
                game:GetService("Debris"):AddItem(rl,.5)
                elseif Type=="Snare" then
                bp=Instance.new("BodyPosition")
                bp.P=2000
                bp.D=100
                bp.maxForce=Vector3.new(math.huge,math.huge,math.huge)
                bp.position=hit.Parent.Torso.Position
                bp.Parent=hit.Parent.Torso
                game:GetService("Debris"):AddItem(bp,1)
            elseif Type=="Float" then
                hit.Parent.Humanoid.PlatformStand = true
                                bp=Instance.new("BodyPosition")
                bp.P=2000
                bp.D=400
                bp.maxForce=Vector3.new(math.huge,math.huge,math.huge)
                bp.position=hit.Parent.Torso.Position+vt(0,35,24)
                                bp.Parent=hit.Parent.Torso
                	
local	rl=Instance.new("BodyAngularVelocity",hit.Parent.Torso)
rl.P=377705
rl.maxTorque=Vector3.new(1,1,1)*500
rl.angularvelocity=Vector3.new(math.random(-3,3),math.random(-6,6),math.random(-3,3))

 local BF = Instance.new("BodyForce",hit.Parent.Torso)
            BF.force = Vector3.new(0, workspace.Gravity/1.10, 0)
                game:GetService("Debris"):AddItem(bp,5)
game:GetService("Debris"):AddItem(BF,5)
game:GetService("Debris"):AddItem(rl,5)
                elseif Type=="Target" then
                if Targetting==false then
                ZTarget=hit.Parent.Torso
                coroutine.resume(coroutine.create(function(Part) 
                so("http://www.roblox.com/asset/?id=15666462",Part,1,1.5) 
                swait(5)
                so("http://www.roblox.com/asset/?id=15666462",Part,1,1.5) 
                end),ZTarget)
                TargHum=ZTarget.Parent:findFirstChild("Humanoid")
                targetgui=Instance.new("BillboardGui")
                targetgui.Parent=ZTarget
                targetgui.Size=UDim2.new(10,100,10,100)
                targ=Instance.new("ImageLabel")
                targ.Parent=targetgui
                targ.BackgroundTransparency=1
                targ.Image="rbxassetid://4834067"
                targ.Size=UDim2.new(1,0,1,0)
                cam.CameraType="Scriptable"
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)
                workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                Targetting=true
                RocketTarget=ZTarget
                for i=1,Property do
                --while Targetting==true and Humanoid.Health>0 and Character.Parent~=nil do
                if Humanoid.Health>0 and char.Parent~=nil and TargHum.Health>0 and TargHum.Parent~=nil and Targetting==true then
                swait()
                end
                --workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,Head.CFrame.p+rmdir*100)
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)*cf(0,5,10)*euler(-0.3,0,0)
                end
                Targetting=false
                RocketTarget=nil
                targetgui.Parent=nil
                cam.CameraType="Custom"
                end
                end
                        debounce=Instance.new("BoolValue")
                        debounce.Name="DebounceHit"
                        debounce.Parent=hit.Parent
                        debounce.Value=true
                        game:GetService("Debris"):AddItem(debounce,Delay)
                        c=Instance.new("ObjectValue")
                        c.Name="creator"
                        c.Value=Player
                        c.Parent=h
                        game:GetService("Debris"):AddItem(c,.5)
                CRIT=false
                hitDeb=true
                AttackPos=6
                comboing = true
                combohits = combohits+1
                combotime = combotime+3.4


                
                if hitfloor == nil then
                    
    local velo=Instance.new("BodyVelocity")
                velo.velocity=vt(0,5.5,0)
                velo.P=8000
                velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                velo.Parent=root
                game:GetService("Debris"):AddItem(velo,0.06)
                
                                   local hitvelo=Instance.new("BodyVelocity")
                hitvelo.velocity=vt(0,5.5,0)
                hitvelo.P=8000
                hitvelo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                hitvelo.Parent=hit
                             game:GetService("Debris"):AddItem(hitvelo,0.06)
                             
                                                          coroutine.resume(coroutine.create(function()
                                 for i = 0,3.7,0.1 do
   swait()
         hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,0,-2.4)
        root.Velocity = root.CFrame.lookVector*0
        hit.Velocity = hit.CFrame.lookVector*130
end
end))
         coroutine.resume(coroutine.create(function()
             while ultra == true do
                 swait()
                 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,0,-2.4)
             end
             end))
                             
                
                end
                
                
        end
end
 
kshowDamage=function(Char,Dealt,du,Color)
        m=Instance.new("Model")
        m.Name=tostring(Dealt)
        h=Instance.new("Humanoid")
        h.Health=0
        h.MaxHealth=0
        h.Parent=m
        c=Instance.new("Part")
        c.Transparency=0
        c.BrickColor=Color
        c.Name="Head"
        c.Material = "Neon"
        c.TopSurface=0
        c.BottomSurface=0
        c.formFactor="Plate"
        c.Size=Vector3.new(1,.4,1)
        ms=Instance.new("CylinderMesh")
        ms.Scale=Vector3.new(.8,.8,.8)
        if CRIT==true then
                ms.Scale=Vector3.new(1,1.25,1)
        end
        ms.Parent=c
        c.Reflectance=0
        Instance.new("BodyGyro").Parent=c
        c.Parent=m
        if Char:findFirstChild("Head")~=nil then
        c.CFrame=CFrame.new(Char["Head"].CFrame.p+Vector3.new(0,1.5,0))
        elseif Char.Parent:findFirstChild("Head")~=nil then
        c.CFrame=CFrame.new(Char.Parent["Head"].CFrame.p+Vector3.new(0,1.5,0))
        end
        f=Instance.new("BodyPosition")
        f.P=2000
        f.D=220
        f.maxForce=Vector3.new(math.huge,math.huge,math.huge)
        f.position=c.Position+Vector3.new(0,3,0)
        f.Parent=c
        game:GetService("Debris"):AddItem(m,.5+du)
        c.CanCollide=false
        m.Parent=workspace
        c.CanCollide=false
    
end

-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end

function Eviscerate(dude)
	if dude.Name ~= char then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
			dude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
					end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
						v:Destroy()
					end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
						for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
								o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							v.Color = maincolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.08
								end
								wait(0.5)
								PartEmmit1.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end




--killer's effects





		function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end
	
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh){
		Parent = Part,
		Offset = OffSet,
		Scale = Scale,
	}
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
		
		
		
function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {
			prt,
			"Block1",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 2 then
		table.insert(Effects, {
			prt,
			"Block2",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
end

function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt=CreatePart(workspace,"Neon",0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh,num) 
for i=0,1,delay do
swait()
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,(math.random(0,1)+math.random())/5)
end

function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end


function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function BreakEffect(brickcolor, cframe, x1, y1, z1)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	local num = math.random(10, 50) / 1000
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Shatter",
		num,
		prt.CFrame,
		math.random() - math.random(),
		0,
		math.random(50, 100) / 100
	})
end





						       so = function(id,par,vol,pit)
		coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound",par or workspace)
		sou.Volume=vol
		sou.Pitch=pit or 1
		sou.SoundId=id
		sou:play()
		game:GetService("Debris"):AddItem(sou,8)
		end))
		end


--end of killer's effects


function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 900817147 --900817147
local SONG2 = 0
local Music = Instance.new("Sound",tors)
Music.Volume = 0.7
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
local attacktype = 1
local attackdebounce = false
local euler = CFrame.fromEulerAnglesXYZ
local cankick = false
----------------------------------------------------------------------------------
hum.WalkSpeed = 8
hum.JumpPower = 57
--[[
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
]]
local ANIMATOR = hum.Animator
local ANIMATE = char.Animate
ANIMATE.Parent = nil
ANIMATOR.Parent = nil
-------------------------------------------------------
--End Customization--
-------------------------------------------------------


-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------

--pls be proud mak i did my best



function attackone()
    
    attack = true
    
          for i = 0, 1.35, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4-2*i), math.rad(4+2*i), math.rad(-40-11*i)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(40+11*i)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.6, 0.2) * angles(math.rad(90+4*i), math.rad(-43), math.rad(16+6*i)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-43)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, 0) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, -0.2) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
      end
      
      so("http://roblox.com/asset/?id=1340545854",ra,1,math.random(0.7,1))


con5=ra.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,3,4,math.random(2,3),"Normal",root,0,1)

so("http://roblox.com/asset/?id=636494529",ra,2,1)
 
 RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))


      wait(0.34)
attackdebounce = false

end
end
end)
                for i = 0, 1.12, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(6), math.rad(23)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(-23)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.6, -0.8) * angles(math.rad(110), math.rad(23), math.rad(2)), 0.4)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0.2) * angles(math.rad(-37), math.rad(0), math.rad(-13)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.3) * RHCF * angles(math.rad(-4), math.rad(0), math.rad(6)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0.05) * LHCF * angles(math.rad(-22), math.rad(0), math.rad(23)), 0.3)
      end
      
      con5:Disconnect()
          attack = false
          
      end












function attacktwo()
    
    attack = true
    
          for i = 0, 1.35, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(46)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(6)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
      end
      
      so("http://roblox.com/asset/?id=1340545854",la,1,math.random(0.7,1))


con5=la.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,3,4,math.random(2,3),"Normal",root,0,1)

so("http://roblox.com/asset/?id=636494529",la,2,1)
 
 RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))


      wait(0.34)
attackdebounce = false

end
end
end)




                for i = 0, 1.12, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(-6), math.rad(-27)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(27)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.16) * angles(math.rad(-33), math.rad(0), math.rad(23)), 0.4)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.67, -0.9) * angles(math.rad(116), math.rad(-28), math.rad(1)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0.05) * RHCF * angles(math.rad(-22), math.rad(0), math.rad(-18)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, -0.3) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(4)), 0.3)
      end
      
      con5:Disconnect()
attack = false
          
      end





function attackthree()
    
    attack = true
    
    
              for i = 0, 1.14, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-46)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(36)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-12), math.rad(0), math.rad(34)), 0.2)
      end
    
    con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,4,5,math.random(3,4),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",ll,2,1)
 
 RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))

    
          wait(0.34)
attackdebounce = false

end
end
end)

        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 9.14, 0.3 do
        swait()
        BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-54*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      attack = false
      con5:disconnect()
end



function attackfour()
    
    attack = true
            so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
     WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
              for i = 0, 5.14, 0.1 do
        swait()
        SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24+4*i), math.rad(0), math.rad(0)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0+11*i), math.rad(0), math.rad(0)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(36+4*i)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(-36-4*i)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28+4*i)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34-4*i)), 0.2)
      end
              so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
       local velo=Instance.new("BodyVelocity")
                velo.velocity=vt(0,25,0)
                velo.P=8000
                velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                velo.Parent=root
                game:GetService("Debris"):AddItem(velo,0.7)



con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.6,-1.8)
end
end))
--kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1)
 RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8)),0.44)
end
end))


      wait(0.14)
attackdebounce = false
end
end
end)

                    for i = 0, 5.11, 0.15 do
        swait()
        BlockEffect(BrickColor.new("White"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.2*i) * angles(math.rad(-10-80*i), math.rad(0), math.rad(0)), 0.42)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
      end


      attack = false
      con5:disconnect()
    end





local cooldown = false
function quickkick()
    attack = true
    
    
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.3,-1.8)
end
end))

--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1)
 RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8)),0.44)
end
end))


      wait(0.08)
attackdebounce = false
end
end
end)

        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 11.14, 0.3 do
        swait()
        root.Velocity = root.CFrame.lookVector * 30
        BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-90*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      attack = false
      con5:disconnect()
end

    
    
    
    
    
    
    
function Taunt()
	attack = true
	hum.WalkSpeed = 0
	Cso("1535995570", hed, 8.45, 1)
	for i = 0, 8.2, 0.1 do
		swait()
		hum.WalkSpeed = 0
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25), Rad(0), Rad(16 * Cos(sine / 12))), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.1* Player_Size, 0.5 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(180), Rad(6), Rad(-56)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.1 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(45), Rad(6), Rad(86)), 0.1)
	end
	attack = false
	hum.WalkSpeed = 8
end
    
    





function Hyperkickcombo()
    
    attack = true
            so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
     WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
      for i = 0, 7.14, 0.1 do
        swait()
        SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(36)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-36)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
      end
local Cracking = Cso("292536356", tors, 10, 1)
 for i = 0, 7.14, 0.1 do
        swait()
		hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
		Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Lime green", 0, "Sphere")
		WaveEffect(BrickColor.new("Lime green"), root.CFrame * CFrame.new(0, -6, 0) * euler(0, math.random(-25, 25), 0), 1, 1, 1, 1, 0.2, 1, 0.05)
        SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
		SphereEffect(BrickColor.new("Lime green"),ll.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(30), math.rad(0), math.rad(0)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(36)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(-36)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
      end
      Cracking.Playing = false
      so("http://www.roblox.com/asset/?id=197161452", char, 3, 0.8)
              so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
              SphereEffect(BrickColor.new("Lime green"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
       local velo=Instance.new("BodyVelocity")
                velo.velocity=vt(0,27,0)
                velo.P=11000
                velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                velo.Parent=root
                game:GetService("Debris"):AddItem(velo,1.24)



con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,3.4,-1.8)
end
end))
--kDamagefunc(hit,2,3,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.09)
attackdebounce = false
end
end
end)

                    for i = 0, 9.11, 0.2 do
        swait()
        BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.12*i) * angles(math.rad(-10-95*i), math.rad(0), math.rad(0)), 0.42)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
      end




      con5:disconnect()
      
      
      
      
      
      
      con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
                       
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.08)
attackdebounce = false
end
end
end)
      
      
      
        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 9.14, 0.3 do
        swait()
               root.Velocity = root.CFrame.lookVector * 20
        BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(53), math.rad(8), math.rad(0-54*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      
      
      
            con5:disconnect()
      
      
      
      con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)
      
      
              so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 15.14, 0.32 do
        swait()
        root.Velocity = root.CFrame.lookVector * 20
        BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-50*i), math.rad(8+20*i), math.rad(0-90*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-4*i)), 0.35)
      end
      
      attack = false
      con5:disconnect()
      
    end





local ultra = false

function Galekicks()
    
    attack = true
                so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
          for i = 0, 1.65, 0.1 do
        swait()
        root.Velocity = root.CFrame.lookVector * 0
        SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end


for i = 1, 17 do
    
          con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)
    
          for i = 0, .1, 0.2 do
        swait()
                BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
                root.Velocity = root.CFrame.lookVector * 10
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
      end

      so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))
      
          for i = 0, 0.4, 0.2 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end
      con5:disconnect()
end

          		    		    
        u =   mouse.KeyDown:connect(function(key)
          	if key == 'r' and combohits >= 150 then
		    ultra = true
		    SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,15,15,15,0.04)
		    end
          end)
          wait(0.3)
         if ultra == true then 
combohits = 0
wait(0.1)
 for i = 0, 1.65, 0.1 do
        swait()
        root.Velocity = root.CFrame.lookVector * 0
        SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end


so("http://roblox.com/asset/?id=146094803",hed,1,1.2)

for i = 1, 65 do
    --Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Really red", 0, "Brick")
          con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)

            
            
            
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)
    
          for i = 0, .03, 0.1 do
        swait()
                BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
                root.Velocity = root.CFrame.lookVector * 10
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
      end

      so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))
      
          for i = 0, 0.07, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end
      con5:disconnect()
end

for i = 0, 1.65, 0.1 do
        swait()
        root.Velocity = root.CFrame.lookVector * 0
        SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end

con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 --hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit, 1, 3, 0,"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,.63)
 RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)

              so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 1, 1.4)
          SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
   
  for i = 0, 2, 0.1 do
        swait()
		--BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0.2) * RHCF * angles(math.rad(-50), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end
        SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
        
        wait(0.25)
        con5:Disconnect() 
   

        
        
        con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=565207203",ll,7,0.63)
 
 RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
SpecialEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,5,18,5,0.04)
WaveEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,1.5,16,1.5,0.04)

coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))
    
          wait(0.06)
attackdebounce = false

end
end
end)

coroutine.resume(coroutine.create(function()
    while ultra == true do
        swait()
        root.CFrame = root.CFrame*CFrame.new(math.random(-3,3),math.random(-2,2),math.random(-3,3))
    end
    end))


        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
        for i = 1,3 do
          for i = 0, 9.14, 0.45 do
        swait()
                root.Velocity = root.CFrame.lookVector * 30
        BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-94*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      end
    
    
    for i = 1,3 do
              for i = 0, 11.14, 0.45 do
        swait()
        root.Velocity = root.CFrame.lookVector * 30
        BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-110*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(27), math.rad(0), math.rad(74)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-34-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      
      
      
    end
     so("http://www.roblox.com/asset/?id=197161452", char, 0.5, 0.8)
    con5:disconnect()
     
     
  end -- combo hit end
            attack = false
          ultra = false
  u:disconnect()
          
      end




-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 2
        hum.WalkSpeed = 24.82
	end
end)
mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 1
        hum.WalkSpeed = 8
	end
end)

 





mouse.Button1Down:connect(function()
 if attack==false then
                if attacktype==1 then
                        attack=true
                        attacktype=2
                        attackone()
                elseif attacktype==2 then
                        attack=true
                        attacktype=3
                        attacktwo()
                elseif attacktype==3 then
                        attack=true
                        attacktype=4
                        attackthree()
                elseif attacktype==4 then
                        attack=true
                        attacktype=1
                        attackfour()
                end
        end
end)




		  mouse.KeyDown:connect(function(key)
		if key == 'e' and attack == false and cankick == true and cooldown == false then
quickkick()
cooldown = true

coroutine.resume(coroutine.create(function()
    wait(2)
cooldown = false
end))



		end
		end)








mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 't' then
			Taunt()
		elseif key == 'f' then
			Hyperkickcombo()
					elseif key == 'r' then
			Galekicks()
		end
	end
end)

-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
print("By Makhail07 and KillerDarkness0105")
print("Basic Animations by Makhail07")
print("Attack Animations by KillerDarkness0105")
print("This is pretty much our final script together")
print("--------------------------------")
print("Attacks")
print("E in air: Quick Kicks")
print("Left Mouse: 4 click combo")
print("F: Hyper Kicks")
print("R: Gale Kicks, Spam R if your combo is over 150 to do an ultra combo")
print("--------------------------------")
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	
	if hitfloor == nil then
	    cankick = true
    else
        cankick = false
        end
	
	
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(20)), 0.1)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-6.5 * Sin(sine / 12)), Rad(0), Rad(-20)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(110), Rad(6 + 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.3* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(110), Rad(6 - 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
			end
		elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-1), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-15 - 15 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 15 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(56)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-56)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
			end
		elseif torvel >= 22 and hitfloor ~= nil then
			Anim = "Sprint"
			change = 1.35
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-8.5 - 2 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
			RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         	LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65) , Rad(0), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65)  , Rad(0) ,	Rad(-13) + la.RotVelocity.Y / 75), 0.15)
			end
		end
	end
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 0.7
	Music.Parent = tors
	Music:Resume()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end 
local basetpart = game.workspace.non:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
	    end
	    
	    	if string.sub(BAR.Text, 1, 5) == ("sonic") then
	    --[[KillerDarkness0105's/Codex's Sonic script]]--

 sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
       --sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)

function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end

loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()


wait(0.07)
Player=game:GetService("Players").LocalPlayer
Character=workspace.non
PlayerGui=Player.PlayerGui
Backpack=Player.Backpack
Torso=Character.Torso
Head=Character["Head"]
Humanoid=Character.Humanoid
LeftArm=Character["Left Arm"]
LeftLeg=Character["Left Leg"]
RightArm=Character["Right Arm"]
RightLeg=Character["Right Leg"]
LS=Torso["Left Shoulder"]
LH=Torso["Left Hip"]
RS=Torso["Right Shoulder"]
RH=Torso["Right Hip"]
Face = Head.face
Neck=Torso.Neck
it=Instance.new
attacktype=1
attacktype2=1
vt=Vector3.new
cf=CFrame.new
cn=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
combo = 0
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false
attackdebounce = false
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
stance = false
local ff = 2
noleg = false
evadecooldown = false
Humanoid.Animator.Parent = nil
equip = false
local Effects = {}
 attackspeed = 0.14 
 df = false
 Swing = 1
local sine = 0
local change = 1
local val = 0
local speed = 0
local rs = game:GetService("RunService").RenderStepped
cam = workspace.CurrentCamera
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create
deb = game:GetService("Debris")
Face.Transparency = 0
--Face.Texture = "rbxassetid://176217905" --176217905
Humanoid.WalkSpeed = 64
local freefall = 0

local boost = false
Humanoid.JumpPower = 88
local musicnum = 1
    
     local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
 local GravPoint = RootPart.Velocity.y
 local NV = Vector3.new(0,0,0)
print("Move list")
print("---------")
print("Shift = Boost")
print("Ctrl = Mach Speed Boost")
print("Q = Left QuickStep, E  = Right QuickStep")
print("C = Slide, in air to stomp")
print("Jump Then Hold B near a wall to wallrun")
print("M to change music, if you're standing still you'll do a special animation!")
print("Space near a wall to walljump, away from a wall homing attack")
		music = Instance.new("Sound",PlayerGui)
		music.Volume = 1
		music.TimePosition = 0
		music.Pitch = 1
		music.SoundId = "rbxassetid://1251555494"
		music.Looped = true
		music:Play()
		

		boostsound = Instance.new("Sound",PlayerGui)
		boostsound.Volume = .6
		boostsound.TimePosition = 0
		boostsound.Pitch = 1
		boostsound.SoundId = "rbxassetid://924922553"
		boostsound.Looped = false



		stompsound = Instance.new("Sound",PlayerGui)
		stompsound.Volume = 2
		stompsound.TimePosition = 0
		stompsound.Pitch = 1
		stompsound.SoundId = "rbxassetid://1295424184"
		stompsound.Looped = false



			       so = function(id,par,vol,pit)
		coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound",par or workspace)
		sou.Volume=vol
		sou.Pitch=pit or 1
		sou.SoundId=id
		sou:play()
		game:GetService("Debris"):AddItem(sou,8)
		end))
		end
		
		--save shoulders
		RSH, LSH=nil, nil
		--welds
		RW, LW=Instance.new("Weld"), Instance.new("Weld")
		RW.Name="Right Shoulder" LW.Name="Left Shoulder"
		LH=Torso["Left Hip"]
		RH=Torso["Right Hip"]
		TorsoColor=Torso.BrickColor
		function NoOutline(Part)
		Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
		end
		player=Player
		ch=Character
		RSH=ch.Torso["Right Shoulder"]
		LSH=ch.Torso["Left Shoulder"]
		--
		RSH.Parent=nil
		LSH.Parent=nil
		--
		RW.Name="Right Shoulder"
		RW.Part0=ch.Torso
		RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5)
		RW.C1=cf(0, 0.5, 0)
		RW.Part1=ch["Right Arm"]
		RW.Parent=ch.Torso
		--
		LW.Name="Left Shoulder"
		LW.Part0=ch.Torso
		LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8)
		LW.C1=cf(0, 0.5, 0)
		LW.Part1=ch["Left Arm"]
		LW.Parent=ch.Torso
		 
		 
		newWeld = function(wp0, wp1, wc0x, wc0y, wc0z)
		    local wld = Instance.new("Weld", wp1)
		    wld.Part0 = wp0
		    wld.Part1 = wp1
		    wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
		end
		 local rs = game:GetService("RunService").RenderStepped
		 
		newWeld(RootPart, Torso, 0, -1, 0)
		Torso.Weld.C1 = CFrame.new(0, -1, 0)
		newWeld(Torso, LeftLeg, -0.5, -1, 0)
		LeftLeg.Weld.C1 = CFrame.new(0, 1, 0)
		newWeld(Torso, RightLeg, 0.5, -1, 0)
		RightLeg.Weld.C1 = CFrame.new(0, 1, 0)
		
		    Player=game:GetService('Players').LocalPlayer
		    Character=Player.Character
		    mouse=Player:GetMouse()
		    m=Instance.new('Model',Character)
		 
		 
		    local function weldBetween(a, b)
		        local weldd = Instance.new("ManualWeld")
		        weldd.Part0 = a
		        weldd.Part1 = b
		        weldd.C0 = CFrame.new()
		        weldd.C1 = b.CFrame:inverse() * a.CFrame
		        weldd.Parent = a
		        return weldd
		    end
		   
		    ArtificialHB = Instance.new("BindableEvent", script)
		ArtificialHB.Name = "Heartbeat"
		 
		script:WaitForChild("Heartbeat")
		 
		frame = 1 / 80
		tf = 0
		allowframeloss = false
		tossremainder = false
		lastframe = tick()
		script.Heartbeat:Fire()
		game:GetService("RunService").Heartbeat:connect(function(s, p)
		    tf = tf + s
		    if tf >= frame then
		        if allowframeloss then
		            script.Heartbeat:Fire()
		            lastframe = tick()
		        else
		            for i = 1, math.floor(tf / frame) do
		                script.Heartbeat:Fire()
		            end
		            lastframe = tick()
		        end
		        if tossremainder then
		            tf = 0
		        else
		            tf = tf - frame * math.floor(tf / frame)
		        end
		    end
		end)
		 
--[[]
		function swait(num)
		    if num == 0 or num == nil then
		        ArtificialHB.Event:wait()
		    else
		        for i = 0, num do
		            ArtificialHB.Event:wait()
		        end
		    end
	end

	]]
	



	function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait()
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait()
		end
	end
end

		function RemoveOutlines(part)
		    part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
		end
		   
		
		part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
		  local fp = it("Part")
		  fp.formFactor = formfactor
		  fp.Parent = parent
		  fp.Reflectance = reflectance
		  fp.Transparency = transparency
		  fp.CanCollide = false
		  fp.Locked = true
		  fp.BrickColor = brickcolor
		  fp.Name = name
		  fp.Size = size
		  fp.Position = Torso.Position
		  NoOutline(fp)
		  if fp.BrickColor == BrickColor.new("Dark indigo") then
		    fp.Material = "Neon"
		  else
		    if fp.BrickColor == BrickColor.new("Really black") then
		      fp.BrickColor = BrickColor.new("Really black")
		      fp.Material = "Metal"
		    else
		      fp.Material = "Neon"
		    end
		  end
		  fp:BreakJoints()
		  return fp
		end
		
		mesh = function(Mesh, part, meshtype, meshid, offset, scale)
		  local mesh = it(Mesh)
		  mesh.Parent = part
		  if Mesh == "SpecialMesh" then
		    mesh.MeshType = meshtype
		    mesh.MeshId = meshid
		  end
		  mesh.Offset = offset
		  mesh.Scale = scale
		  return mesh
		end
		
		weld = function(parent, part0, part1, c0)
		  local weld = it("Weld")
		  weld.Parent = parent
		  weld.Part0 = part0
		  weld.Part1 = part1
		  weld.C0 = c0
		  return weld
		end
		
		F1 = Instance.new("Folder", Character)
		F1.Name = "Effects Folder"
		F2 = Instance.new("Folder", F1)
		F2.Name = "Effects"
		Triangle = function(a, b, c)
		end
		
		MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CanCollide = false
		  prt.CFrame = cframe
		  prt.Name = "prt"
		  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Block1", delay, x3, y3, z3})
		end
		
		
		
		MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CanCollide = false
		  prt.CFrame = cframe
		  prt.Name = "prt"
		  local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3})
		end
		
		MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CFrame = cframe
		  local msh = mesh("SpecialMesh", prt, "FileMesh", "http://www.roblox.com/asset/?id=20329976", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3})
		end
		
		MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt(0.2, 0.2, 0.2))
		  prt.Anchored = true
		  prt.CFrame = cframe
		  msh = mesh("SpecialMesh", prt, "Head", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  Effects[#Effects + 1] = {prt, "Cylinder", delay, x3, y3, z3}
		end
		
		MagicCylinder2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt(0.2, 0.2, 0.2))
		  prt.Anchored = true
		  prt.CFrame = cframe
		  msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  Effects[#Effects + 1] = {prt, "Cylinder", delay, x3, y3, z3}
		end
		
		MagicBlood = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CFrame = cframe
		  local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Blood", delay, x3, y3, z3})
		end
		
		ElecEffect = function(cff, x, y, z)
		  local prt = part(3, F2, 0, 0, BrickColor.new("Dark indigo"), "Part", vt(1, 1, 1))
		  prt.Anchored = true
		  prt.CFrame = cff * cf(math.random(-x, x), math.random(-y, y), math.random(-z, z))
		  prt.CFrame = cf(prt.Position)
		  game:GetService("Debris"):AddItem(prt, 2)
		  xval = math.random() / 2
		  yval = math.random() / 2
		  zval = math.random() / 2
		  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(xval, yval, zval))
		  Effects[#Effects + 1] = {prt, "Elec", 0.1, x, y, z, xval, yval, zval}
		end
		
		function FindNearestTorso(Position, Distance, SinglePlayer)
			if SinglePlayer then
				return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
			end
			local List = {}
			for i, v in pairs(workspace:GetChildren()) do
				if v:IsA("Model") then
					if v:findFirstChild("Torso") then
						if v ~= Character then
							if (v.Torso.Position - Position).magnitude <= Distance then
								table.insert(List, v)
							end 
						end 
					end 
				end 
			end
			return List
		end
		
		
		function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end
	
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh){
		Parent = Part,
		Offset = OffSet,
		Scale = Scale,
	}
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
		
		
		
function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {
			prt,
			"Block1",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 2 then
		table.insert(Effects, {
			prt,
			"Block2",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
end

function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay,material)
local prt=CreatePart(workspace,material,0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh,num) 
for i=0,1,delay do
swait()
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,(math.random(0,1)+math.random())/5)
end

function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end


function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function BreakEffect(brickcolor, cframe, x1, y1, z1)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	local num = math.random(10, 50) / 1000
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Shatter",
		num,
		prt.CFrame,
		math.random() - math.random(),
		0,
		math.random(50, 100) / 100
	})
end
		
		local lerp = function(a, b, t)
	return a * (1 - t) + b * t
end
		
		function clerp(a,b,t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1-t
		return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t))
		end
		 
		function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5/s
		return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5
		else
		local i = 0
		if m11 > m00 then
		i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
		i = 2
		end
		if i == 0 then
		local s = math.sqrt(m00-m11-m22+1)
		local recip = 0.5/s
		return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip
		elseif i == 1 then
		local s = math.sqrt(m11-m22-m00+1)
		local recip = 0.5/s
		return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip
		elseif i == 2 then
		local s = math.sqrt(m22-m00-m11+1)
		local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip
		end
		end
		end
		

		function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w*xs, w*ys, w*zs
		local xx = x*xs
		local xy = x*ys
		local xz = x*zs
		local yy = y*ys
		local yz = y*zs
		local zz = z*zs
		return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy))
		end
		function QuaternionSlerp(a, b, t)
		local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
		local theta = math.acos(cosTheta)
		local invSinTheta = 1/math.sin(theta)
		startInterp = math.sin((1-t)*theta)*invSinTheta
		finishInterp = math.sin(t*theta)*invSinTheta  
		else
		startInterp = 1-t
		finishInterp = t
		end
		else
		if (1+cosTheta) > 0.0001 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1/math.sin(theta)
		startInterp = math.sin((t-1)*theta)*invSinTheta
		finishInterp = math.sin(t*theta)*invSinTheta
		else
		startInterp = t-1
		finishInterp = t
		end
		end
		return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp
		end
		 
		function weld5(part0, part1, c0, c1)
		    weeld=Instance.new("Weld", part0)
		    weeld.Part0=part0
		    weeld.Part1=part1
		    weeld.C0=c0
		    weeld.C1=c1
		    return weeld
		end
		 
		--Example: Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
		 
		function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
	end
	
	
	



Character.Humanoid.MaxHealth = 120
Character.Humanoid.Health = 120
 
 local f = 0
 local b = Instance.new("BlurEffect",cam)
local    c = Instance.new('PointLight', Torso)
c.Range = 16
c.Color = Color3.new(0, 1,1)
c.Brightness = 1.5
 game:GetService("RunService"):BindToRenderStep("W0tT", 0, function()

b.Size = b.Size - 4
if boost == true then
c.Enabled = true
    cam.FieldOfView = lerp(cam.FieldOfView, 110, 0.5)
   -- cam.FieldOfView = 110
    freefall = 0
    Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,3),0.25)
 SphereEffect(BrickColor.new("Cyan"),RightLeg.CFrame*CFrame.new(0,-1,0)*angles(math.random(-180,180),math.random(-180,180),math.random(-180,180)),1.4,12,1.4,2.8,26,2.8,0.07)
  SphereEffect(BrickColor.new("Cyan"),LeftLeg.CFrame*CFrame.new(0,-1,0)*angles(math.random(-180,180),math.random(-180,180),math.random(-180,180)),1.4,12,1.4,2.8,26,2.8,0.07)
  if hitfloor ~= nil and Anim ~= "runIdle" then
  SpecialEffect(BrickColor.new("Cyan"),RootPart.CFrame*CFrame.new(0,-3.4,.78) ,2,2,2, 1.5,1.5,1.5,.09)
  end
end
if boost == false then
    cam.FieldOfView = lerp(cam.FieldOfView, 70, 0.076)
    --cam.FieldOfView = 70
    c.Enabled = false
end
end)



						 mouse.KeyDown:connect(function(key)
    if string.byte(key) == 48 then
        b.Size = 40
		Swing = 2
		freefall = 0
		
coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))
        Humanoid.WalkSpeed = 180
        RootPart.Velocity = RootPart.CFrame.lookVector*150
        RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-9.2) , 1, 1, 1, 8, 8, 8, 0.14,"Neon") 
        boost = true
        boostsound:Play()
end
end)

mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
		Swing = 1
        Humanoid.WalkSpeed = 64
        boost = false
        boostsound:Stop()

end
end)




						 mouse.KeyDown:connect(function(key)
    if string.byte(key) == 50 then
        b.Size = 40
        freefall = 0
		Swing = 2
		
coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.35*2.8,0.35*2.8),math.random(-0.35*2.8,0.35*2.8),math.random(-0.35*2.8,0.35*2.8)),0.48)
end
end))
		
        Humanoid.WalkSpeed = 320
        RootPart.Velocity = RootPart.CFrame.lookVector*550
        RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-9.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
        RingEffect(BrickColor.new("White"), RootPart.CFrame*CFrame.new(0,0,-11.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
        RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-13.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
        boost = true
        boostsound:Play()
end
end)

mouse.KeyUp:connect(function(key)
    if string.byte(key) == 50 then
		Swing = 1
        Humanoid.WalkSpeed = 64
        boost = false
        boostsound:Stop()

end
end)


local lastwall = nil
local jumped = false



		 
		 
		 
		 local vwall = false
		 
		 		 mouse.KeyDown:connect(function(key)
		     if key == 'b' and hitfloor == nil and attack == false then
	vrun()
end
 end)
 
 
 function vrun()
     		 	local ray = Ray.new(
		RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
	)
	local hit, position, normal = workspace:FindPartOnRay(ray, character)
	
	if hit then
	    if hit.Parent.Parent ~= Character and hit.Parent ~= Character and hit.Name ~= "prt" and hit.CanCollide == true then
	    vwall = true
	        local NV = Vector3.new(0,0,0)
	             local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
 local GravPoint = RootPart.Velocity.y
		local velo = Instance.new("BodyVelocity",Torso)
		velo.MaxForce = Vector3.new(400000,400000,400000)

		attack = true
while vwall == true and ray and hit do
swait()
change = 0.84+ Humanoid.WalkSpeed/132
if Humanoid.WalkSpeed > 40 and Humanoid.WalkSpeed < 70 then
velo.Velocity =  Vector3.new(0,40,0)
end
if Humanoid.WalkSpeed > 70 and Humanoid.WalkSpeed < 200 then
		velo.Velocity =  Vector3.new(0,80,0)
		end
		if Humanoid.WalkSpeed > 200 then
		velo.Velocity =  Vector3.new(0,130,0)
		end
		 ray = Ray.new(
		RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
	)
	hit, position, normal = workspace:FindPartOnRay(ray, character)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/2), .6) * angles(math.rad(96), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+20*math.sin(sine/2)),math.rad(0),math.rad(0+5*math.sin(sine/4)) + RootPart.RotVelocity.Y / 13),.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.1) * angles(math.rad(-90-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(15+2*math.sin(sine/4))- RootPart.RotVelocity.Y / 34),.15)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.1)*angles(math.rad(-90-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-15+2*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34),.15)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.28*math.cos(sine/4), 0-0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0+104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.3+ Humanoid.WalkSpeed/272)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.28*math.cos(sine/4),0+0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0-104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.3+ Humanoid.WalkSpeed/272)
end
		velo:Destroy()
		wait(0.07)

if vwall == false then

 RootPart.Velocity = -RootPart.CFrame.lookVector*68 + Vector3.new(0,86,0)

--[[]
		for i = 0,5,0.2 do
rs:wait()
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.79, 0) * CFrame.Angles(math.rad(0+100*i), math.rad(0), math.rad(0)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(0)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(180), math.rad(-60), math.rad(40)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(180), math.rad(60), math.rad(-40)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
end
]]


for i = 0,4,0.1 do
swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
end

 		attack = false


end


		if vwall == true then
 RootPart.Velocity = RootPart.CFrame.lookVector*38 + Vector3.new(0,86,0)

--[[]
		for i = 0,5,0.2 do
rs:wait()
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.79, 0) * CFrame.Angles(math.rad(0+100*i), math.rad(0), math.rad(0)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(0)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(180), math.rad(-60), math.rad(40)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(180), math.rad(60), math.rad(-40)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
end
]]


for i = 0,4,0.15 do
swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0-260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
end

 		attack = false

end


end
end
end
 
 

 
 	 mouse.KeyUp:connect(function(key)
		     if key == 'b' and vwall == true then
	         vwall = false
	         end
	         end)
		 


		 
		 
function Ldash()
    
    

evadecooldown = true
attack = true
k = math.random(1,2) 
if k == 1 then
so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
else
 so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
 end
 
 
 


 --+173.8*i
for i = 0,.7,0.1 do
swait()
Head.Velocity = Head.CFrame.rightVector * -135
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(32)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(-9),math.rad(-14)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.2) * angles(math.rad(27), math.rad(0), math.rad(30)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(30)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(12)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(8)), 0.2)
end

attack = false
wait(0.08)
evadecooldown = false
 
 
end





function Rdash()
    
    

evadecooldown = true
attack = true
k = math.random(1,2) 
if k == 1 then
so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
else
 so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
 end
 
 
 
 

 --+173.8*i
for i = 0,.7,0.1 do
swait()
Head.Velocity = Head.CFrame.rightVector * 135
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-32)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(9),math.rad(14)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(-30)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.2) * angles(math.rad(27), math.rad(0), math.rad(-30)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-8)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-12)), 0.2)
end

attack = false
wait(0.08)
evadecooldown = false
 
 
end
local sliding = false


function Slide()
    
     local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
     spd = spd + 30
local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
 local GravPoint = RootPart.Velocity.y
 if spd > 40 and hitfloor ~= nil then
noleg = true

attack = true
k = math.random(1,2) 
if k == 1 then
so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
else
 so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
 end
 
 
 

 
 
 

 
 
 local NV = Vector3.new(0,0,0)
local bv = Instance.new("BodyVelocity", Torso)
bv.maxForce = Vector3.new(1/0,1/0,1/0)
bv.velocity = dir*spd
	        local bg = Instance.new("BodyGyro", Torso)
bg.maxTorque = Vector3.new(1/0,1/0,1/0)
bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)
Head.Running.SoundId = "rbxassetid://1295468446"
Head.Running.TimePosition = 0

Humanoid.PlatformStand = true
while spd > 2 and hitfloor ~= nil and sliding == true do
swait()
spd = spd - 0.95
bv.velocity = dir*spd + Vector3.new(0,0,0)
bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -2.3, 0) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(12)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(34),math.rad(0),math.rad(12)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(110), math.rad(0), math.rad(70)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.2) * angles(math.rad(0), math.rad(0), math.rad(-60)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -0.56, -0.2) * CFrame.Angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
end
bv:Destroy()
bg:Destroy()
Head.Running.SoundId = "rbxassetid://758199523"
Head.Running.TimePosition = 0
Humanoid.PlatformStand = false
attack = false
sliding = false
wait(0.05)
evadecooldown = false
 
 
end
end

function land()
    attack = true
   RootPart.Velocity = Vector3.new(0,0,0)
    WaveEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,-1,0) , 1, 1, 1, 3, 0.8, 3, 0.06) 
     so("http://www.roblox.com/asset/?id=1295424585", Torso, 3.5, 1)

coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.55*2.8,0.55*2.8),math.random(-0.55*2.8,0.55*2.8),math.random(-0.55*2.8,0.55*2.8)),0.44)
        Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -2, 0) * CFrame.Angles(math.rad(-16), math.rad(0), math.rad(0)), 0.5)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(7),math.rad(0),math.rad(0)),.5)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(87)),.5)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0) * angles(math.rad(0), math.rad(0), math.rad(-87)),.5)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, 0, -0.5) * CFrame.Angles(math.rad(16), math.rad(0), math.rad(0)), 0.5)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1.14, 0.2) * CFrame.Angles(math.rad(-17), math.rad(0), math.rad(0)), 0.5)
       
end
attack = false


end))



end




function stomp()
    attack = true
    stompsound:Play()
    
   while hitfloor == nil do 
       swait()
       b.Size = 12
        WaveEffect(BrickColor.new("Cyan"), LeftLeg.CFrame*CFrame.new(0,-2.4,0) , 1, 1, 1, 0.8, 0.8, 0.8, 0.14) 
       RootPart.Velocity = Vector3.new(0,RootPart.Velocity.y/1.6,0) +Vector3.new(0,-150,0)
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(0+4*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(140+12*math.cos(sine/1.3))), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(-140+12*math.cos(sine/1.3))), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(60+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3), -0.13) * CFrame.Angles(math.rad(0+4*math.cos(sine/1.3)), math.rad(3), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, .27+0.17*math.cos(sine/1.3), -0.56) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(0), math.rad(0)), 0.1)

end
 stompsound:Stop()
land()


end


function changemusic()
    musicnum = musicnum + 1
    music.TimePosition = 0
    local osix = false
    local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude
    if musicnum > 14 then
        musicnum = 1
    end
    if musicnum == 1 then
        music.SoundId = "rbxassetid://179029173"
    end
    if musicnum == 2 then
        music.SoundId = "rbxassetid://146443855"
        end
        if musicnum == 3 then
           music.SoundId = "rbxassetid://1342408291" 
          end
          if musicnum == 4 then
            music.SoundId = "rbxassetid://201219416"  
        end
        if musicnum == 5 then
music.SoundId = "rbxassetid://1390472571" 
end
        if musicnum == 6 then
            osix = true
music.SoundId = "rbxassetid://249974783" 
end
if musicnum == 7 then
    music.SoundId = "rbxassetid://1851880603"
end
if musicnum == 8 then
 music.SoundId = "rbxassetid://412034984"
end
if musicnum == 9 then
   music.SoundId = "rbxassetid://536915629"
end
if musicnum == 10 then
music.SoundId = "rbxassetid://1200005861"
end
if musicnum == 11 then
    music.SoundId = "rbxassetid://1055930631"
end
if musicnum == 12 then
    music.SoundId = "rbxassetid://300269553"
end
if musicnum == 13 then
    music.SoundId = "rbxassetid://199897052"
end
if musicnum == 14 then
  music.SoundId = "rbxassetid://638115895"  
end

if spd < 14 then
Humanoid.Jump = true

if osix == false then
so("rbxassetid://537371462",PlayerGui,2,1)
end


RootPart.Velocity = Vector3.new(0,102,0)
attack = true
wait(0.08)
for i = 0,7,0.1 do
    swait()
    RootPart.Velocity = Vector3.new(0,2,0)
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0-260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)

end
b.Size = 40
MoonEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,0) , 1, 1, 1, 8, 8, 8, 0.06) 

if osix == true then
osix = false
so("rbxassetid://156821036",PlayerGui,2,1)
end

Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -3, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 1)
for i = 0,5,0.1 do
    swait()
RootPart.Velocity = Vector3.new(0,3.5,0)
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1+0.1*i, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.21)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(22-2*i),math.rad(0),math.rad(0)),.21)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.09*i, 0) * angles(math.rad(20-6*i), math.rad(0), math.rad(90+13*i)), 0.21)
LW.C0 = clerp(LW.C0, CFrame.new(-1.0-0.12*i, 0.5, -0.4+0.05*i) * angles(math.rad(20+13*i), math.rad(0), math.rad(20-13*i)), 0.21)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(-22-4*i)), 0.21)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(22+4*i)), 0.21)
end
attack = false
end
end


  mouse.KeyDown:connect(function(key)
if key == 'q' and attack == false and evadecooldown == false then
Ldash()
end
end)
 
 
 
   mouse.KeyDown:connect(function(key)
if key == 'e' and attack == false and evadecooldown == false then
Rdash()
end
end)

   mouse.KeyDown:connect(function(key)
if key == 'c' and attack == false and evadecooldown == false and hitfloor ~= nil then
     sliding = true
Slide()
end
end)

   mouse.KeyDown:connect(function(key)
if key == 'c' and attack == false and hitfloor == nil then
     stomp()
end
end)


local walljump = false


function walljumpp()
    	local ray = Ray.new(
		Torso.CFrame.p, RootPart.CFrame.lookVector *5
	)
	local hit, position, normal = workspace:FindPartOnRay(ray, character)
	
	if hit then
	    if  hit.Parent.Parent ~= Character and hit.Parent ~= Character then
	    local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
	    GravPoint = 0
 	    freefall = 0
	    walljump = true 
	    Humanoid.AutoRotate = false
		local velo = Instance.new("BodyVelocity",Torso)
		velo.MaxForce = Vector3.new(400000,400000,400000)
		--game.Debris:AddItem(velo,0.1)
		attack = true
while hitfloor == nil and walljump == true and ray and hit  do
swait()
freefall = 0
GravPoint = GravPoint - 0.36
		 ray = Ray.new(
		RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
	)
	hit, position, normal = workspace:FindPartOnRay(ray, character)
velo.Velocity = vt(0,GravPoint,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.9) * CFrame.Angles(math.rad(5), math.rad(90), math.rad(8)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(7),math.rad(0),math.rad(86)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(120)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-60)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-6), math.rad(14), math.rad(-12)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(23)), 0.2)
end
if walljump == false then
    k = math.random(1,3) 
if k == 1 then
so("http://www.roblox.com/asset/?id=800121776", Head, 2.5, 1)
else if k == 2 then
 so("http://www.roblox.com/asset/?id=804889329", Head, 2.5, 1)
else if k == 3 then
     so("http://www.roblox.com/asset/?id=804907617", Head, 2.5, 1)
     end
     end
end
 
    velo:Destroy()
        attack = false
    coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
end
end))
    
    Humanoid.AutoRotate = true
    RootPart.Velocity = RootPart.CFrame.lookVector * -137 + Vector3.new(0,136,0)
    wait(0.07)
     RootPart.CFrame = CFrame.new(RootPart.CFrame.p,-RootPart.CFrame.lookVector)
end
if walljump == true then
 		attack = false
walljump = false
Humanoid.AutoRotate = true
velo:Destroy()
end
end
end
end

    
    local homed = nil
    function home()
        if walljump ~= true then
        		    	for i, v in pairs(FindNearestTorso(Torso.CFrame.p, 80)) do
				if v:FindFirstChild('Head') then
					Grabbed = true
					homed = v
				end
			end
    
    if homed ~= nil and homed:FindFirstChildOfClass("Humanoid").Health > 1 and walljump == false then
        					    so("http://www.roblox.com/asset/?id=162460823", Head, 1, .8)
        					    	   local SBall = Instance.new("Part",Character)
	SBall.Name = "Homing Ball"
	SBall.CanCollide = false
	SBall.Anchored = false
	SBall.Transparency = 0.64
	SBall.CFrame = CFrame.new(RootPart.CFrame.p)
	SBall.BrickColor = BrickColor.new("Toothpaste")
	SBall.Size = Vector3.new(1,1,1)
	SBall.Material = "Neon"
	SBallweld = Instance.new("Weld")
SBallweld.Parent = SBall
SBallweld.Part0 = RootPart
SBallweld.Part1 = SBall
SBallweld.C1 = CFrame.new(0, 1, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
        SBallweld.Part0 = RootPart
	local SBallmesh = Instance.new("SpecialMesh",SBall)
	SBallmesh.MeshType = "Sphere"
	SBallmesh.Scale = Vector3.new(6,6,6)
        	trail = Instance.new("Trail", Character)
a2 = Instance.new("Attachment", Torso) a2.Position = Vector3.new(0,2,0)
a3 = Instance.new("Attachment", Torso)a3.Position = Vector3.new(0,-2.5,0)
trail.Texture = "rbxassetid://0"
trail.Attachment0 = a2
trail.Attachment1 = a3
trail.Lifetime  =  0.353
trail.MinLength = 0.03
trail.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,1)})
trail.Color = ColorSequence.new(Color3.new(0,1,1), Color3.new(0, 0,0))
trail.LightEmission = 4.8
trail.TextureLength = 0.034
        trail.Enabled = true
 attack = true
	local position = Instance.new("BodyPosition",Torso)
	position.P = 68350
	position.maxForce = Vector3.new(math.huge,math.huge,math.huge)
	
        while homed ~= nil and (homed.Torso.Position-RootPart.Position).magnitude > 8 do
        swait()
        SBall.CFrame = CFrame.new(RootPart.CFrame.p)
    Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+420*math.abs(sine/3.2)), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
    position.Position = homed.Torso.Position + Vector3.new(0,2,0) 
end
		local bodvol=Instance.new("BodyVelocity")
bodvol.velocity= RootPart.CFrame.lookVector*240 + Vector3.new(0,30,0)
bodvol.P= 35200
bodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
bodvol.Parent=homed.Head
game:GetService("Debris"):AddItem(bodvol, 0.2)
homed:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(10,30))

position:Destroy()
trail.Enabled = false
SBall:Destroy()
RootPart.Velocity = Vector3.new(0,93.5,0)
    coroutine.resume(coroutine.create(function()
for i = 0,5,0.26 do
    swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1+0.1*i, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.21)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(22-2*i),math.rad(0),math.rad(0)),.21)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.09*i, 0) * angles(math.rad(20-6*i), math.rad(0), math.rad(90+13*i)), 0.21)
LW.C0 = clerp(LW.C0, CFrame.new(-1.0-0.12*i, 0.5, -0.4+0.05*i) * angles(math.rad(20+13*i), math.rad(0), math.rad(20-13*i)), 0.21)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(-22-4*i)), 0.21)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(22+4*i)), 0.21)
end
homed = nil
attack = false
end))

end
    
end


end











    










    
		 		 mouse.KeyDown:connect(function(key)
		 		     wait(0.16)
		     if string.byte(key) == 32 and hitfloor == nil and attack == false and walljump == false and Humanoid.Jump == true then
		 walljumpp()
	 end
	 		     if string.byte(key) == 32 and hitfloor == nil and attack == false and walljump == false and Humanoid.Jump == true then
		 home()
	 end
	 
if string.byte(key) == 32 and hitfloor == nil and attack == true and walljump == true then
walljump = false
end
	 end)
		 



   mouse.KeyDown:connect(function(key)
if key == 'm' and attack == false then
changemusic()
end
end)






   mouse.KeyUp:connect(function(key)
       wait(0.05)
if key == 'c' and sliding == true then
     sliding = false
end
end)
local look = 0



				while true do
    swait()
sine = sine + change
--speed = speed + music.PlaybackLoudness/90
local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
	
    local TiltVelocity = CFrame.new(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity))

local rlegray = Ray.new(RightLeg.Position+Vector3.new(0,0.54,0),Vector3.new(0, -1.75, 0))
local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, Character)

local llegray = Ray.new(LeftLeg.Position+Vector3.new(0,0.54,0),Vector3.new(0, -1.75, 0))
local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, Character)

    	local waterthing = Ray.new(RootPart.CFrame.p,Vector3.new(0,-1,0))
	local start, position = workspace:FindPartOnRay(waterthing, character)
	
	if start ~= nil and start.Material == "Water" then
	
    RootPart.Velocity = RootPart.Velocity + Vector3.new(0,6,0)
    
    end

if torvel<1  and Swing == 2 then
    boost = false
elseif torvel>1   and Swing == 2 then
    boost = true
    freefall = 0
end
if hitfloor ~= nil and freefall < 150 then
    freefall = 0
end
if freefall > 150 and hitfloor ~= nil then
land()
freefall = 0
end







		if RootPart.Velocity.y > 1 and hitfloor==nil then
Anim="Jump"





if attack==false then
change = 1
look = 0
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(4), math.rad(0), math.rad(0)), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10+2.05*math.cos(sine/5)),math.rad(0),math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20+2.05*math.cos(sine/5)), math.rad(-10), math.rad(50-2.05*math.cos(sine/5))), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20+2.05*math.cos(sine/5)), math.rad(-10), math.rad(-50+2.05*math.cos(sine/5))), 0.07)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, -0.6) * CFrame.Angles(math.rad(-25+3.05*math.cos(sine/5)), math.rad(-3), math.rad(0)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.47, -0.7) * CFrame.Angles(math.rad(-12+3.05*math.cos(sine/5)), math.rad(0), math.rad(0)), 0.1)
end

elseif RootPart.Velocity.y < -1 and freefall <150 and hitfloor==nil then
Anim="Fall"
change = 1
freefall = freefall +0.77


if attack==false then
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(7+4*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(140+12*math.cos(sine/1.3))), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(-140+12*math.cos(sine/1.3))), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(40+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3), -0.13) * CFrame.Angles(math.rad(18+7*math.cos(sine/1.3)), math.rad(3), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.37+0.17*math.cos(sine/1.3), -0.2) * CFrame.Angles(math.rad(32+7*math.cos(sine/1.3)), math.rad(0), math.rad(0)), 0.1)
end



elseif RootPart.Velocity.y < -1 and freefall > 150 and hitfloor==nil then
Anim="FreeFall"
change = 1


if attack==false then
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(-90+3*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(14+12*math.cos(sine/1.3)), math.rad(0), math.rad(110)), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(14+12*math.cos(sine/1.3)), math.rad(0), math.rad(-110)), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-12+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3),0.2) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(3), math.rad(-46)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.17*math.cos(sine/1.3), 0.2) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(0), math.rad(46)), 0.1)
end

elseif torvel<1 and hitfloor~=nil then
Anim="Idle"
change = 1
if attack==false and equip == false then
  
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.04*math.cos(sine/40), -0) * CFrame.Angles(math.rad(0-0.81*math.cos(sine/40)), math.rad(-40), math.rad(0)), 0.1)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0+2.6*math.sin(sine/40)),math.rad(0),math.rad(40)),0.1)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.55+0.04*math.sin(sine/40), 0-0.04*math.cos(sine/40)) * angles(math.rad(-2+1.3*math.cos(sine/40)), math.rad(0+4*math.sin(sine/40)), math.rad(6.3+2.2*math.cos(sine/40))),0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.55+0.04*math.sin(sine/40), 0-0.04*math.cos(sine/40)) * angles(math.rad(2+1.3*math.cos(sine/40)), math.rad(0-4*math.sin(sine/40)), math.rad(-6.3-2.2*math.cos(sine/40))),0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, llegendPoint.Y-LeftLeg.Position.Y+0.04*math.cos(sine/40), 0) * CFrame.Angles(math.rad(0+0.81*math.cos(sine/40)), math.rad(18+0.81*math.cos(sine/40)), math.rad(-2-0.81*math.cos(sine/40))),0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.57, rlegendPoint.Y-RightLeg.Position.Y+0.04*math.cos(sine/40), 0)  * CFrame.Angles(math.rad(0+0.81*math.cos(sine/40)), math.rad(-2+0.81*math.cos(sine/40)), math.rad(3-0.81*math.cos(sine/40))),0.1)
end


	
elseif torvel>1.5 and torvel<70 and hitfloor~=nil then
Anim="Walk"
change = 0.84+ Character.Humanoid.WalkSpeed/132
look = 0
if attack==false and equip == false then
					       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/2), -.8) * angles(math.rad(-26), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+20*math.sin(sine/2)),math.rad(0),math.rad(0+5*math.sin(sine/4)) + RootPart.RotVelocity.Y / 13),.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.1) * angles(math.rad(-60-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(15+2*math.sin(sine/4))- RootPart.RotVelocity.Y / 34),.15)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.1)*angles(math.rad(-60-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-15+2*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34),.15)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.28*math.cos(sine/4), 0-0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0+104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.3)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.28*math.cos(sine/4),0+0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0-104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.3)
end


		elseif torvel>=70 and torvel<200 and hitfloor~=nil then
		Anim="Run"
		change = 0.84+ Character.Humanoid.WalkSpeed/142
		if attack==false and equip == false then
					       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/1.5), -.8) * angles(math.rad(-37), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+25*math.sin(sine/1.5)),math.rad(0),math.rad(0+5*math.sin(sine/3)) + RootPart.RotVelocity.Y / 13),.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.3) * angles(math.rad(-72-8*math.sin(sine/1.5))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(1+0*math.cos(sine/3))- RootPart.RotVelocity.Y / 34),.25)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.3)*angles(math.rad(-72-8*math.sin(sine/1.5))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-1+0*math.cos(sine/3))+ RootPart.RotVelocity.Y / -34),.25)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.32*math.cos(sine/3), 0-0.42*math.cos(sine/3)) * CFrame.Angles(math.rad(0+134*math.sin(sine/3)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.44)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.32*math.cos(sine/3),0+0.42*math.cos(sine/3)) * CFrame.Angles(math.rad(0-134*math.sin(sine/3)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.44)
		end
		
		--[[
		if attack==false then
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1-0.4*math.cos(sine/5.5)/2, 0 *math.sin(sine/6.6)/2) * CFrame.Angles(math.rad(0) + -math.sin(sine/5.5)/1.2, math.rad(0), 0), .8)
		RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.4*math.cos(sine/5.5)/2,0 *-math.sin(sine/6.6)/2) * CFrame.Angles(math.rad(0) + math.sin(sine/5.5)/1.2, math.rad(0), 0), .8)
		end
		]]
		if attack==true and noleg == false then
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1-0.24*math.cos(sine/5), 0.+0.24*math.cos(sine/5)) * CFrame.Angles(math.rad(0-74*math.sin(sine/5)), math.rad(0), math.rad(0)), 0.3)
		   RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.24*math.cos(sine/5),0.-0.24*math.cos(sine/5)) * CFrame.Angles(math.rad(0+74*math.sin(sine/5)), math.rad(0), math.rad(0)), 0.3)
		end
		
		
		
				elseif torvel>=200 and hitfloor~=nil then
		Anim="MachRun"
		change = 0.84+ Character.Humanoid.WalkSpeed/182
		if attack==false and equip == false then
					       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/1), -3.8) * angles(math.rad(-44), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .2)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+25*math.sin(sine/1)),math.rad(0),math.rad(0+5*math.sin(sine/2)) + RootPart.RotVelocity.Y / 13),.2)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.5) * angles(math.rad(-78-12*math.sin(sine/1))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(-24+0*math.cos(sine/2))- RootPart.RotVelocity.Y / 34),.35)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.5)*angles(math.rad(-78-12*math.sin(sine/1))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(24+0*math.cos(sine/2))+ RootPart.RotVelocity.Y / -34),.35)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.42*math.cos(sine/2), 0-0.62*math.cos(sine/2)) * CFrame.Angles(math.rad(0+134*math.sin(sine/2)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.52)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.42*math.cos(sine/2),0+0.62*math.cos(sine/2)) * CFrame.Angles(math.rad(0-134*math.sin(sine/2)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.52)
		end
		
		

end









 if 0 < #Effects then
      for e = 1, #Effects do
        if Effects[e] ~= nil then
          local Thing = Effects[e]
          if Thing ~= nil then
            local Part = Thing[1]
            local Mode = Thing[2]
            local Delay = Thing[3]
            local IncX = Thing[4]
            local IncY = Thing[5]
            local IncZ = Thing[6]
            if Thing[1].Transparency <= 1 then
              if Thing[2] == "Block1" then
                Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                Mesh = Thing[1]:FindFirstChild("Mesh")
                if not Mesh then
                  Mesh = Instance.new("BlockMesh")
                end
                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
              elseif Thing[2] == "Cylinder" then
                  Mesh = Thing[1]:FindFirstChild("Mesh")
                  if not Mesh then
                    Mesh = Instance.new("BlockMesh")
                  end
                  Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                elseif Thing[2] == "Blood" then
                    Mesh = Thing[1]:FindFirstChild("Mesh")
                    if not Mesh then
                      Mesh = Instance.new("BlockMesh")
                    end
                    Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
                    Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                    Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                  elseif Thing[2] == "Elec" then
                      Mesh = Thing[1]:FindFirstChild("Mesh")
                      if not Mesh then
                        Mesh = Instance.new("BlockMesh")
                      end
                      Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                    elseif Thing[2] == "Disappear" then
                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                      end
            else
              Part.Parent = nil
              game:GetService("Debris"):AddItem(Part, 0)
              table.remove(Effects, e)
            end
          end
        end
      end
    end

end
	    	end
    
    --	if string.sub(BAR.Text, 1, 9) == ("traprifle") then
	    
	--    end
	    --billie
	    	if string.sub(BAR.Text, 1, 6) == ("billie") then
	    
 
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)

function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end


loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(1)

-- nebula's ezconvert
--[[
PUT YOUR SCRIPTS BELOW HERE VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV	
]]
local plr = game:GetService("Players").LocalPlayer
local char = workspace.non
if char:FindFirstChild("Animate") then
	char.Animate:Destroy()
end
local hum = char:FindFirstChildOfClass("Humanoid")
local tors = char.Torso
local head = char.Head
local rootpart = char.HumanoidRootPart
local RS = tors["Right Shoulder"]
local LS = tors["Left Shoulder"]
local RH = tors["Right Hip"]
local LH = tors["Left Hip"]
local neck = tors.Neck
local rootj = rootpart.RootJoint
local RSnor = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
local LSnor = CFrame.new(-1, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
local RHnor = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
local LHnor = CFrame.new(-1, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
local necknor = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local rootjnor = CFrame.new(0, 0, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local sine = 0
local music = Instance.new("Sound")
music.Parent = tors
local timepos = 0
local attack = false
local rooted = false
local playing = true
local speed = 16
local nokill = {
	"mrfunnylaughs4",
	"v_Sado"
}
local wig = Instance.new("Part")
wig.Size = Vector3.new(1.4, 1.99, 0.84)
wig.Parent = head
local mesh = Instance.new("SpecialMesh")
mesh.MeshType = Enum.MeshType.FileMesh
mesh.MeshId = "rbxassetid://952995462"
mesh.Scale = Vector3.new(1.44, 1.4, 1.22)
mesh.TextureId = "rbxassetid://949743130"
mesh.VertexColor = Vector3.new(1, 0.839, 0.73)
mesh.Parent = wig
local weld = Instance.new("Weld")
weld.Part0 = wig
weld.Part1 = head
weld.C1 = CFrame.new(0, -0.8, 0.25)
weld.Parent = wig
local rem = Instance.new("RemoteEvent")
rem.Name = "Events"
--[[
local Player = game:GetService("Players").LocalPlayer
    local Event = script:WaitForChild("UserInput_Event")
 
    local Mouse = Player:GetMouse()
    local UIS = game:GetService("UserInputService")
    local input = function(io,a)
        if a then return end
        --Since InputObject is a client-side instance, we create and pass table instead
        Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState,Hit=Mouse.Hit,Target=Mouse.Target})
    end
    UIS.InputBegan:Connect(input)
    UIS.InputEnded:Connect(input)
 
    local h,t
    --Give the server mouse data 30 times every second, but only if the values changed
    --If player is not moving their mouse, client won't fire events
    while wait(1/30) do
        if h~=Mouse.Hit or t~=Mouse.Target then
            h,t=Mouse.Hit,Mouse.Target
            Event:FireServer({isMouse=true,Target=t,Hit=h})
        end
    ]]--,plr.Character)	
rem.OnServerEvent:Connect(function(player, key)
	if player == plr then
		if attack == false then
			if key == "t" then
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://145757437"
				sound.Volume = 10
				sound.Parent = head
				local effect = Instance.new("PitchShiftSoundEffect")
				effect.Octave = 1.75
				effect.Parent = sound
				sound:Play()
				for i = 1, 120 do
					game:GetService("RunService").Stepped:Wait()
					head.Size = Vector3.new(2 + 1 * math.sin(sine / 5), 1 + 1 * math.sin(sine / 5), 1 + 1 * math.sin(sine / 5)) 
					neck.C0 = necknor * CFrame.new(0, 0, math.sin(sine / 5))
				end
				head.Size = Vector3.new(2, 1, 1)
			end
			if key == "r" then
				attack = true
				rooted = true
				playing = false
				local scream = Instance.new("Sound")
				scream.SoundId = "rbxassetid://176238381"
				scream.Parent = head
				scream:Play()
				repeat
					game:GetService("RunService").Stepped:Wait()
					RS.C0 = RSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					LS.C0 = LSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					RH.C0 = RHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					LH.C0 = LHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					rootj.C0 = rootjnor * CFrame.new(0, 0, 3 * math.sin(sine / 2)) * CFrame.Angles(sine / 2, 0, 0)
					neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
				until scream.Playing == false
				scream:Destroy()
				rooted = false
				if math.random(1, 3) == 1 then
					local sound = Instance.new("Sound")
					sound.SoundId = "rbxassetid://2878822762"
					sound.Volume = 10
					sound.PlaybackSpeed = 2
					sound.Parent = head
					sound:Play()
					repeat
						game:GetService("RunService").Stepped:Wait()
						head.Size = Vector3.new(2 + 1 * math.sin(sine / 2), 1 + 1 * math.sin(sine / 2), 1 + 1 * math.sin(sine / 2)) 
						RS.C0 = RSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						LS.C0 = LSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						RH.C0 = RHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						LH.C0 = LHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						rootj.C0 = rootjnor
						neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					until sound.Playing == false
					head.Size = Vector3.new(2, 1, 1)
				end
				playing = true
				attack = false
			end
			if key == "y" then
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://3475233802"
				sound.Volume = 10
				sound.Parent = head
				sound:Play()
				local thing = head.Touched:Connect(function(hit)
					local found = false
					for i,v in pairs(nokill) do
						if game:GetService("Players"):FindFirstChild(v) then
							if hit:IsDescendantOf(game:GetService("Players")[v].Character) then
								found = true
							end
						end
					end
					if found == false and hit.Size.Magnitude < 300 then
						local parent = hit.Parent
						hit.Parent = nil
						wait(math.random(20, 50) / 10)
						hit.Anchored = false
						hit.BrickColor = BrickColor.new("Bright green")
						hit.CFrame = head.CFrame
						hit.Velocity = head.CFrame.LookVector * 150
						hit.Parent = parent
						local sound = Instance.new("Sound")
						sound.SoundId = "rbxassetid://704088758"
						sound.Volume = 10
						sound.Parent = head
						sound:Play()
					end
				end)
				for i = 1, 180 do
					game:GetService("RunService").Stepped:Wait()
					head.Size = Vector3.new(20, 10, 10)
					neck.C0 = necknor * CFrame.new(0, -10, 0)
				end
				thing:Disconnect()
				head.Size = Vector3.new(2, 1, 1)
			end
			if key == "p" then
				attack = true
				playing = false
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://2533880583"
				sound.Volume = 3
				sound.TimePosition = 20.15
				sound.Parent = head
				sound:Play()
				wig.Parent = nil
				local hat = Instance.new("Part")
				hat.Name = "JevilHat"
				hat.CanCollide = false
				hat.Size = Vector3.new(1, 1, 1)
				hat.Parent = char
				local mesh = Instance.new("SpecialMesh")
				mesh.MeshType = Enum.MeshType.FileMesh
				mesh.MeshId = "rbxassetid://193760002"
				mesh.TextureId = "rbxassetid://193760041"
				mesh.VertexColor = Vector3.new(0.5, 0, 0.5)
				mesh.Parent = hat
				local weld = Instance.new("Weld")
				weld.Part0 = head
				weld.Part1 = hat
				weld.C0 = CFrame.new(0, 0.5, 0.31)
				weld.Parent = hat
				for i,v in pairs(head:GetChildren()) do
					if v:IsA("Decal") then
						local old = v.Texture
						v.Texture = "rbxassetid://241553801"
						coroutine.resume(coroutine.create(function()
							repeat game:GetService("RunService").Stepped:Wait() until sound.Playing == false or sound.TimePosition > 30.35
							v.Texture = old
						end))
					end
				end
				local anything = Instance.new("Sound")
				anything.SoundId = "rbxassetid://2544975373"
				anything.Volume = 10
				anything.Parent = head
				anything:Play()
				speed = 50
				repeat
					game:GetService("RunService").Stepped:Wait()
					RS.C0 = RSnor * CFrame.Angles(0, 0, math.pi / 2 - 1 * math.sin(sine / 3))
					LS.C0 = LSnor * CFrame.Angles(0, 0, -math.pi / 2 + 1 * math.sin(sine / 3))
					RH.C0 = RHnor
					LH.C0 = LHnor
					rootj.C0 = rootjnor
					neck.C0 = necknor
				until sound.Playing == false or sound.TimePosition > 30.35
				speed = 16
				hat:Destroy()
				wig.Parent = head
				sound:Destroy()
				playing = true
				attack = false
			end
			if key == "f" then
				attack = true
				playing = false
				speed = 150
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://2259766079"
				sound.Volume = 10
				sound.Parent = head
				sound:Play()
				local timepos = 0
				local thing = 1
				repeat
					game:GetService("RunService").Stepped:Wait()
					if sound.Parent ~= head then
						local sound = Instance.new("Sound")
						sound.TimePosition = timepos
						sound.Parent = head
					end
					sound.Volume = 10
					sound.PlaybackSpeed = 1
					sound.Playing = true
					timepos = sound.TimePosition
					RS.C0 = RSnor * CFrame.Angles(0, 0, math.pi / 2 - 1 * math.sin(sine / (15 / thing)))
					LS.C0 = LSnor * CFrame.Angles(0, 0, -math.pi / 2 + 1 * math.sin(sine / (15 / thing)))
					RH.C0 = RHnor
					LH.C0 = LHnor
					rootj.C0 = rootjnor
					neck.C0 = necknor
					thing = thing + 0.005
				until sound.Playing == false or sound.TimePosition > 10
				local old = head.BrickColor
				repeat
					game:GetService("RunService").Stepped:Wait()
					if sound.TimePosition > 20 then
						head.BrickColor = BrickColor.new("Sunrise")
					end
					sound.PlaybackSpeed = sound.PlaybackSpeed + 0.001
					head.Size = head.Size + Vector3.new(0.01, 0.01, 0.01)
					neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
				until sound.Playing == false
				for i = 1, 20 do
					local clone = head:Clone()
					clone.Parent = workspace
					clone.Velocity = Vector3.new(0, 200, 0)
					local sound = Instance.new("Sound")
					sound.SoundId = "rbxassetid://2878822762"
					sound.Volume = 0.5
					sound.Parent = head
					sound:Play()
				end
				head.Size = Vector3.new(2, 1, 1)
				head.BrickColor = old
				speed = 16
				playing = true
				attack = false
			end
			if key == "u" then
				local part = Instance.new("Part")
				part.CFrame = rootpart.CFrame * CFrame.new(0, 0, 5)
				part.Size = Vector3.new(3, 4, 3)
				part.Parent = workspace
				local click = Instance.new("ClickDetector")
				click.Parent = part
				local mesh = Instance.new("SpecialMesh")
				mesh.MeshType = Enum.MeshType.FileMesh
				mesh.MeshId = "rbxassetid://430897733"
				mesh.Scale = Vector3.new(4, 4, 4)
				mesh.TextureId = "rbxassetid://430897961"
				mesh.Parent = part
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://741801027"
				sound.Volume = 3
				sound.Parent = part
				sound:Play()
				click.MouseClick:Connect(function()
					local banana = Instance.new("Part")
					banana.Size = Vector3.new(1, 1, 1)
					banana.CFrame = part.CFrame * CFrame.new(0, 5, 0)
					banana.Velocity = Vector3.new(math.random(-25, 25), 200, math.random(-25, 25))
					banana.Parent = workspace
					local mesh = Instance.new("SpecialMesh")
					mesh.MeshType = Enum.MeshType.FileMesh
					mesh.MeshId = "rbxassetid://28937301"
					mesh.TextureId = "rbxassetid://28937670"
					mesh.Scale = Vector3.new(0.8, 0.8, 0.8)
					mesh.Parent = banana
					local sound = Instance.new("Sound")
					sound.SoundId = "rbxassetid://28976727"
					sound.Volume = 2
					sound.Parent = banana
					sound:Play()
					local touched = false
					banana.Touched:Connect(function(hit)
						if hit.Parent and hit.Parent:FindFirstChild("Head") and not hit:IsDescendantOf(char) and touched == false then
							touched = true
							coroutine.resume(coroutine.create(function()
								for i = 1, 60 do
									game:GetService("RunService").Stepped:Wait()
									mesh.Scale = mesh.Scale + Vector3.new(0.3, 0.3, 0.3)
									banana.Size = banana.Size + Vector3.new(0.3, 0.3, 0.3)
								end
								banana:Destroy()
							end))
							local sound = Instance.new("Sound")
							sound.SoundId = "rbxassetid://168411776"
							sound.Volume = 10
							sound.Parent = hit.Parent.Head
							sound:Play()
						end
					end)
				end)
				repeat game:GetService("RunService").Stepped:Wait() until sound.Playing == false
				part:Destroy()
			end
		end
	end
end)
while game:GetService("RunService").Stepped:Wait() do
	sine = sine + 1
	if attack then 
		if rooted then
			hum.WalkSpeed = 0
			hum.JumpPower = 0
		else
			hum.WalkSpeed = speed
			hum.JumpPower = 50
		end
	else
		hum.WalkSpeed = 16
		hum.JumpPower = 50
	end
	for i,v in pairs(char:GetChildren()) do
		if v:IsA("Accessory") then
			v:Destroy()
		end
	end
	if music.Parent ~= tors then
		music = Instance.new("Sound")
		music.Parent = tors
		music.TimePosition = timepos
	else
		timepos = music.TimePosition
	end
	music.PlaybackSpeed = 0.84
	music.Volume = 1
	music.SoundId = "rbxassetid://3015811673"
	music.Playing = playing
	local torsvel = (tors.Velocity * Vector3.new(1, 0, 1)).Magnitude
	local hitfloor = workspace:FindPartOnRay(Ray.new(char.HumanoidRootPart.CFrame.Position, ((CFrame.new(char.HumanoidRootPart.Position, char.HumanoidRootPart.Position - Vector3.new(0, 1, 0))).LookVector).Unit * 4), char)
	if attack == false then
		if torsvel < 1 and hitfloor then
			RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(0, 0, math.pi / 2 + 0.3 * math.cos(sine / 7) + 0.5 * math.sin(sine / 14)), 0.15)
			LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(0, 0, 0.5 + 0.2 * math.sin(sine / 7) + 0.15 * math.cos(sine / 14)), 0.15)
			RH.C0 = RH.C0:Lerp(RHnor * CFrame.Angles(0, 0, -0.5 + 1 * math.sin(sine / 14) - 0.5 * math.cos(sine / 28)), 0.15)
			LH.C0 = LH.C0:Lerp(LHnor * CFrame.new(0.1 * math.sin(sine / 3.5) + 0.2 * math.cos(sine / 14), 0, 0) * CFrame.Angles(0, 0.2 * math.cos(sine / 28) - 0.3 * math.sin(sine / 48) + 0.15 * math.cos(sine / 3.5) - 0.25 * math.sin(sine / 3.5), -0.1 * math.sin(sine / 3.5) - 0.2 * math.cos(sine / 14)), 0.15)
			rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.new(0, 0, 0.3 * math.cos(sine / 4.5)), 0.15)
			neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(math.sin(sine / 10), math.cos(sine / 10), 0), 0.15)
		end
		if torsvel > 1 and hitfloor then
			RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(0, sine / 5, -1 * math.sin(sine / 7)), 0.15)
			LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(0, sine / 5, -1 * math.sin(sine / 7)), 0.15)
			RH.C0 = RH.C0:Lerp(RHnor * CFrame.new(1 * math.cos(sine / 7), 0.15 + 0.5 * math.cos(sine / 7), 0) * CFrame.Angles(0, 0.3 * math.sin(sine / 7), -0.23 + 1 * math.sin(sine / 7)), 0.15)
			LH.C0 = LH.C0:Lerp(LHnor * CFrame.new(1 * math.cos(sine / 7), 0.15 - 0.5 * math.cos(sine / 7), 0) * CFrame.Angles(0, 0.3 * math.sin(sine / 7), 0.23 + 1 * math.sin(sine / 7)), 0.15)
			rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.new(0, 0, -0.1 + 0.2 * math.cos(sine / 3.5)) * CFrame.Angles(0.2 - 0.4 * math.sin(sine / 3.5), rootpart.RotVelocity.Y / 50, -0.3 * math.sin(sine / 7)), 0.15)
			neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(0.4 * math.sin(sine / 3.5), 0, -head.RotVelocity.Y / 15 + 0.3 * math.sin(sine / 7)), 0.15)
		end
		if not hitfloor then
			RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(math.clamp(tors.Velocity.Y / 200 - 0.3, -hum.JumpPower / 200 - 0.3, hum.JumpPower / 200 - 0.3), 0, math.pi / 1.5), 0.15)
			LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(math.clamp(tors.Velocity.Y / 200 - 0.3, -hum.JumpPower / 200 - 0.3, hum.JumpPower / 200 - 0.3), 0, -math.pi / 1.5), 0.15)
			RH.C0 = RH.C0:Lerp(RHnor + Vector3.new(0, -0.6, 0.4), 0.15)
			LH.C0 = LH.C0:Lerp(LHnor * CFrame.Angles(0, 0, -0.3) + Vector3.new(0, -0.1, 0), 0.15)
			rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.Angles(-math.clamp(tors.Velocity.Y / 100, -hum.JumpPower / 100, hum.JumpPower / 100), 0, 0), 0.15)
			neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(math.random(-100, 100) / 1000, math.random(-100, 100) / 1000, math.random(-100, 100) / 1000), 0.15)
		end
	end
end

	   end
--billie end
			end-- bar end
	--	CMDBAR.Text = ""

end)


end)
TextLabel.Parent = DW
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.Position = UDim2.new(0.0814071298, 0, 0.29780513, 0)
TextLabel.Size = UDim2.new(0, 200, 0, 50)
TextLabel.Font = Enum.Font.GothamBold
TextLabel.Text = "Light Mode"
TextLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.TextSize = 20.000

WD.Name = "WD"
WD.Parent = Frame
WD.AnchorPoint = Vector2.new(0.5, 0.5)
WD.BackgroundColor3 = Color3.fromRGB(21, 21, 21)
WD.BackgroundTransparency = 1.000
WD.Position = UDim2.new(0, 359, 0, 161)
WD.Size = UDim2.new(0, 239, 0, 323)
WD.Image = "rbxassetid://2790382281"
WD.ImageColor3 = Color3.fromRGB(29, 29, 29)
WD.ScaleType = Enum.ScaleType.Slice
WD.SliceCenter = Rect.new(4, 4, 252, 252)

Icon_2.Name = "Icon"
Icon_2.Parent = WD
Icon_2.AnchorPoint = Vector2.new(0.5, 0.5)
Icon_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Icon_2.BackgroundTransparency = 1.000
Icon_2.BorderSizePixel = 0
Icon_2.Position = UDim2.new(0, 200, 0, 46)
Icon_2.Size = UDim2.new(0, 79, 0, 62)
Icon_2.Image = "http://www.roblox.com/asset/?id=5459745167"

Dark.Name = "Dark"
Dark.Parent = WD
Dark.AnchorPoint = Vector2.new(0.5, 0.5)
Dark.BackgroundColor3 = Color3.fromRGB(240, 240, 240)
Dark.BackgroundTransparency = 1.000
Dark.Position = UDim2.new(0.496721029, 0, 0.769523799, 0)
Dark.Size = UDim2.new(0, 207, 0, 46)
Dark.Image = "rbxassetid://2790389767"
Dark.ImageColor3 = Color3.fromRGB(0, 190, 139)
Dark.ScaleType = Enum.ScaleType.Slice
Dark.SliceCenter = Rect.new(8, 8, 248, 248)
Dark.MouseButton1Down:connect(function()
Selection.Frame:TweenPosition(UDim2.new(-0.409, 0,0.288, 0), 'Out', 'Bounce', 1, true)
wait(4)
game.CoreGui.Selection:Destroy()
	-- Gui to Lua
-- Version: 3.1
--game.CoreGui.sangiscool:Destroy()
-- Instances:
lplayer = game:GetService("Players").LocalPlayer
local Mouse = lplayer:GetMouse()
local sangiscool = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local sangWAREexecutionground = Instance.new("ImageLabel")
local Icon = Instance.new("ImageLabel")
local ImageButton = Instance.new("ImageButton")
local BAR = Instance.new("TextBox")

--Properties:

sangiscool.Name = "sangiscool"
sangiscool.Parent = game.CoreGui
sangiscool.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Frame.Parent = sangiscool
Frame.BackgroundColor3 = Color3.fromRGB(34, 34, 34)
Frame.BackgroundTransparency = 1.000
Frame.Position = UDim2.new(0.37716049, 0, 0.270689636, 0)
Frame.Size = UDim2.new(0, 536, 0, 281)

sangWAREexecutionground.Name = "sangWARE execution ground"
sangWAREexecutionground.Parent = Frame
sangWAREexecutionground.AnchorPoint = Vector2.new(0.5, 0.5)
sangWAREexecutionground.BackgroundColor3 = Color3.fromRGB(24, 24, 24)
sangWAREexecutionground.BackgroundTransparency = 1.000
sangWAREexecutionground.Position = UDim2.new(0, 268, 0, 142)
sangWAREexecutionground.Size = UDim2.new(0, 519, 0, 264)
sangWAREexecutionground.Image = "rbxassetid://2790382281"
sangWAREexecutionground.ImageColor3 = Color3.fromRGB(68, 68, 68)
sangWAREexecutionground.ScaleType = Enum.ScaleType.Slice
sangWAREexecutionground.SliceCenter = Rect.new(4, 4, 252, 252)

Icon.Name = "Icon"
Icon.Parent = sangWAREexecutionground
Icon.AnchorPoint = Vector2.new(0.5, 0.5)
Icon.BackgroundColor3 = Color3.fromRGB(24, 24, 24)
Icon.BackgroundTransparency = 1.000
Icon.BorderSizePixel = 0
Icon.Position = UDim2.new(0, 48, 0, 42)
Icon.Size = UDim2.new(0, 79, 0, 62)
Icon.Image = "http://www.roblox.com/asset/?id=5459745167"

--ImageButton.Parent = sangWAREexecutionground
--ImageButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
--ImageButton.BorderColor3 = Color3.fromRGB(255, 255, 255)
--ImageButton.Position = UDim2.new(0.882948041, 0, 0.774934292, 0)
--ImageButton.Size = UDim2.new(0, 40, 0, 40)
ImageButton.Image = "http://www.roblox.com/asset/?id=115574122"

BAR.Name = "BAR"
BAR.Parent = sangWAREexecutionground
BAR.AnchorPoint = Vector2.new(0.5, 0.5)
BAR.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
BAR.BackgroundTransparency = 0.500
BAR.BorderSizePixel = 0
BAR.Position = UDim2.new(0.498792917, 0, 0.561797142, 0)
BAR.Size = UDim2.new(0, 367, 0, 81)
BAR.Font = Enum.Font.Gotham
BAR.PlaceholderColor3 = Color3.fromRGB(103, 103, 103)
BAR.PlaceholderText = "Enter Command"
BAR.Text = ""
BAR.TextColor3 = Color3.fromRGB(2, 2, 2)
BAR.TextSize = 14.000



-- Scripts:
local function RULWIG_fake_script() -- MainFrame.Draggify 
	local script = Instance.new('LocalScript', game.CoreGui.sangiscool.Frame)

	local UIS = game:GetService("UserInputService")
	function dragify(Frame)
		dragToggle = nil
		dragSpeed = 0.5
		dragInput = nil
		dragStart = nil
		dragPos = nil
		function updateInput(input)
			Delta = input.Position - dragStart
			Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
			game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.25), {Position = Position}):Play()
		end
		Frame.InputBegan:Connect(function(input)
			if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and UIS:GetFocusedTextBox() == nil then
				dragToggle = true
				dragStart = input.Position
				startPos = Frame.Position
				input.Changed:Connect(function()
					if input.UserInputState == Enum.UserInputState.End then
						dragToggle = false
					end
				end)
			end
		end)
		Frame.InputChanged:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
				dragInput = input
			end
		end)
		game:GetService("UserInputService").InputChanged:Connect(function(input)
			if input == dragInput and dragToggle then
				updateInput(input)
			end
		end)
	end
	dragify(script.Parent)
	
end
coroutine.wrap(RULWIG_fake_script)()
--chat command
prefix = "."

game.Players.LocalPlayer.Chatted:Connect(function(msg)
if string.sub(msg, 1, 5) == (prefix.."gale") then
     	    

--cal hm  = sethiddenproperty(game.Players.CurbYismm.SimulationRadius            )
--int(hm)
---thiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end

loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()

print("cool")




--[[ Name : Gale Fighter ]]--
-------------------------------------------------------
--A Collaboration Between makhail07 and KillerDarkness0105

--Base Animaion by makhail07, attacks by KillerDarkness0105
-------------------------------------------------------


local FavIDs = {
	340106355, --Nefl Crystals
	927529620, --Dimension
	876981900, --Fantasy
	398987889, --Ordinary Days
	1117396305, --Oh wait, it's you.
	885996042, --Action Winter Journey
	919231299, --Sprawling Idiot Effigy
	743466274, --Good Day Sunshine
	727411183, --Knife Fight
	1402748531, --The Earth Is Counting On You!
	595230126 --Robot Language
	}



--The reality of my life isn't real but a Universe -makhail07
wait(0.2)
local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name)
print('yankee with no')
print('brim')
local char = workspace.non
local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")
hum.MaxHealth = 200
hum.Health = 200

-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
vt = Vector3.new
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 90
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------



-------------------------------------------------------
--Start Combo Function--
-------------------------------------------------------
local comboing = false
local combohits = 0
local combotime = 0
local maxtime = 65



function sandbox(var,func)
	local env = getfenv(func)
	local newenv = setmetatable({},{
		__index = function(self,k)
			if k=="script" then
				return var
			else
				return env[k]
			end
		end,
	})
	setfenv(func,newenv)
	return func
end
cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
comboframe = Instance.new("ScreenGui")
Frame1 = Instance.new("Frame")
Frame2 = Instance.new("Frame")
TextLabel3 = Instance.new("TextLabel")
comboframe.Name = "combinserter"
comboframe.Parent = mas
Frame1.Name = "combtimegui"
Frame1.Parent = comboframe
Frame1.Size = UDim2.new(0, 300, 0, 14)
Frame1.Position = UDim2.new(0, 900, 0.629999971, 0)
Frame1.BackgroundColor3 = Color3.new(0, 0, 0)
Frame1.BorderColor3 = Color3.new(0.0313726, 0.0470588, 0.0627451)
Frame1.BorderSizePixel = 5
Frame2.Name = "combtimeoverlay"
Frame2.Parent = Frame1
Frame2.Size = UDim2.new(0, 0, 0, 14)
Frame2.BackgroundColor3 = Color3.new(0, 1, 0)
Frame2.ZIndex = 2
TextLabel3.Parent = Frame2
TextLabel3.Transparency = 0
TextLabel3.Size = UDim2.new(0, 300, 0, 50)
TextLabel3.Text ="Hits:  "..combohits
TextLabel3.Position = UDim2.new(0, 0, -5.5999999, 0)
TextLabel3.BackgroundColor3 = Color3.new(1, 1, 1)
TextLabel3.BackgroundTransparency = 1
TextLabel3.Font = Enum.Font.Bodoni
TextLabel3.FontSize = Enum.FontSize.Size60
TextLabel3.TextColor3 = Color3.new(0, 1, 0)
TextLabel3.TextStrokeTransparency = 0
gui = game:GetService("Players").LocalPlayer.PlayerGui
for i,v in pairs(mas:GetChildren()) do
	v.Parent = game:GetService("Players").LocalPlayer.PlayerGui
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
	spawn(function()
		pcall(v)
	end)
end





coroutine.resume(coroutine.create(function()
	while true do
		wait()
		
		
		if combotime>65 then
		    combotime = 65
	    end
	    
	    
	    
	    
	    
		if combotime>.1 and comboing == true then
		    TextLabel3.Transparency = 0
		    TextLabel3.TextStrokeTransparency = 0
		    TextLabel3.BackgroundTransparency = 1
		    Frame1.Transparency = 0
		    Frame2.Transparency = 0
		       TextLabel3.Text ="Hits:  "..combohits
		    combotime = combotime - .34
Frame2.Size = Frame2.Size:lerp(UDim2.new(0, combotime/maxtime*300, 0, 14),0.42)
    end
    
    
    
    
	    if combotime<.1 then
	        		    TextLabel3.BackgroundTransparency = 1
	        		    TextLabel3.Transparency = 1
		    TextLabel3.TextStrokeTransparency = 1

Frame2.Size = UDim2.new(0, 0, 0, 14)
	        combotime = 0
	        comboing = false
	       		    Frame1.Transparency = 1
		    Frame2.Transparency = 1
		   combohits = 0 
	        
	        end
end
end))



-------------------------------------------------------
--End Combo Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
         if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
         if insta == true then
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:service("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end




	kDamagefunc=function(hit,minim,maxim,knockback,Type,Property,Delay,KnockbackType,decreaseblock)
        if hit.Parent==nil then
                return
        end
        h=hit.Parent:FindFirstChild("Humanoid")
        for _,v in pairs(hit.Parent:children()) do
        if v:IsA("Humanoid") then
        h=v
        end
        end
        if hit.Parent.Parent:FindFirstChild("Torso")~=nil then
        h=hit.Parent.Parent:FindFirstChild("Humanoid")
        end
        if hit.Parent.className=="Hat" then
        hit=hit.Parent.Parent:findFirstChild("Head")
        end
        if h~=nil and hit.Parent.Name~=char.Name and hit.Parent:FindFirstChild("Torso")~=nil then
        if hit.Parent:findFirstChild("DebounceHit")~=nil then if hit.Parent.DebounceHit.Value==true then return end end
        --[[                if game.Players:GetPlayerFromCharacter(hit.Parent)~=nil then
                        return
                end]]
--                        hs(hit,1.2) 
                        c=Instance.new("ObjectValue")
                        c.Name="creator"
                        c.Value=game:service("Players").LocalPlayer
                        c.Parent=h
                        game:GetService("Debris"):AddItem(c,.5)
                Damage=math.random(minim,maxim)
--                h:TakeDamage(Damage)
                blocked=false
                block=hit.Parent:findFirstChild("Block")
                if block~=nil then
                print(block.className)
                if block.className=="NumberValue" then
                if block.Value>0 then
                blocked=true
                if decreaseblock==nil then
                block.Value=block.Value-1
                end
                end
                end
                if block.className=="IntValue" then
                if block.Value>0 then
                blocked=true
                if decreaseblock~=nil then
                block.Value=block.Value-1
                end
                end
                end
                end
                if blocked==false then
--                h:TakeDamage(Damage)
                h.Health=h.Health-Damage
                kshowDamage(hit.Parent,Damage,.5,BrickColor.new("White"))
                else
                h.Health=h.Health-(Damage/2)
                kshowDamage(hit.Parent,Damage/2,.5,BrickColor.new("White"))
                end
                if Type=="Knockdown" then
                hum=hit.Parent.Humanoid
hum.PlatformStand=true
coroutine.resume(coroutine.create(function(HHumanoid)
swait(1)
HHumanoid.PlatformStand=false
end),hum)
                local angle=(hit.Position-(Property.Position+Vector3.new(0,0,0))).unit
--hit.CFrame=CFrame.new(hit.Position,Vector3.new(angle.x,hit.Position.y,angle.z))*CFrame.fromEulerAnglesXYZ(math.pi/4,0,0)
local bodvol=Instance.new("BodyVelocity")
bodvol.velocity=angle*knockback
bodvol.P=5000
bodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
bodvol.Parent=hit
rl=Instance.new("BodyAngularVelocity")
rl.P=3000
rl.maxTorque=Vector3.new(500,500,500)
rl.angularvelocity=Vector3.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))
rl.Parent=hit
game:GetService("Debris"):AddItem(bodvol,.5)
game:GetService("Debris"):AddItem(rl,.5)
                elseif Type=="Normal" then
                vp=Instance.new("BodyVelocity")
                vp.P=500
                vp.maxForce=Vector3.new(math.huge,0,math.huge)
--                vp.velocity=Character.Torso.CFrame.lookVector*Knockback
                if KnockbackType==1 then
                vp.velocity=Property.CFrame.lookVector*knockback+Property.Velocity/1.05
                elseif KnockbackType==2 then
                vp.velocity=Property.CFrame.lookVector*knockback
                end
                if knockback>0 then
                        vp.Parent=hit.Parent.Torso
                end
                game:GetService("Debris"):AddItem(vp,.5)
            elseif Type=="Up" then
                hit.Parent.Humanoid.PlatformStand = true
                local bodyVelocity=Instance.new("BodyVelocity")
                bodyVelocity.velocity=vt(0,15,0)
                bodyVelocity.P=5000
                bodyVelocity.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
                bodyVelocity.Parent=hit
                game:GetService("Debris"):AddItem(bodyVelocity,1)
                rl=Instance.new("BodyAngularVelocity")
                rl.P=3000
rl.AngularVelocity = Vector3.new(2000,2000,2000)
rl.MaxTorque = Vector3.new(40000,40000,40000)
                rl.Parent=hit
                hit.Parent.Humanoid.PlatformStand = false
                game:GetService("Debris"):AddItem(rl,.5)
                elseif Type=="Snare" then
                bp=Instance.new("BodyPosition")
                bp.P=2000
                bp.D=100
                bp.maxForce=Vector3.new(math.huge,math.huge,math.huge)
                bp.position=hit.Parent.Torso.Position
                bp.Parent=hit.Parent.Torso
                game:GetService("Debris"):AddItem(bp,1)
            elseif Type=="Float" then
                hit.Parent.Humanoid.PlatformStand = true
                                bp=Instance.new("BodyPosition")
                bp.P=2000
                bp.D=400
                bp.maxForce=Vector3.new(math.huge,math.huge,math.huge)
                bp.position=hit.Parent.Torso.Position+vt(0,35,24)
                                bp.Parent=hit.Parent.Torso
                	
local	rl=Instance.new("BodyAngularVelocity",hit.Parent.Torso)
rl.P=377705
rl.maxTorque=Vector3.new(1,1,1)*500
rl.angularvelocity=Vector3.new(math.random(-3,3),math.random(-6,6),math.random(-3,3))

 local BF = Instance.new("BodyForce",hit.Parent.Torso)
            BF.force = Vector3.new(0, workspace.Gravity/1.10, 0)
                game:GetService("Debris"):AddItem(bp,5)
game:GetService("Debris"):AddItem(BF,5)
game:GetService("Debris"):AddItem(rl,5)
                elseif Type=="Target" then
                if Targetting==false then
                ZTarget=hit.Parent.Torso
                coroutine.resume(coroutine.create(function(Part) 
                so("http://www.roblox.com/asset/?id=15666462",Part,1,1.5) 
                swait(5)
                so("http://www.roblox.com/asset/?id=15666462",Part,1,1.5) 
                end),ZTarget)
                TargHum=ZTarget.Parent:findFirstChild("Humanoid")
                targetgui=Instance.new("BillboardGui")
                targetgui.Parent=ZTarget
                targetgui.Size=UDim2.new(10,100,10,100)
                targ=Instance.new("ImageLabel")
                targ.Parent=targetgui
                targ.BackgroundTransparency=1
                targ.Image="rbxassetid://4834067"
                targ.Size=UDim2.new(1,0,1,0)
                cam.CameraType="Scriptable"
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)
                workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                Targetting=true
                RocketTarget=ZTarget
                for i=1,Property do
                --while Targetting==true and Humanoid.Health>0 and Character.Parent~=nil do
                if Humanoid.Health>0 and char.Parent~=nil and TargHum.Health>0 and TargHum.Parent~=nil and Targetting==true then
                swait()
                end
                --workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,Head.CFrame.p+rmdir*100)
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)*cf(0,5,10)*euler(-0.3,0,0)
                end
                Targetting=false
                RocketTarget=nil
                targetgui.Parent=nil
                cam.CameraType="Custom"
                end
                end
                        debounce=Instance.new("BoolValue")
                        debounce.Name="DebounceHit"
                        debounce.Parent=hit.Parent
                        debounce.Value=true
                        game:GetService("Debris"):AddItem(debounce,Delay)
                        c=Instance.new("ObjectValue")
                        c.Name="creator"
                        c.Value=Player
                        c.Parent=h
                        game:GetService("Debris"):AddItem(c,.5)
                CRIT=false
                hitDeb=true
                AttackPos=6
                comboing = true
                combohits = combohits+1
                combotime = combotime+3.4


                
                if hitfloor == nil then
                    
    local velo=Instance.new("BodyVelocity")
                velo.velocity=vt(0,5.5,0)
                velo.P=8000
                velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                velo.Parent=root
                game:GetService("Debris"):AddItem(velo,0.06)
                
                                   local hitvelo=Instance.new("BodyVelocity")
                hitvelo.velocity=vt(0,5.5,0)
                hitvelo.P=8000
                hitvelo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                hitvelo.Parent=hit
                             game:GetService("Debris"):AddItem(hitvelo,0.06)
                             
                                                          coroutine.resume(coroutine.create(function()
                                 for i = 0,3.7,0.1 do
   swait()
         hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,0,-2.4)
        root.Velocity = root.CFrame.lookVector*0
        hit.Velocity = hit.CFrame.lookVector*130
end
end))
         coroutine.resume(coroutine.create(function()
             while ultra == true do
                 swait()
                 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,0,-2.4)
             end
             end))
                             
                
                end
                
                
        end
end
 
kshowDamage=function(Char,Dealt,du,Color)
        m=Instance.new("Model")
        m.Name=tostring(Dealt)
        h=Instance.new("Humanoid")
        h.Health=0
        h.MaxHealth=0
        h.Parent=m
        c=Instance.new("Part")
        c.Transparency=0
        c.BrickColor=Color
        c.Name="Head"
        c.Material = "Neon"
        c.TopSurface=0
        c.BottomSurface=0
        c.formFactor="Plate"
        c.Size=Vector3.new(1,.4,1)
        ms=Instance.new("CylinderMesh")
        ms.Scale=Vector3.new(.8,.8,.8)
        if CRIT==true then
                ms.Scale=Vector3.new(1,1.25,1)
        end
        ms.Parent=c
        c.Reflectance=0
        Instance.new("BodyGyro").Parent=c
        c.Parent=m
        if Char:findFirstChild("Head")~=nil then
        c.CFrame=CFrame.new(Char["Head"].CFrame.p+Vector3.new(0,1.5,0))
        elseif Char.Parent:findFirstChild("Head")~=nil then
        c.CFrame=CFrame.new(Char.Parent["Head"].CFrame.p+Vector3.new(0,1.5,0))
        end
        f=Instance.new("BodyPosition")
        f.P=2000
        f.D=220
        f.maxForce=Vector3.new(math.huge,math.huge,math.huge)
        f.position=c.Position+Vector3.new(0,3,0)
        f.Parent=c
        game:GetService("Debris"):AddItem(m,.5+du)
        c.CanCollide=false
        m.Parent=workspace
        c.CanCollide=false
    
end

-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end

function Eviscerate(dude)
	if dude.Name ~= char then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
			dude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
					end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
						v:Destroy()
					end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
						for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
								o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							v.Color = maincolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.08
								end
								wait(0.5)
								PartEmmit1.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end




--killer's effects





		function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end
	
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh){
		Parent = Part,
		Offset = OffSet,
		Scale = Scale,
	}
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
		
		
		
function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {
			prt,
			"Block1",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 2 then
		table.insert(Effects, {
			prt,
			"Block2",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
end

function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt=CreatePart(workspace,"Neon",0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh,num) 
for i=0,1,delay do
swait()
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,(math.random(0,1)+math.random())/5)
end

function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end


function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function BreakEffect(brickcolor, cframe, x1, y1, z1)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	local num = math.random(10, 50) / 1000
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Shatter",
		num,
		prt.CFrame,
		math.random() - math.random(),
		0,
		math.random(50, 100) / 100
	})
end





						       so = function(id,par,vol,pit)
		coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound",par or workspace)
		sou.Volume=vol
		sou.Pitch=pit or 1
		sou.SoundId=id
		sou:play()
		game:GetService("Debris"):AddItem(sou,8)
		end))
		end


--end of killer's effects


function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 900817147 --900817147
local SONG2 = 0
local Music = Instance.new("Sound",tors)
Music.Volume = 0.7
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
local attacktype = 1
local attackdebounce = false
local euler = CFrame.fromEulerAnglesXYZ
local cankick = false
----------------------------------------------------------------------------------
hum.WalkSpeed = 8
hum.JumpPower = 57
--[[
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
]]
local ANIMATOR = hum.Animator
local ANIMATE = char.Animate
ANIMATE.Parent = nil
ANIMATOR.Parent = nil
-------------------------------------------------------
--End Customization--
-------------------------------------------------------


-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------

--pls be proud mak i did my best



function attackone()
    
    attack = true
    
          for i = 0, 1.35, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4-2*i), math.rad(4+2*i), math.rad(-40-11*i)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(40+11*i)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.6, 0.2) * angles(math.rad(90+4*i), math.rad(-43), math.rad(16+6*i)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-43)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, 0) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, -0.2) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
      end
      
      so("http://roblox.com/asset/?id=1340545854",ra,1,math.random(0.7,1))


con5=ra.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,3,4,math.random(2,3),"Normal",root,0,1)

so("http://roblox.com/asset/?id=636494529",ra,2,1)
 
 RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))


      wait(0.34)
attackdebounce = false

end
end
end)
                for i = 0, 1.12, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(6), math.rad(23)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(-23)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.6, -0.8) * angles(math.rad(110), math.rad(23), math.rad(2)), 0.4)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0.2) * angles(math.rad(-37), math.rad(0), math.rad(-13)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.3) * RHCF * angles(math.rad(-4), math.rad(0), math.rad(6)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0.05) * LHCF * angles(math.rad(-22), math.rad(0), math.rad(23)), 0.3)
      end
      
      con5:Disconnect()
          attack = false
          
      end












function attacktwo()
    
    attack = true
    
          for i = 0, 1.35, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(46)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(6)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
      end
      
      so("http://roblox.com/asset/?id=1340545854",la,1,math.random(0.7,1))


con5=la.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,3,4,math.random(2,3),"Normal",root,0,1)

so("http://roblox.com/asset/?id=636494529",la,2,1)
 
 RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))


      wait(0.34)
attackdebounce = false

end
end
end)




                for i = 0, 1.12, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(-6), math.rad(-27)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(27)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.16) * angles(math.rad(-33), math.rad(0), math.rad(23)), 0.4)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.67, -0.9) * angles(math.rad(116), math.rad(-28), math.rad(1)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0.05) * RHCF * angles(math.rad(-22), math.rad(0), math.rad(-18)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, -0.3) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(4)), 0.3)
      end
      
      con5:Disconnect()
attack = false
          
      end





function attackthree()
    
    attack = true
    
    
              for i = 0, 1.14, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-46)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(36)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-12), math.rad(0), math.rad(34)), 0.2)
      end
    
    con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,4,5,math.random(3,4),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",ll,2,1)
 
 RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))

    
          wait(0.34)
attackdebounce = false

end
end
end)

        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 9.14, 0.3 do
        swait()
        BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-54*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      attack = false
      con5:disconnect()
end



function attackfour()
    
    attack = true
            so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
     WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
              for i = 0, 5.14, 0.1 do
        swait()
        SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24+4*i), math.rad(0), math.rad(0)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0+11*i), math.rad(0), math.rad(0)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(36+4*i)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(-36-4*i)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28+4*i)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34-4*i)), 0.2)
      end
              so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
       local velo=Instance.new("BodyVelocity")
                velo.velocity=vt(0,25,0)
                velo.P=8000
                velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                velo.Parent=root
                game:GetService("Debris"):AddItem(velo,0.7)



con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.6,-1.8)
end
end))
--kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1)
 RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8)),0.44)
end
end))


      wait(0.14)
attackdebounce = false
end
end
end)

                    for i = 0, 5.11, 0.15 do
        swait()
        BlockEffect(BrickColor.new("White"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.2*i) * angles(math.rad(-10-80*i), math.rad(0), math.rad(0)), 0.42)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
      end


      attack = false
      con5:disconnect()
    end





local cooldown = false
function quickkick()
    attack = true
    
    
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.3,-1.8)
end
end))

--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1)
 RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8)),0.44)
end
end))


      wait(0.08)
attackdebounce = false
end
end
end)

        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 11.14, 0.3 do
        swait()
        root.Velocity = root.CFrame.lookVector * 30
        BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-90*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      attack = false
      con5:disconnect()
end

    
    
    
    
    
    
    
function Taunt()
	attack = true
	hum.WalkSpeed = 0
	Cso("1535995570", hed, 8.45, 1)
	for i = 0, 8.2, 0.1 do
		swait()
		hum.WalkSpeed = 0
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25), Rad(0), Rad(16 * Cos(sine / 12))), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.1* Player_Size, 0.5 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(180), Rad(6), Rad(-56)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.1 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(45), Rad(6), Rad(86)), 0.1)
	end
	attack = false
	hum.WalkSpeed = 8
end
    
    





function Hyperkickcombo()
    
    attack = true
            so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
     WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
      for i = 0, 7.14, 0.1 do
        swait()
        SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(36)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-36)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
      end
local Cracking = Cso("292536356", tors, 10, 1)
 for i = 0, 7.14, 0.1 do
        swait()
		hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
		Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Lime green", 0, "Sphere")
		WaveEffect(BrickColor.new("Lime green"), root.CFrame * CFrame.new(0, -6, 0) * euler(0, math.random(-25, 25), 0), 1, 1, 1, 1, 0.2, 1, 0.05)
        SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
		SphereEffect(BrickColor.new("Lime green"),ll.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(30), math.rad(0), math.rad(0)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(36)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(-36)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
      end
      Cracking.Playing = false
      so("http://www.roblox.com/asset/?id=197161452", char, 3, 0.8)
              so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
              SphereEffect(BrickColor.new("Lime green"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
       local velo=Instance.new("BodyVelocity")
                velo.velocity=vt(0,27,0)
                velo.P=11000
                velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                velo.Parent=root
                game:GetService("Debris"):AddItem(velo,1.24)



con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,3.4,-1.8)
end
end))
--kDamagefunc(hit,2,3,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.09)
attackdebounce = false
end
end
end)

                    for i = 0, 9.11, 0.2 do
        swait()
        BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.12*i) * angles(math.rad(-10-95*i), math.rad(0), math.rad(0)), 0.42)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
      end




      con5:disconnect()
      
      
      
      
      
      
      con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
                       
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.08)
attackdebounce = false
end
end
end)
      
      
      
        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 9.14, 0.3 do
        swait()
               root.Velocity = root.CFrame.lookVector * 20
        BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(53), math.rad(8), math.rad(0-54*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      
      
      
            con5:disconnect()
      
      
      
      con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)
      
      
              so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 15.14, 0.32 do
        swait()
        root.Velocity = root.CFrame.lookVector * 20
        BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-50*i), math.rad(8+20*i), math.rad(0-90*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-4*i)), 0.35)
      end
      
      attack = false
      con5:disconnect()
      
    end





local ultra = false

function Galekicks()
    
    attack = true
                so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
          for i = 0, 1.65, 0.1 do
        swait()
        root.Velocity = root.CFrame.lookVector * 0
        SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end


for i = 1, 17 do
    
          con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)
    
          for i = 0, .1, 0.2 do
        swait()
                BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
                root.Velocity = root.CFrame.lookVector * 10
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
      end

      so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))
      
          for i = 0, 0.4, 0.2 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end
      con5:disconnect()
end

          		    		    
        u =   mouse.KeyDown:connect(function(key)
          	if key == 'r' and combohits >= 150 then
		    ultra = true
		    SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,15,15,15,0.04)
		    end
          end)
          wait(0.3)
         if ultra == true then 
combohits = 0
wait(0.1)
 for i = 0, 1.65, 0.1 do
        swait()
        root.Velocity = root.CFrame.lookVector * 0
        SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end


so("http://roblox.com/asset/?id=146094803",hed,1,1.2)

for i = 1, 65 do
    --Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Really red", 0, "Brick")
          con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)

            
            
            
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)
    
          for i = 0, .03, 0.1 do
        swait()
                BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
                root.Velocity = root.CFrame.lookVector * 10
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
      end

      so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))
      
          for i = 0, 0.07, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end
      con5:disconnect()
end

for i = 0, 1.65, 0.1 do
        swait()
        root.Velocity = root.CFrame.lookVector * 0
        SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end

con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 --hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit, 1, 3, 0,"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,.63)
 RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)

              so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 1, 1.4)
          SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
   
  for i = 0, 2, 0.1 do
        swait()
		--BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0.2) * RHCF * angles(math.rad(-50), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end
        SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
        
        wait(0.25)
        con5:Disconnect() 
   

        
        
        con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=565207203",ll,7,0.63)
 
 RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
SpecialEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,5,18,5,0.04)
WaveEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,1.5,16,1.5,0.04)

coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))
    
          wait(0.06)
attackdebounce = false

end
end
end)

coroutine.resume(coroutine.create(function()
    while ultra == true do
        swait()
        root.CFrame = root.CFrame*CFrame.new(math.random(-3,3),math.random(-2,2),math.random(-3,3))
    end
    end))


        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
        for i = 1,3 do
          for i = 0, 9.14, 0.45 do
        swait()
                root.Velocity = root.CFrame.lookVector * 30
        BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-94*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      end
    
    
    for i = 1,3 do
              for i = 0, 11.14, 0.45 do
        swait()
        root.Velocity = root.CFrame.lookVector * 30
        BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-110*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(27), math.rad(0), math.rad(74)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-34-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      
      
      
    end
     so("http://www.roblox.com/asset/?id=197161452", char, 0.5, 0.8)
    con5:disconnect()
     
     
  end -- combo hit end
            attack = false
          ultra = false
  u:disconnect()
          
      end




-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 2
        hum.WalkSpeed = 24.82
	end
end)
mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 1
        hum.WalkSpeed = 8
	end
end)

 





mouse.Button1Down:connect(function()
 if attack==false then
                if attacktype==1 then
                        attack=true
                        attacktype=2
                        attackone()
                elseif attacktype==2 then
                        attack=true
                        attacktype=3
                        attacktwo()
                elseif attacktype==3 then
                        attack=true
                        attacktype=4
                        attackthree()
                elseif attacktype==4 then
                        attack=true
                        attacktype=1
                        attackfour()
                end
        end
end)




		  mouse.KeyDown:connect(function(key)
		if key == 'e' and attack == false and cankick == true and cooldown == false then
quickkick()
cooldown = true

coroutine.resume(coroutine.create(function()
    wait(2)
cooldown = false
end))



		end
		end)








mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 't' then
			Taunt()
		elseif key == 'f' then
			Hyperkickcombo()
					elseif key == 'r' then
			Galekicks()
		end
	end
end)

-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
print("By Makhail07 and KillerDarkness0105")
print("Basic Animations by Makhail07")
print("Attack Animations by KillerDarkness0105")
print("This is pretty much our final script together")
print("--------------------------------")
print("Attacks")
print("E in air: Quick Kicks")
print("Left Mouse: 4 click combo")
print("F: Hyper Kicks")
print("R: Gale Kicks, Spam R if your combo is over 150 to do an ultra combo")
print("--------------------------------")
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	
	if hitfloor == nil then
	    cankick = true
    else
        cankick = false
        end
	
	
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(20)), 0.1)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-6.5 * Sin(sine / 12)), Rad(0), Rad(-20)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(110), Rad(6 + 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.3* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(110), Rad(6 - 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
			end
		elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-1), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-15 - 15 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 15 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(56)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-56)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
			end
		elseif torvel >= 22 and hitfloor ~= nil then
			Anim = "Sprint"
			change = 1.35
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-8.5 - 2 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
			RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         	LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65) , Rad(0), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65)  , Rad(0) ,	Rad(-13) + la.RotVelocity.Y / 75), 0.15)
			end
		end
	end
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 0.7
	Music.Parent = tors
	Music:Resume()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end 
local basetpart = game.workspace.non:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end  
end





if string.sub(msg, 1, 7) == (prefix.."insane") then
       

Bypass = "death"
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
        sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
    end
end)

loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(5)


Ply = game.Players.LocalPlayer
--FIXED WITH TRIGECTORY's CheatSheet--
cheatsheetplr = game.Players.LocalPlayer
i = Instance.new("NumberValue", cheatsheetplr )
i.Name = "FPSCH"
Bin = Instance.new("HopperBin", cheatsheetplr .Backpack)
script.Parent = Bin
local cf = CFrame.new
local function Create(A)
local A = Instance.new(A)
return function(B)
for i,v in pairs(B) do
A[i] = v
end
return A
end
end
RW = Create("Weld")({Name = "Right Shoulder", Part0 = Tor, C0 = CFrame.new(1.5, 0.5, 0), C1 = CFrame.new(0, 0.5, 

0), Part1 = RA, Parent = Tor})
LW = Create("Weld")({Name = "Left Shoulder", Part0 = Tor, C0 = CFrame.new(-1.5, 0.5, 0), C1 = CFrame.new(0, 0.5, 

0), Part1 = LA, Parent = Tor})
wait(.05)
--Saz

debounce=true
etime=0
etimem=20
down=false

vPlayer=game.Players.LocalPlayer
cPlayer=nil
Humanoid=nil

Welds={}

stopVictoly=function()
	
	for _,v in pairs(Welds) do
		v.Parent = cPlayer.Torso
	end
	
	wait(.2)
	
	g1:Remove() g2:Remove() g3:Remove() g4:Remove() g5:Remove()
	
	b1:Remove() b2:Remove()
	
	p1:Remove() p2:Remove()
	
	bpos:Remove()
	brot:Remove()
	
	Head.Anchored=false
	
	Humanoid.PlatformStand=false
	
end
startVictoly=function()
	
	Welds={}

	cPlayer=workspace.non
	Humanoid = nil
	for _,v in pairs(cPlayer:children()) do
		if v.className=="Humanoid" then
			Humanoid=v
		end
		if v.Name=="Torso" then
			for __,vv in pairs(v:children()) do
				if vv:IsA("JointInstance") then
					table.insert(Welds,vv)
				end
			end
		end
	end
	
	Torso = cPlayer.Torso
	Head = cPlayer.Head
	RightArm = cPlayer["Right Arm"]
	LeftArm = cPlayer["Left Arm"]
	RightLeg = cPlayer["Right Leg"]
	LeftLeg = cPlayer["Left Leg"]
	
	Head.Anchored=true
	
	headpos = Head.CFrame.p
	
	print("noob")
	
	Humanoid.PlatformStand=true
	
	Torso.Anchored=true
	
	p1=Instance.new("Part",cPlayer)
	p1.Anchored=true
	p1.formFactor="Custom"
	p1.Size=Vector3.new(1,1,1)
	p1.TopSurface=0
	p1.BottomSurface=0
	p1.CanCollide=false
	p1.Name="AnchorR"
	p1.CFrame = Torso.CFrame * CFrame.new(.5,-3.5,0)
	p1.Transparency=1
	
	p2=Instance.new("Part",cPlayer)
	p2.Anchored=true
	p2.formFactor="Custom"
	p2.Size=Vector3.new(1,1,1)
	p2.TopSurface=0
	p2.BottomSurface=0
	p2.CanCollide=false
	p2.Name="AnchorL"
	p2.CFrame = Torso.CFrame * CFrame.new(-.5,-3.5,0)
	p2.Transparency=1
	
	g1=Instance.new("Glue",RightLeg)
	g1.Part0 = Torso
	g1.Part1 = RightLeg
	g1.C0 = CFrame.new(.5,-2,0)
	g1.C1 = CFrame.new(0,0,0)
	g1.F0 = Vector3.new(0,1,0)
	g1.F1 = Vector3.new(0,1,0)
	g1.F2 = Vector3.new(0,1,0)
	g1.F3 = Vector3.new(0,1,0)
	
	g2=Instance.new("Glue",p1)
	g2.Part0 = p1
	g2.Part1 = RightLeg
	g2.C0 = CFrame.new(0,1.5,0)
	g2.C1 = CFrame.new(0,0,0)
	g2.F0 = Vector3.new(.25,-1,.25)
	g2.F1 = Vector3.new(.25,-1,-.25)
	g2.F2 = Vector3.new(-.25,-1,.25)
	g2.F3 = Vector3.new(-.25,-1,-.25)
	
	g3=Instance.new("Glue",LeftLeg)
	g3.Part0 = Torso
	g3.Part1 = LeftLeg
	g3.C0 = CFrame.new(-.5,-2,0)
	g3.C1 = CFrame.new(0,0,0)
	g3.F0 = Vector3.new(0,1,0)
	g3.F1 = Vector3.new(0,1,0)
	g3.F2 = Vector3.new(0,1,0)
	g3.F3 = Vector3.new(0,1,0)
	
	g4=Instance.new("Glue",p2)
	g4.Part0 = p2
	g4.Part1 = LeftLeg
	g4.C0 = CFrame.new(0,1.5,0)
	g4.C1 = CFrame.new(0,0,0)
	g4.F0 = Vector3.new(.25,-1,.25)
	g4.F1 = Vector3.new(.25,-1,-.25)
	g4.F2 = Vector3.new(-.25,-1,.25)
	g4.F3 = Vector3.new(-.25,-1,-.25)
	
	g5=Instance.new("Glue",Torso)
	g5.Part0 = Head
	g5.Part1 = Torso
	g5.C0 = CFrame.new(0,0,0)
	g5.C1 = CFrame.new(0,1.5,0)
	g5.F0 = Vector3.new(0,0,0)
	g5.F1 = Vector3.new(0,0,0)
	g5.F2 = Vector3.new(0,0,0)
	g5.F3 = Vector3.new(0,0,0)
	
	for _,v in pairs(Welds) do
		if v.Name~="Neck" then
			print(v.Name)
			v.Parent = nil
			if v.Name=="Right Shoulder" then
				RSC0 = v.C0
				RSC1 = v.C1
			elseif v.Name=="Left Shoulder" then
				LSC0 = v.C0
				LSC1 = v.C1				
			end
		end
	end
	
	b1=Instance.new("Motor6D",RightArm)
	b1.Part0 = Torso
	b1.Part1 = RightArm
	b1.C0 = RSC0
	b1.C1 = RSC1 * CFrame.new(0,.25,0)
	
	b2=Instance.new("Motor6D",LeftArm)
	b2.Part0 = Torso
	b2.Part1 = LeftArm
	b2.C0 = LSC0
	b2.C1 = LSC1 * CFrame.new(0,.25,0)
	
	pos=Torso.Position
	brot=Instance.new("BodyAngularVelocity",Torso)
	brot.P=2250
	brot.maxTorque=Vector3.new(8000000,8000000,8000000)
	bpos=Instance.new("BodyPosition",Torso)
	bpos.P=4250
	bpos.D=150
	bpos.maxForce=Vector3.new(8000000000,0,8000000000)
	bpos.position=Torso.Position
	
	Torso.RotVelocity=Vector3.new()
	Torso.Velocity=Vector3.new()
	
	
	for i=1, 5 do
		for _,v in pairs(cPlayer:children()) do
			if v:IsA("BasePart") then
				v.Velocity=Vector3.new()
				v.RotVelocity=Vector3.new()
			end
		end
		wait(.05)
	end
	
	Torso.Neck.Parent=nil
	Torso.Anchored=false
	
	ex=0
	em = 0
	elo = 0
	
	local mus = Instance.new("Sound",Torso)
	mus.Volume = 1
	mus.SoundId="http://www.roblox.com/asset/?id=230597205"
	mus:Play()
	
	ded=false
	
	wait()
	
	li=Instance.new("PointLight",Torso)
	li.Range=25
	li.Brightness=5
	li.Shadows=true
	
	pos=Torso.CFrame
	
	while down do
		game:GetService("RunService").Heartbeat:wait()
		em = em+1
		elo = elo+1
		if em == 11 then
			brot.angularvelocity=Vector3.new(math.random(-26,26),math.random(-20,20)/6,math.random(-26,26)/2)
			bpos.position = (pos * CFrame.new(math.random(-20,20)/10,0,math.random(-20,20)/20)).p
			em = math.random(0,4)
			li.Color=Color3.new(math.random(100,255)/255,math.random(100,255)/255,math.random(100,255)/255)
		end
		
		b1.C0 = RSC0 * CFrame.new(math.cos(math.rad(elo*15))/20,.5,math.sin(math.rad(elo*15))/30) * CFrame.Angles(math.rad(ex/8)*elo - math.pi/3,math.cos(math.rad(elo*15))/100,math.sin(elo/8)*7)
		b2.C0 = LSC0 * CFrame.new(math.cos(math.rad(elo*15))/20,.5,math.sin(math.rad(elo*15))/30) * CFrame.Angles(math.rad(-ex/8)*elo - math.pi/3,math.sin(math.rad(elo*15))/100,-math.cos(elo/8)*7)
		
		ex = ex + math.random(-5,5)/5
		if ex > 50 then
			ex = 50
		elseif ex < 10 then
			ex = 20
		end
		
		if elo > 15 then
		
			if g1.Parent==nil or g2.Parent==nil or g3.Parent==nil or g4.Parent==nil or g5.Parent==nil or Humanoid.Health <= 0 then
				ded = true
				break
			end
			if g1.Part0==nil or g2.Part0==nil or g3.Part0==nil or g4.Part0==nil or g5.Part0==nil then
				ded = true
				break
			end
			if RightArm.Parent == nil or LeftArm.Parent == nil or LeftLeg.Parent==nil or RightLeg.Parent==nil then
				ded=true
				break
			end
		
		end
		
	end
	
	li:Remove()
	
	mus:Stop()
	
	if ded then
		Head.Anchored=false
		
		for _,v in pairs(cPlayer:children()) do
			if v:IsA("BasePart") then
				v:BreakJoints()
				v.CFrame = CFrame.new(Torso.Position + Vector3.new(math.random(-2,2),math.random(-1,2),math.random(-2,2))) * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				v.Velocity=Vector3.new(0,0,0)
			end
		end
		
		e=Instance.new("Explosion",workspace)
		e.BlastRadius=10
		e.BlastPressure=0
		e.Position=Torso.Position
		e.Hit:connect(function(hit) if hit.Parent == cPlayer and hit.Name~="AnchorR" and hit.Name~="AnchorL" then if hit:FindFirstChild("Fire") == nil then Instance.new("Fire",hit) end hit:BreakJoints() hit.Velocity = (e.Position - hit.Position).unit * 80 hit.RotVelocity = hit.Velocity end end)
		
		s=Instance.new("Sound",Head)
		s.SoundId="http://www.roblox.com/asset/?id=230597277"
		s.Volume=1
		s:Play()
		
		s=Instance.new("Sound",p1)
		s.SoundId="http://www.roblox.com/asset/?id=221920821"
		s.Volume=1
		s.Pitch=1.25
		s:Play()
	end
	
	wait(.5)
	mus:Remove()
	
end

onEquip=function(mouse)
	mouse.Button1Down:connect(function() down=true startVictoly() end)
	mouse.Button1Up:connect(function() down=false stopVictoly() end)
end
script.Parent.Selected:connect(onEquip)
local basetpart = game.Players.Character:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
  sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
  end

end




if string.sub(msg, 1, 7) == (prefix.."billie") then
       spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)

function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end


loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(1)

-- nebula's ezconvert
--[[
PUT YOUR SCRIPTS BELOW HERE VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV	
]]
local plr = game:GetService("Players").LocalPlayer
local char = workspace.non
if char:FindFirstChild("Animate") then
	char.Animate:Destroy()
end
local hum = char:FindFirstChildOfClass("Humanoid")
local tors = char.Torso
local head = char.Head
local rootpart = char.HumanoidRootPart
local RS = tors["Right Shoulder"]
local LS = tors["Left Shoulder"]
local RH = tors["Right Hip"]
local LH = tors["Left Hip"]
local neck = tors.Neck
local rootj = rootpart.RootJoint
local RSnor = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
local LSnor = CFrame.new(-1, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
local RHnor = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
local LHnor = CFrame.new(-1, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
local necknor = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local rootjnor = CFrame.new(0, 0, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local sine = 0
local music = Instance.new("Sound")
music.Parent = tors
local timepos = 0
local attack = false
local rooted = false
local playing = true
local speed = 16
local nokill = {
	"mrfunnylaughs4",
	"v_Sado"
}
local wig = Instance.new("Part")
wig.Size = Vector3.new(1.4, 1.99, 0.84)
wig.Parent = head
local mesh = Instance.new("SpecialMesh")
mesh.MeshType = Enum.MeshType.FileMesh
mesh.MeshId = "rbxassetid://952995462"
mesh.Scale = Vector3.new(1.44, 1.4, 1.22)
mesh.TextureId = "rbxassetid://949743130"
mesh.VertexColor = Vector3.new(1, 0.839, 0.73)
mesh.Parent = wig
local weld = Instance.new("Weld")
weld.Part0 = wig
weld.Part1 = head
weld.C1 = CFrame.new(0, -0.8, 0.25)
weld.Parent = wig
local rem = Instance.new("RemoteEvent")
rem.Name = "Events"
--[[
local Player = game:GetService("Players").LocalPlayer
    local Event = script:WaitForChild("UserInput_Event")
 
    local Mouse = Player:GetMouse()
    local UIS = game:GetService("UserInputService")
    local input = function(io,a)
        if a then return end
        --Since InputObject is a client-side instance, we create and pass table instead
        Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState,Hit=Mouse.Hit,Target=Mouse.Target})
    end
    UIS.InputBegan:Connect(input)
    UIS.InputEnded:Connect(input)
 
    local h,t
    --Give the server mouse data 30 times every second, but only if the values changed
    --If player is not moving their mouse, client won't fire events
    while wait(1/30) do
        if h~=Mouse.Hit or t~=Mouse.Target then
            h,t=Mouse.Hit,Mouse.Target
            Event:FireServer({isMouse=true,Target=t,Hit=h})
        end
    ]]--,plr.Character)	
rem.OnServerEvent:Connect(function(player, key)
	if player == plr then
		if attack == false then
			if key == "t" then
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://145757437"
				sound.Volume = 10
				sound.Parent = head
				local effect = Instance.new("PitchShiftSoundEffect")
				effect.Octave = 1.75
				effect.Parent = sound
				sound:Play()
				for i = 1, 120 do
					game:GetService("RunService").Stepped:Wait()
					head.Size = Vector3.new(2 + 1 * math.sin(sine / 5), 1 + 1 * math.sin(sine / 5), 1 + 1 * math.sin(sine / 5)) 
					neck.C0 = necknor * CFrame.new(0, 0, math.sin(sine / 5))
				end
				head.Size = Vector3.new(2, 1, 1)
			end
			if key == "r" then
				attack = true
				rooted = true
				playing = false
				local scream = Instance.new("Sound")
				scream.SoundId = "rbxassetid://176238381"
				scream.Parent = head
				scream:Play()
				repeat
					game:GetService("RunService").Stepped:Wait()
					RS.C0 = RSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					LS.C0 = LSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					RH.C0 = RHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					LH.C0 = LHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					rootj.C0 = rootjnor * CFrame.new(0, 0, 3 * math.sin(sine / 2)) * CFrame.Angles(sine / 2, 0, 0)
					neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
				until scream.Playing == false
				scream:Destroy()
				rooted = false
				if math.random(1, 3) == 1 then
					local sound = Instance.new("Sound")
					sound.SoundId = "rbxassetid://2878822762"
					sound.Volume = 10
					sound.PlaybackSpeed = 2
					sound.Parent = head
					sound:Play()
					repeat
						game:GetService("RunService").Stepped:Wait()
						head.Size = Vector3.new(2 + 1 * math.sin(sine / 2), 1 + 1 * math.sin(sine / 2), 1 + 1 * math.sin(sine / 2)) 
						RS.C0 = RSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						LS.C0 = LSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						RH.C0 = RHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						LH.C0 = LHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						rootj.C0 = rootjnor
						neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					until sound.Playing == false
					head.Size = Vector3.new(2, 1, 1)
				end
				playing = true
				attack = false
			end
			if key == "y" then
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://3475233802"
				sound.Volume = 10
				sound.Parent = head
				sound:Play()
				local thing = head.Touched:Connect(function(hit)
					local found = false
					for i,v in pairs(nokill) do
						if game:GetService("Players"):FindFirstChild(v) then
							if hit:IsDescendantOf(game:GetService("Players")[v].Character) then
								found = true
							end
						end
					end
					if found == false and hit.Size.Magnitude < 300 then
						local parent = hit.Parent
						hit.Parent = nil
						wait(math.random(20, 50) / 10)
						hit.Anchored = false
						hit.BrickColor = BrickColor.new("Bright green")
						hit.CFrame = head.CFrame
						hit.Velocity = head.CFrame.LookVector * 150
						hit.Parent = parent
						local sound = Instance.new("Sound")
						sound.SoundId = "rbxassetid://704088758"
						sound.Volume = 10
						sound.Parent = head
						sound:Play()
					end
				end)
				for i = 1, 180 do
					game:GetService("RunService").Stepped:Wait()
					head.Size = Vector3.new(20, 10, 10)
					neck.C0 = necknor * CFrame.new(0, -10, 0)
				end
				thing:Disconnect()
				head.Size = Vector3.new(2, 1, 1)
			end
			if key == "p" then
				attack = true
				playing = false
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://2533880583"
				sound.Volume = 3
				sound.TimePosition = 20.15
				sound.Parent = head
				sound:Play()
				wig.Parent = nil
				local hat = Instance.new("Part")
				hat.Name = "JevilHat"
				hat.CanCollide = false
				hat.Size = Vector3.new(1, 1, 1)
				hat.Parent = char
				local mesh = Instance.new("SpecialMesh")
				mesh.MeshType = Enum.MeshType.FileMesh
				mesh.MeshId = "rbxassetid://193760002"
				mesh.TextureId = "rbxassetid://193760041"
				mesh.VertexColor = Vector3.new(0.5, 0, 0.5)
				mesh.Parent = hat
				local weld = Instance.new("Weld")
				weld.Part0 = head
				weld.Part1 = hat
				weld.C0 = CFrame.new(0, 0.5, 0.31)
				weld.Parent = hat
				for i,v in pairs(head:GetChildren()) do
					if v:IsA("Decal") then
						local old = v.Texture
						v.Texture = "rbxassetid://241553801"
						coroutine.resume(coroutine.create(function()
							repeat game:GetService("RunService").Stepped:Wait() until sound.Playing == false or sound.TimePosition > 30.35
							v.Texture = old
						end))
					end
				end
				local anything = Instance.new("Sound")
				anything.SoundId = "rbxassetid://2544975373"
				anything.Volume = 10
				anything.Parent = head
				anything:Play()
				speed = 50
				repeat
					game:GetService("RunService").Stepped:Wait()
					RS.C0 = RSnor * CFrame.Angles(0, 0, math.pi / 2 - 1 * math.sin(sine / 3))
					LS.C0 = LSnor * CFrame.Angles(0, 0, -math.pi / 2 + 1 * math.sin(sine / 3))
					RH.C0 = RHnor
					LH.C0 = LHnor
					rootj.C0 = rootjnor
					neck.C0 = necknor
				until sound.Playing == false or sound.TimePosition > 30.35
				speed = 16
				hat:Destroy()
				wig.Parent = head
				sound:Destroy()
				playing = true
				attack = false
			end
			if key == "f" then
				attack = true
				playing = false
				speed = 150
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://2259766079"
				sound.Volume = 10
				sound.Parent = head
				sound:Play()
				local timepos = 0
				local thing = 1
				repeat
					game:GetService("RunService").Stepped:Wait()
					if sound.Parent ~= head then
						local sound = Instance.new("Sound")
						sound.TimePosition = timepos
						sound.Parent = head
					end
					sound.Volume = 10
					sound.PlaybackSpeed = 1
					sound.Playing = true
					timepos = sound.TimePosition
					RS.C0 = RSnor * CFrame.Angles(0, 0, math.pi / 2 - 1 * math.sin(sine / (15 / thing)))
					LS.C0 = LSnor * CFrame.Angles(0, 0, -math.pi / 2 + 1 * math.sin(sine / (15 / thing)))
					RH.C0 = RHnor
					LH.C0 = LHnor
					rootj.C0 = rootjnor
					neck.C0 = necknor
					thing = thing + 0.005
				until sound.Playing == false or sound.TimePosition > 10
				local old = head.BrickColor
				repeat
					game:GetService("RunService").Stepped:Wait()
					if sound.TimePosition > 20 then
						head.BrickColor = BrickColor.new("Sunrise")
					end
					sound.PlaybackSpeed = sound.PlaybackSpeed + 0.001
					head.Size = head.Size + Vector3.new(0.01, 0.01, 0.01)
					neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
				until sound.Playing == false
				for i = 1, 20 do
					local clone = head:Clone()
					clone.Parent = workspace
					clone.Velocity = Vector3.new(0, 200, 0)
					local sound = Instance.new("Sound")
					sound.SoundId = "rbxassetid://2878822762"
					sound.Volume = 0.5
					sound.Parent = head
					sound:Play()
				end
				head.Size = Vector3.new(2, 1, 1)
				head.BrickColor = old
				speed = 16
				playing = true
				attack = false
			end
			if key == "u" then
				local part = Instance.new("Part")
				part.CFrame = rootpart.CFrame * CFrame.new(0, 0, 5)
				part.Size = Vector3.new(3, 4, 3)
				part.Parent = workspace
				local click = Instance.new("ClickDetector")
				click.Parent = part
				local mesh = Instance.new("SpecialMesh")
				mesh.MeshType = Enum.MeshType.FileMesh
				mesh.MeshId = "rbxassetid://430897733"
				mesh.Scale = Vector3.new(4, 4, 4)
				mesh.TextureId = "rbxassetid://430897961"
				mesh.Parent = part
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://741801027"
				sound.Volume = 3
				sound.Parent = part
				sound:Play()
				click.MouseClick:Connect(function()
					local banana = Instance.new("Part")
					banana.Size = Vector3.new(1, 1, 1)
					banana.CFrame = part.CFrame * CFrame.new(0, 5, 0)
					banana.Velocity = Vector3.new(math.random(-25, 25), 200, math.random(-25, 25))
					banana.Parent = workspace
					local mesh = Instance.new("SpecialMesh")
					mesh.MeshType = Enum.MeshType.FileMesh
					mesh.MeshId = "rbxassetid://28937301"
					mesh.TextureId = "rbxassetid://28937670"
					mesh.Scale = Vector3.new(0.8, 0.8, 0.8)
					mesh.Parent = banana
					local sound = Instance.new("Sound")
					sound.SoundId = "rbxassetid://28976727"
					sound.Volume = 2
					sound.Parent = banana
					sound:Play()
					local touched = false
					banana.Touched:Connect(function(hit)
						if hit.Parent and hit.Parent:FindFirstChild("Head") and not hit:IsDescendantOf(char) and touched == false then
							touched = true
							coroutine.resume(coroutine.create(function()
								for i = 1, 60 do
									game:GetService("RunService").Stepped:Wait()
									mesh.Scale = mesh.Scale + Vector3.new(0.3, 0.3, 0.3)
									banana.Size = banana.Size + Vector3.new(0.3, 0.3, 0.3)
								end
								banana:Destroy()
							end))
							local sound = Instance.new("Sound")
							sound.SoundId = "rbxassetid://168411776"
							sound.Volume = 10
							sound.Parent = hit.Parent.Head
							sound:Play()
						end
					end)
				end)
				repeat game:GetService("RunService").Stepped:Wait() until sound.Playing == false
				part:Destroy()
			end
		end
	end
end)
while game:GetService("RunService").Stepped:Wait() do
	sine = sine + 1
	if attack then 
		if rooted then
			hum.WalkSpeed = 0
			hum.JumpPower = 0
		else
			hum.WalkSpeed = speed
			hum.JumpPower = 50
		end
	else
		hum.WalkSpeed = 16
		hum.JumpPower = 50
	end
	for i,v in pairs(char:GetChildren()) do
		if v:IsA("Accessory") then
			v:Destroy()
		end
	end
	if music.Parent ~= tors then
		music = Instance.new("Sound")
		music.Parent = tors
		music.TimePosition = timepos
	else
		timepos = music.TimePosition
	end
	music.PlaybackSpeed = 0.84
	music.Volume = 1
	music.SoundId = "rbxassetid://3015811673"
	music.Playing = playing
	local torsvel = (tors.Velocity * Vector3.new(1, 0, 1)).Magnitude
	local hitfloor = workspace:FindPartOnRay(Ray.new(char.HumanoidRootPart.CFrame.Position, ((CFrame.new(char.HumanoidRootPart.Position, char.HumanoidRootPart.Position - Vector3.new(0, 1, 0))).LookVector).Unit * 4), char)
	if attack == false then
		if torsvel < 1 and hitfloor then
			RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(0, 0, math.pi / 2 + 0.3 * math.cos(sine / 7) + 0.5 * math.sin(sine / 14)), 0.15)
			LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(0, 0, 0.5 + 0.2 * math.sin(sine / 7) + 0.15 * math.cos(sine / 14)), 0.15)
			RH.C0 = RH.C0:Lerp(RHnor * CFrame.Angles(0, 0, -0.5 + 1 * math.sin(sine / 14) - 0.5 * math.cos(sine / 28)), 0.15)
			LH.C0 = LH.C0:Lerp(LHnor * CFrame.new(0.1 * math.sin(sine / 3.5) + 0.2 * math.cos(sine / 14), 0, 0) * CFrame.Angles(0, 0.2 * math.cos(sine / 28) - 0.3 * math.sin(sine / 48) + 0.15 * math.cos(sine / 3.5) - 0.25 * math.sin(sine / 3.5), -0.1 * math.sin(sine / 3.5) - 0.2 * math.cos(sine / 14)), 0.15)
			rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.new(0, 0, 0.3 * math.cos(sine / 4.5)), 0.15)
			neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(math.sin(sine / 10), math.cos(sine / 10), 0), 0.15)
		end
		if torsvel > 1 and hitfloor then
			RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(0, sine / 5, -1 * math.sin(sine / 7)), 0.15)
			LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(0, sine / 5, -1 * math.sin(sine / 7)), 0.15)
			RH.C0 = RH.C0:Lerp(RHnor * CFrame.new(1 * math.cos(sine / 7), 0.15 + 0.5 * math.cos(sine / 7), 0) * CFrame.Angles(0, 0.3 * math.sin(sine / 7), -0.23 + 1 * math.sin(sine / 7)), 0.15)
			LH.C0 = LH.C0:Lerp(LHnor * CFrame.new(1 * math.cos(sine / 7), 0.15 - 0.5 * math.cos(sine / 7), 0) * CFrame.Angles(0, 0.3 * math.sin(sine / 7), 0.23 + 1 * math.sin(sine / 7)), 0.15)
			rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.new(0, 0, -0.1 + 0.2 * math.cos(sine / 3.5)) * CFrame.Angles(0.2 - 0.4 * math.sin(sine / 3.5), rootpart.RotVelocity.Y / 50, -0.3 * math.sin(sine / 7)), 0.15)
			neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(0.4 * math.sin(sine / 3.5), 0, -head.RotVelocity.Y / 15 + 0.3 * math.sin(sine / 7)), 0.15)
		end
		if not hitfloor then
			RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(math.clamp(tors.Velocity.Y / 200 - 0.3, -hum.JumpPower / 200 - 0.3, hum.JumpPower / 200 - 0.3), 0, math.pi / 1.5), 0.15)
			LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(math.clamp(tors.Velocity.Y / 200 - 0.3, -hum.JumpPower / 200 - 0.3, hum.JumpPower / 200 - 0.3), 0, -math.pi / 1.5), 0.15)
			RH.C0 = RH.C0:Lerp(RHnor + Vector3.new(0, -0.6, 0.4), 0.15)
			LH.C0 = LH.C0:Lerp(LHnor * CFrame.Angles(0, 0, -0.3) + Vector3.new(0, -0.1, 0), 0.15)
			rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.Angles(-math.clamp(tors.Velocity.Y / 100, -hum.JumpPower / 100, hum.JumpPower / 100), 0, 0), 0.15)
			neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(math.random(-100, 100) / 1000, math.random(-100, 100) / 1000, math.random(-100, 100) / 1000), 0.15)
		end
	end
end

end

if string.sub(msg, 1, 4) == (prefix.."rpg") then
    
--//====================================================\\--
--||                       BASIS
--\\====================================================//--


 sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
       --sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


local rpg = game.Players.LocalPlayer.Character["Back Attack Missle Launcher"].Handle
rpg.AccessoryWeld:Destroy()



local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = rpg
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true


attachment0.CFrame = CFrame.new(1.8,.5,-.3)
attachment1.CFrame = CFrame.Angles(.4,5,20) 

loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(1)




local MODULE = script
local CHARACTER = workspace.non
local PLAYER = game:GetService("Players"):GetPlayerFromCharacter(CHARACTER)
local HUM = CHARACTER.Humanoid
--local REMOTE = MODULE.Event
local ROOT = HUM.Torso
local HEAD = CHARACTER.Head
local TORSO = CHARACTER.Torso
local RIGHTARM = CHARACTER["Right Arm"]
local LEFTARM = CHARACTER["Left Arm"]
local RIGHTLEG = CHARACTER["Right Leg"]
local LEFTLEG = CHARACTER["Left Leg"]
local ROOTJOINT = ROOT["RootJoint"]
local NECK = TORSO["Neck"]
local RIGHTSHOULDER = TORSO["Right Shoulder"]
local LEFTSHOULDER = TORSO["Left Shoulder"]
local RIGHTHIP = TORSO["Right Hip"]
local LEFTHIP = TORSO["Left Hip"]
local MOUSEPOS = ROOT.Position
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor


--//====================================================\\--
--||                  BACKGROUND VALUES
--\\====================================================//--
local ANIM_SPEED = 3
local MOUSE = game.Players.LocalPlayer:GetMouse()
local Mouse = game.Players.LocalPlayer:GetMouse()
local MOUSEPOS = Mouse.Hit.p
local FRAME_SPEED = 1 / 60 -- (1 / 30) OR (1 / 60)
local CHANGE = 2 / ANIM_SPEED
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local KEYHOLD = false
local MOUSEHOLD = false
local SINE = 0
local ATTACKING = false
local Debris = game:GetService("Debris")
local Effects = IT("Folder",CHARACTER)
Effects.Name = "FXFolder"
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local BGM = 213546066
local BOMB = 2671146857
local STORED = 9999999999999
--//====================================================\\--
--||                     HEARTBEAT
--\\====================================================//--
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = FRAME_SPEED
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end
--//====================================================\\--
--||                       CLERP
--\\====================================================//--
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
--//====================================================\\--
--||                     FUNCTIONS
--\\====================================================//--
function WeldParts(A,B)
	local WLD = IT("ManualWeld")
	WLD.Part0 = A
	WLD.Part1 = B
	WLD.C1 = B.CFrame:inverse() * A.CFrame
	WLD.Parent = A
	return WLD
end
--NewSound({ID = 0,PARENT = ROOT,VOLUME = 0.5,PITCH = 1,LOOP = false,MAXDISTANCE = 1000,EMITTERSIZE = 10,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
function NewSound(TABLE)
	local ID = "rbxassetid://"..(TABLE.ID or 0)
	local PARENT = (TABLE.PARENT or ROOT)
	local VOLUME = (TABLE.VOLUME or 0.5)
	local PITCH = (TABLE.PITCH or 1)
	local LOOP = (TABLE.LOOP or false)
	local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
	local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
	local PLAYING = (TABLE.PLAYING or true)
	local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
	local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
	if ID ~= "rbxassetid://0" then
		local SOUND = IT("Sound",PARENT)
		SOUND.SoundId = ID
		SOUND.Volume = VOLUME
		SOUND.Pitch = PITCH
		SOUND.Looped = LOOP
		SOUND.MaxDistance = MAXDISTANCE
		SOUND.EmitterSize = EMITTERSIZE
		SOUND.PlayOnRemove = PLAYONREMOVE
		if DOESDEBRIS == true and PLAYING == true and LOOP == false then
			Debris:AddItem(SOUND,SOUND.TimeLength+5)
		end
		if PLAYING == true then
			SOUND:Play()
		end
		return SOUND
	end
end
function ManSlaughter(MAN)
	if MAN then
		local ROOT = MAN:FindFirstChild("HumanoidRootPart")
		if ROOT then
			ROOT:Remove()
		end
		local MANHUM = MAN:FindFirstChildOfClass("Humanoid")
		if MANHUM then
			MANHUM.BreakJointsOnDeath = false
			MANHUM.Health = 0
		end
		if MAN:FindFirstChild("R6Ragdoll") == nil and MAN:FindFirstChild("R15Ragdoll") == nil then
			if MAN:FindFirstChild("UpperTorso") then
				local SCRIPT = script.R15Ragdoll:Clone()
				SCRIPT.Parent = MAN
				SCRIPT.Disabled = false
			else
				local SCRIPT = script.R6Ragdoll:Clone()
				SCRIPT.Parent = MAN
				SCRIPT.Disabled = false
			end
			local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
			if TORSO then
				NewSound({ID = 146594648,PARENT = TORSO,VOLUME = 1,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 75,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
			end
		end
		MAN:BreakJoints()
		if MAN:FindFirstChild("Slaughtered") == nil then
			local MARK = IT("Folder",MAN)
			MARK.Name = "Slaughtered"
		else
			if MAN:FindFirstChild("Slaughtered") then
				local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
				if TORSO then
					TORSO.RotVelocity = VT(0,MRANDOM(-25,25),0)
				end
			end
		end
	end
end
function AreaOfEffect(AREA,RANGE,FLING,RETURN)
	local HIT = {}
	for index, CHILD in pairs(workspace:GetChildren()) do
		if CHILD:FindFirstChildOfClass("Humanoid") then
			local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
			local ROOT = HUMAN.Torso
			if ROOT then
				if (ROOT.Position - AREA).Magnitude <= RANGE then
					if RETURN == true then
						if CHILD ~= CHARACTER then
							table.insert(HIT,{CHILD,HUMAN,ROOT})
						end
					else
						if CHILD ~= CHARACTER then
							ManSlaughter(CHILD)
						end
						local BV = IT("BodyVelocity")
						BV.MaxForce = BV.MaxForce * 500
						BV.Velocity = CF(AREA,ROOT.Position+VT(0,0.5,0)).lookVector*FLING
						BV.Parent = ROOT
						Debris:AddItem(BV,0.05)
					end
				end
			end
		end
	end
	if RETURN == true then
		return HIT
	end
end
function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = ROOT.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end
function CameraShake(AREA,RANGE,SHAKE,TIMER)
	for index, CHILD in pairs(workspace:GetChildren()) do
		if CHILD:FindFirstChildOfClass("Humanoid") then
			local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
			local ROOT = HUMAN.Torso
			if ROOT and game.Players:GetPlayerFromCharacter(CHILD) then
				if (ROOT.Position - AREA).Magnitude <= RANGE then
					if CHILD:FindFirstChild("CamShake") then
						Debris:AddItem(CHILD:FindFirstChild("CamShake"),0.05)
					end
					local CAMSHAKE = script.CamShake:Clone()
					CAMSHAKE.Parent = CHILD
					local TIMER_V = IT("NumberValue",CAMSHAKE)
					TIMER_V.Name = "Timer"
					TIMER_V.Value = TIMER
					local SHAKE_V = IT("NumberValue",CAMSHAKE)
					SHAKE_V.Name = "Shake"
					SHAKE_V.Value = SHAKE
					CAMSHAKE.Disabled = false
					Debris:AddItem(CAMSHAKE,15)
				end
			end
		end
	end
end
--//====================================================\\--
--||                     CHARACTER
--\\====================================================//--

for index, CHILD in pairs(CHARACTER:GetChildren()) do
	if CHILD ~= ROOT then
		if CHILD:IsA("Accessory") then
			CHILD:Remove()
		end
	end
end
local FACE = HEAD.face
FACE.Texture = "rbxassetid://559113097"
--HELMET.CFrame = HEAD.CFrame*CF(0,0.5,0)
--HELMET.Anchored = false
--WeldParts(HEAD,HELMET)
--local BAZOOKA = MODULE.Bazooka
--.Parent = CHARACTER
--BAZOOKA.Anchored = false
--local GRIP = IT("Motor6D")
--GRIP.Part0 = RIGHTARM
--GRIP.Part1 = BAZOOKA
--GRIP.C0 = CF(0,-1,-0.5)*ANGLES(RAD(-90),0,0)*CF(0,0,1.85)
--local G_C0 = GRIP.C0
--GRIP.Parent = RIGHTARM
for i = 1, 15 do
	local FACE = CreatePart(3, CHARACTER, "Fabric", 0, 0+(i-1)/15.2, "Dark stone grey", "FaceGradient", VT(1.01,0.58,1.01),false)
	FACE.Color = C3(0,0,0)
	HEAD:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
	FACE.CFrame = HEAD.CFrame*CF(0,0.3-(i-1)/35,0)
	WeldParts(HEAD,FACE)
end
--local MISSILE = MODULE.Missile
--MISSILE.Parent = nil

--//====================================================\\--
--||                     ABILITIES
--\\====================================================//--
function Fire_in_the_hole()
	if STORED > 0 then
		ATTACKING = true
		local GYRO = IT("BodyGyro")
		GYRO.D = 50
		GYRO.P = 5000
		GYRO.MaxTorque = VT(0,4000000,0)
		GYRO.CFrame = CF(ROOT.Position,Mouse.Hit.p)
		GYRO.Parent = ROOT
		ATTACKING = true
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				GYRO.CFrame = CF(ROOT.Position,Mouse.Hit.p)
			until ATTACKING == false
			GYRO:Remove()
		end))
		repeat
			for i=0, 0.06, 0.1 / ANIM_SPEED do
				Swait()
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
			end
		--	AddTo(-1)
			coroutine.resume(coroutine.create(function()
				local GOTO = Mouse.Hit.p
				local ROCKET = MISSILE:Clone()
				ROCKET.Parent = Effects
				ROCKET.CFrame = CF(BAZOOKA.CFrame*CF(0,0,-2).p,GOTO)
				NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				NewSound({ID = 440145223,PARENT = ROCKET,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for i = 1, 200 do
					Swait()
					local HIT,POS = Raycast(ROCKET.Position,ROCKET.CFrame.lookVector,5,CHARACTER)
					if HIT then
						ROCKET.CFrame = CF(POS)
						break
					end
					ROCKET.CFrame = ROCKET.CFrame*CF(0,0,-4)
				end
				ROCKET.Transparency = 1
				ROCKET.Hind:Remove()
				ROCKET.CFrame = CF(ROCKET.Position)
				ROCKET.Size = VT(0,0,0)
				NewSound({ID = 142070127,PARENT = ROCKET,VOLUME = 7,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 300,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for index, CHILD in pairs(script.Grenade:GetChildren()) do
					local C = CHILD:Clone()
					C.Parent = ROCKET
					C:Emit(125)
				end
				CameraShake(ROCKET.Position,50,125,70)
				AreaOfEffect(ROCKET.Position,35,200,false)
				Debris:AddItem(ROCKET,2)
			end))
			for i=0, 0.025, 0.1 / ANIM_SPEED do
				Swait()
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(200), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
			end
		until MOUSEHOLD == false or STORED <= 0
		if STORED <= 0 then
			STORED = 0
			STOREDGUI.Text = "STORED: 0"
		end
		ATTACKING = false
	end
end
function Store()
	HUM.WalkSpeed = 0
	HUM.JumpPower = 0
	ATTACKING = true
	repeat
		for i=0, 0.01, 0.1 / ANIM_SPEED do
			Swait()
	--		GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
	
		for i=0, 0.02, 0.1 / ANIM_SPEED do
			Swait()
		--	GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.675, 0.45, 0.3) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
		for i=0, 0.02, 0.1 / ANIM_SPEED do
			Swait()
		--	GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
		NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 1,PITCH = MRANDOM(9,11)/6,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		for i=0, 0.05, 0.1 / ANIM_SPEED do
			Swait()
		--	GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.75, 0.45, -0.1) * ANGLES(RAD(45), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-0.9, 0.5, -0.75) * ANGLES(RAD(60), RAD(0), RAD(37.5)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
		end
	--	ROCKET:Remove()
	--	BAZOOKA.Face.Pop:Emit(5)
	--	AddTo(1)
	until KEYHOLD == false
	ATTACKING = false
	HUM.WalkSpeed = 100
	HUM.JumpPower = 50
end
function Dance()
	HUM.WalkSpeed = 0
	HUM.JumpPower = 0
	ATTACKING = true
	local REMOVETRACK = false
	local TRACK = nil
	if ROOT:FindFirstChild("BGM_MUSIC") then
		TRACK = ROOT:FindFirstChild("BGM_MUSIC")
		TRACK.Volume = 5
	else
		TRACK = NewSound({ID = BOMB,PARENT = ROOT,VOLUME = 5,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		REMOVETRACK = true
	end
	TRACK.SoundId = "rbxassetid://"..BOMB
	TRACK:Play()
	local DONEWITHDANCING = false
	local NC = mouse.KeyDown:connect(function(key)
		key=key:lower()
		local V2 = key
		if V2 == "m" then
			DONEWITHDANCING = true
			ATTACKING = false
			if REMOVETRACK == true then
				TRACK:Remove()
			else
				TRACK:Play()
				TRACK.Volume = 1.25
				TRACK.SoundId = "rbxassetid://"..BGM
			end
		end
	end)
	local I = 0
	local RAVE = IT("PointLight",ROOT)
	RAVE.Brightness = 25
	RAVE.Color = BrickColor.random().Color
	repeat
		I = I + 2
		Swait()
		RAVE.Color = BrickColor.random().Color
		ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0 - 0.32 * SIN(I / 10), 0, -0.55 - 0.05 * COS(I / 5)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
		NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
		RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(170), RAD(10), RAD(-35 * COS(I/10)))  *CF(0,-1,0) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
		LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(170), RAD(-10), RAD(-35 * COS(I/10))) * CF(0,-1,0) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
		RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1.35, -0.475 + 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-12 - 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
		LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.35, -0.475 - 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-12 + 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
	until DONEWITHDANCING == true
	RAVE:Remove()
	NC:Disconnect()
	if REMOVETRACK == true then
		TRACK:Remove()
	else
		TRACK:Play()
		TRACK.Volume = 1.25
		TRACK.SoundId = "rbxassetid://"..BGM
	end
	ATTACKING = false
	HUM.WalkSpeed = 100
	HUM.JumpPower = 50
end
--//====================================================\\--
--||                       WRAP
--\\====================================================//--
game.Players.LocalPlayer:GetMouse().Button1Down:connect(function()
	MOUSEHOLD = true
	if ATTACKING == false then
		Fire_in_the_hole()
	end
end)
game.Players.LocalPlayer:GetMouse().Button1Up:connect(function()
	MOUSEHOLD = false
end)
game.Players.LocalPlayer:GetMouse().KeyDown:connect(function(key)
	key=key:lower()
	local V2 = key
	KEYHOLD = true
				if V2 == "z" then
					Store()
				elseif V2 == "m" then
					Dance()
				elseif V2 == "t" then
					NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				elseif V2 == "e" then
					if ROOT:FindFirstChild("BGM_MUSIC") then
						ROOT:FindFirstChild("BGM_MUSIC"):Remove()
					else
						local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						M.Name = "BGM_MUSIC"
					end
				end
end)
game.Players.LocalPlayer:GetMouse().KeyUp:connect(function()
	KEYHOLD = false
end)
--[[
REMOTE.OnServerEvent:Connect(function(PLR,V1,V2)
	if PLR == PLAYER and ANIM ~= "Sit" then
		--if V1 == "MousePositionUpdate" then
			--MOUSEPOS = V2
		if V1 == "KeyUp" then
			KEYHOLD = false
		elseif V1 == "MouseUp" then
			MOUSEHOLD = false
		end
		if ATTACKING == false then
			if V1 == "MouseDown" then
				MOUSEHOLD = true
				Fire_in_the_hole()
			elseif V1 == "KeyDown" then
				KEYHOLD = true
				if V2 == "z" then
					Store()
				elseif V2 == "m" then
					Dance()
				elseif V2 == "t" then
					NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				elseif V2 == "e" then
					if ROOT:FindFirstChild("BGM_MUSIC") then
						ROOT:FindFirstChild("BGM_MUSIC"):Remove()
					else
						local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						M.Name = "BGM_MUSIC"
					end
				end
			end
		end
	end
end)
]]--
local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
M.Name = "BGM_MUSIC"
HUM.WalkSpeed = 100
while true do
	Swait()
	local MOUSEPOS = Mouse.Hit.p
	SINE = SINE + CHANGE
	if CHARACTER:FindFirstChild("Animate") then
		CHARACTER:FindFirstChild("Animate"):Destroy()
	end
	if CHARACTER:FindFirstChild("Sound") then
		CHARACTER:FindFirstChild("Sound"):Destroy()
	end
	for _,v in next, HUM:GetPlayingAnimationTracks() do
		v:Stop();
	end
	local TORSOVELOCITY = (ROOT.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = ROOT.Velocity.y
	local HITFLOOR = Raycast(ROOT.Position, (CF(ROOT.Position, ROOT.Position + VT(0, -1, 0))).lookVector, 4+HUM.HipHeight, CHARACTER)
	local WALKSPEEDVALUE = 0.5
	local SITTING = HUM.Sit
	if ANIM == "Walk" and TORSOVELOCITY > 1 and SITTING == false then
		RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 0.875 - 0.3 * SIN(SINE / WALKSPEEDVALUE), -0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RIGHTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
		LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 0.875 + 0.3 * SIN(SINE / WALKSPEEDVALUE), 0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LEFTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) or SITTING == true then
		RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
		LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
	end
---	if ATTACKING == false then
--		GRIP.C0 = Clerp(GRIP.C0, G_C0, 1.5 / ANIM_SPEED)
--	end
	if SITTING == false then
		if HITFLOOR then
			if TORSOVELOCITY < 1 and HITFLOOR ~= nil then
				ANIM = "Idle"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 6)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(100), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25 - 2.5 * COS(SINE / 6))) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
				end
			elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
				ANIM = "Walk"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.05 + 0.05 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(135), RAD(0), RAD(5 + 2.5 * COS(SINE / WALKSPEEDVALUE))) * RIGHTSHOULDERC0, 2 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(0), RAD(-25 - 2.5 * COS(SINE / WALKSPEEDVALUE))) * LEFTSHOULDERC0, 2 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1 , -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-15)), 2 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(15)), 2 / ANIM_SPEED)
				end
			end
		else
			if TORSOVERTICALVELOCITY > 0 then
				ANIM = "Jump"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(10)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 1 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
			    end
			else
				ANIM = "Fall"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(150), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / ANIM_SPEED)
				end
			end
		end
	else
		ANIM = "Sit"
		if ATTACKING == false then
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.65, 0) * ANGLES(RAD(50), RAD(-10), RAD(45))*CF(0,-0.25,0) * LEFTSHOULDERC0, 1.25 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.25, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.25 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -0.25, -1) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1.25 / ANIM_SPEED)
		end
	end
end
local basetpart = game.workspace.non:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end

    
end

if string.sub(msg, 1, 7) == (prefix.."hammer") then
    			

Bypass = "death"
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)




local pee = game.Players.LocalPlayer.Character["MARTILLO"]
local gold = game.Players.LocalPlayer.Character["MARTILLO"].Handle
gold.AccessoryWeld:Destroy()




local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = gold
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true

attachment1.CFrame = CFrame.Angles(-25.7,5,20) 
  attachment0.CFrame = CFrame.new(1,-3,-.1)
  
  




  
  ----fling attachments
  
 
--  local toolgoflingfling = Instance.new("BodyVelocity", gold)
--toolgoflingfling.MaxForce = Vector3.new(90000,90000,90000)
--toolgoflingfling.Velocity = Vector3.new(90000,90000,90000)

  

wait(0.1)

warn([[Have fun with sangWARE!]])

--loadstring(game:GetObjects("rbxassetid://4480871791")[1].Source)()
--wait(5)

-- 5325226148
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(0.1)



playerss = workspace.non

local ToolName = pee

Bypass = "death"


local IsDead = false
local StateMover = true



Bypass = "death"
plr = game.Players.LocalPlayer
--dead = false
char = plr.Character




wait(4)




--



-- game:GetService("Workspace").GoldAxe.Handle.Rotation = Vector3.new(-0,0,-50)


 --local lol = Instance.new("Attachment",Right Arm)

--The reality of my life isn't real but a Universe -makhail07
wait()
local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name)
print('God Loaded')
print('hahahAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')
char = playerss
local hum = char.Humanoid
local hed = char.Head
local lol = Instance.new("Attachment",char["Right Arm"])
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")



function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end

function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end






-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end


function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end


local kan = Instance.new("Sound",char)
kan.Volume = 1.25
kan.TimePosition = 0
kan.PlaybackSpeed = 1
kan.Pitch = 1
kan.SoundId = "rbxassetid://853707984"
kan.Name = "wrecked"
kan.Looped = true
kan:Play()

local currentThemePlaying = kan.SoundId
local currentPitch = kan.Pitch
local currentVol = kan.Volume
function newTheme(ID,timepos,pitch,vol)
local kanz = kan
--kanz:Stop()
kanz.Volume = vol
--kanz.TimePosition = timepos
kanz.PlaybackSpeed = pitch
kanz.Pitch = pitch
kanz.SoundId = ID
kanz.Name = "wrecked"
kanz.Looped = true
currentThemePlaying = kanz.SoundId
currentVol = kanz.Volume
currentPitch = kanz.Pitch
--kanz:Play()
--coroutine.resume(coroutine.create(function()
--wait(0.05)
--end))
end

--newTheme("rbxassetid://853707984",0,1.01,0.85)

function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end


--local RbxUtility = LoadLibrary("RbxUtility")
--local Create = RbxUtility.Create

local function Create(A)
local A = Instance.new(A)
return function(B)
for i,v in pairs(B) do
A[i] = v
end
return A
end
end
-------------------------------------------------------
-----------------------hammer--------------------------
---- WEAPON OR STUFF
local rarmor = CreateParta(m,1,0,"SmoothPlastic",BrickColor.Random())
----local weaponweld = CreateWeld(rarmor,tors,rarmor,-3,0,-0.5,math.rad(0),math.rad(0),math.rad(-40),0,0,0,math.rad(0),math.rad(0),math.rad(0))
--local MainWeldS = CreateWeld(Part475,rarmor,Part475,0,0,0,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local A0 = Instance.new("Attachment",rarmor)
local A1 = Instance.new("Attachment",rarmor)
tl1 = Instance.new('Trail',rarmor)
tl1.Attachment0 = A0
tl1.Attachment1 = A1
tl1.LightEmission = 1
tl1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
tl1.Lifetime = 0.6
tl1.Enabled = false


rarmor.Attachment.Name = "Attachment2"


-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
    --    if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
 --       hit.Parent:FindFirstChild("Head"):BreakJoints()
  --     end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
   --     if insta == true then
--      hit.Parent:FindFirstChild("Head"):BreakJoints()
  --      end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:service("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end


function Eviscerate(dude)
	if dude.Name ~= char then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
	--	d//ude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
				end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
					v:Destroy()
				end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
					for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
							o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							v.Color = maincolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.08
								end
								wait(0.5)
								PartEmmit1.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
function chatfunc(text, color)
	local chat = coroutine.wrap(function()
		if char:FindFirstChild("TalkingBillBoard") ~= nil then
			char:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local naeeym2 = Instance.new("BillboardGui", char)
		naeeym2.Size = UDim2.new(0, 100, 0, 40)
		naeeym2.StudsOffset = Vector3.new(0, 5, 0)
		naeeym2.Adornee = hed
		naeeym2.Name = "TalkingBillBoard"
		local tecks2 = Instance.new("TextLabel", naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SciFi"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 0
		tecks2.TextColor3 = color
		tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
		tecks2.Size = UDim2.new(1, 0, 0.5, 0)
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
				tecks2.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
				tecks2.Rotation = math.random(-5, 5)
			end
		end))
		for i = 1, string.len(text) do
			CFuncs.Sound.Create("rbxassetid://274118116", hed, 5.25, 0.115)
			tecks2.Text = string.sub(text, 1, i)
			swait(1)
		end
		wait(1)
		naeeym2:Destroy()
	end)
	chat()
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 703597239
local SONG2 = 853707984
local Music = Instance.new("Sound",tors)
Music.Volume = 2.5
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
----------------------------------------------------------------------------------
hum.WalkSpeed = 16
hum.JumpPower = 57
hum.Animator.Parent = nil
----------------------------------------------------------------------------------
--local Blobby = Instance.new("Part", char)
--Blobby.Name = "Blob"
--Blobby.CanCollide = false
--Blobby.BrickColor = BrickColor.new("Really black")
--Blobby.Transparency = 0
--Blobby.Material = "Plastic"
--Blobby.Size = Vector3.new(1, 1, 2)
--Blobby.TopSurface = Enum.SurfaceType.Smooth
--Blobby.BottomSurface = Enum.SurfaceType.Smooth

--local Weld = Instance.new("Weld", Blobby)
--Weld.Part0 = ra
--Weld.Part1 = Blobby
--Weld.C1 = CFrame.new(0, -2, 1.1)
--Weld.C0 = CFrame.Angles(Rad(-86),0,0)

--local M2 = Instance.new("SpecialMesh")
--M2.Parent = Blobby
--M2.MeshId = "http://www.roblox.com/asset/?id=10604848"
--M2.TextureId = "http://www.roblox.com/asset/?id=10605252"
--M2.Scale = Vector3.new(1, 1, 1)

--[[local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0, 3.5, 0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"
--naeeym2.PlayerToHideFrom = Player
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Fight Me"
tecks2.Font = Enum.Font.Bodoni
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(0, 0, 0)
tecks2.TextStrokeColor3 = Color3.new(1, 1, 1)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2]]
-------------------------------------------------------
--End Customization--
-------------------------------------------------------


-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
function Ban()
	attack = true
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
 --	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 9.5)) do
--		if v:FindFirstChild("Head") then
--			Eviscerate(v)
--		end
--	end
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
	attack = false
end
function BigBan()
	attack = true
--	Weld.C0 = CFrame.Angles(Rad(-90), Rad(-25), Rad(0))
	for i = 0, 3.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-6), Rad(45)), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
 --	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 14.5)) do
--		if v:FindFirstChild("Head") then
--			Eviscerate(v)
---		end
--	end
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(75), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-6), Rad(45)), 0.2)
	end
--	Weld.C0 = CFrame.Angles(Rad(-86),0,0)
	attack = false
end
function BANN()
	attack = true
--	M2.Scale = Vector3.new(2, 2, 2)
	for i = 0, 4.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(-20)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(.6* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-.8* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(156), Rad(-.6), Rad(45)), 0.2)
	end
	Cso("147722910", char, 10, 1)
	CameraEnshaking(2, 35)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
	Effects.Ring.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0) * angles(math.rad(90), math.rad(0), math.rad(0)), 0.5, 0.5, 0.1, 2, 2, 0, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 7, 10, 15, -0.1, 15, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 6, 10, 15, -0.1, 15, 0.02)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 4, 10, 15, -0.1, 15, 0.01)
 --	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 19.5)) do
--		if v:FindFirstChild("Head") then
--			Eviscerate(v)
--		end
--	end
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
--	M2.Scale = Vector3.new(1, 1, 1)
	attack = false
end


-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------

game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(k)
   -- if string.byte(key) == 48 then
   Swing = 2
     hum.WalkSpeed = 38.82
--	end
end)
mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 1
        hum.WalkSpeed = 16
	end
end)
mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 'e' then
			BigBan()
		elseif key == 'r' then
			BANN()
		elseif key == 't' then
			Cso("1450018171", hed, 10, 1)
		end
	end
end)
mouse.Button1Down:connect(function(key)
    

    
    
	if attack == false then
		Ban()
	end
end)
 






-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		--Aura(5, 0.15, "Add", root.CFrame * CFrame.new(math.random(-5, 5), -10, math.random(-5, 5)) * CFrame.Angles(math.rad(90), 0, 0), 1.5, 1.5, 10, -0.015, maincolor, 0, "Sphere")
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(190), Rad(-.6), Rad(13)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel > 2 and torvel < 25 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(6 - 6.5 * Sin(sine / 7)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8* Player_Size - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8* Player_Size + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(190) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-37)  * Cos(sine / 7) , Rad(8 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
			end
		elseif torvel >= 25 and hitfloor ~= nil then
			Anim = "Sprint"
			change = 1.35
			if attack == false then
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
			RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925* Player_Size - 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         	LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925* Player_Size + 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(215) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-75) , Rad(8 * Cos(sine / 7)) ,	Rad(-13) + la.RotVelocity.Y / 75), 0.15)
			end
		end
	end
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 1.5
	Music.Parent = tors
	Music:Resume()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
    end

---open chat space

if string.sub(msg, 1, 8) == (prefix.."shotgun") then
    
--//====================================================\\--
--||			   CREATED BY SHACKLUSTER shotgun script
--\\====================================================//--
--repeat wait() until script:WaitForChild'Owner'.Value

wait(0.1)

Bypass = "death"
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
        sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
    end
end)




loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(1)


local shottie = workspace.non["Type-12Accessory"].Handle
shottie.AccessoryWeld:Destroy()
shottie.BodyBackAttachment:Destroy()


local righthandlo = workspace.non["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = shottie
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true


attachment0.CFrame = CFrame.new(0.3,1.9,-.1)
attachment1.CFrame = CFrame.Angles(4,1.7,-10) 
	
wait(0.2)
Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = workspace.non
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local MOUSEPOS = RootPart.Position
local TIME = 0
local sick = Instance.new("Sound",Torso)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 3
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Type = "Ban"
local reason = "Ur damn skids nigga"
local Rooted = false
local SINE = 0
local SIZE = 1
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "BanishV3Gui"
local Characterb = IT("Model")
Characterb.Name = "shackisgaylol"
local CharacterA = IT("Model")
CharacterA.Name = "shackismegagaylol"
local Effects = IT("Folder", CharacterA)
Effects.Name = "Effects"
local Effects2 = IT("Folder", Characterb)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true
local TOBANISH = {}
script.Parent = PlayerGui

--//=================================\\
--\\=================================//


--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

local BODY = {}
for _, c in pairs(Character:GetDescendants()) do
	if c:IsA("BasePart") and c.Name ~= "Handle" then
		if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency})
	elseif c:IsA("JointInstance") then
		table.insert(BODY,{c,c.Parent,nil,nil,nil})
	end
end
for e = 1, #BODY do
	if BODY[e] ~= nil then
		local STUFF = BODY[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
		if PART.ClassName == "Part" and PART ~= RootPart then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)
	end
end

function refit()
	Character.Parent = workspace
	for e = 1, #BODY do
		if BODY[e] ~= nil then
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART:IsA("BasePart") and PART ~= RootPart then
				PART.Material = MATERIAL
				PART.Color = COLOR
				PART.Transparency = TRANSPARENCY+EXTRATRANS
			end
			if PART.Parent ~= PARENT then
				Humanoid:remove()
				PART.Parent = PARENT
				Humanoid = IT("Humanoid",Character)
			end
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end


function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "White", "Trail", VT(0,0,0))
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(0.5,DIST,0.5)
	else
		TRAIL.Size = VT(0.25,DIST,0.25)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.1
		end
		TRAIL:remove()
	end))
end

function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MagicSphereCo(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MagicBlock(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "ForceField", 0, 0.5, BRICKC(COLOR), "Effect", VT(SIZE,SIZE,SIZE), true)
	local mesh = IT("BlockMesh",wave)
	wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function CreateRing(SIZE, DOESROT, ROT, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
	local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "559831844", "", SIZE, VT(0, 0, 0))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
			end
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

local DECAL = IT("Decal")
function MagicRing()
	local RING = CreatePart(3, Effects, "Granite", 0, 1, "Maroon", "MagicRing", VT(0,0,0),true)
	local MESH = IT("BlockMesh",RING)
	local BOTTOMTEXTURE = DECAL:Clone()
	BOTTOMTEXTURE.Parent = RING
	BOTTOMTEXTURE.Face = "Bottom"
	BOTTOMTEXTURE.Name = "BottomTexture"
	local TOPTEXTURE = DECAL:Clone()
	TOPTEXTURE.Parent = RING
	TOPTEXTURE.Face = "Top"
	TOPTEXTURE.Name = "TopTexture"
	BOTTOMTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	TOPTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	BOTTOMTEXTURE.Color3 = C3(0,0,0)
	TOPTEXTURE.Color3 = C3(1,1,1)
	return RING,MESH,TOPTEXTURE,BOTTOMTEXTURE
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

--function SHAKECAM(POSITION, RANGE, INTENSITY, TIME)
--	local CHILDREN = workspace:GetDescendants()
--	for index, CHILD in pairs(CHILDREN) do
--		if CHILD.ClassName == "Model" then
	--		local HUM = CHILD:FindFirstChildOfClass("Humanoid")
		--	if HUM then
		--		local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
			--	if TORSO and RANGE >= (TORSO.Position - POSITION).Magnitude then
				--	local CAMSHAKER = script.CamShake:Clone()
				--	CAMSHAKER.Shake.Value = INTENSITY
				---	CAMSHAKER.Timer.Value = TIME
				--	CAMSHAKER.Parent = CHILD
				--	CAMSHAKER.Disabled = false
			--	end
	--		end
	--	end
--	end
--nd

--//=================================\\
--||	     WEAPON CREATION
--\\=================================//

--local Shotgun = script.Shotgun:Clone()
--Shotgun.Parent = RightArm
--CreateWeld(Shotgun.Handle,RightArm,Shotgun.Handle,0.2,-0.1,0.5,math.rad(90),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local Hole = shottie

local Particle = IT("ParticleEmitter",nil)
Particle.Enabled = false
Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
Particle.LightEmission = 0.5
Particle.Rate = 150
Particle.ZOffset = 0.2
Particle.Rotation = NumberRange.new(-180, 180)
Particle.RotSpeed = NumberRange.new(-180, 180)
Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
Particle.Color = ColorSequence.new(C3(0,1,0),C3(0,1.1,0))

--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
function ParticleEmitter(Table)
	local PRTCL = Particle:Clone()
	local Speed = Table.Speed or 5
	local Drag = Table.Drag or 0
	local Size1 = Table.Size1 or 1
	local Size2 = Table.Size2 or 5
	local Lifetime1 = Table.Lifetime1 or 1
	local Lifetime2 = Table.Lifetime2 or 1.5
	local Parent = Table.Parent or Torso
	local Emit = Table.Emit or 100
	local Offset = Table.Offset or 360
	local Acel = Table.Acel or VT(0,0,0)
	local Enabled = Table.Enabled or false
	PRTCL.Parent = Parent
	PRTCL.Size = NumberSequence.new(Size1,Size2)
	PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
	PRTCL.Speed = NumberRange.new(Speed)
	PRTCL.VelocitySpread = Offset
	PRTCL.Drag = Drag
	PRTCL.Acceleration = Acel
	if Enabled == false then
		PRTCL:Emit(Emit)
		Debris:AddItem(PRTCL,Lifetime2)
	else
		PRTCL.Enabled = true
	end
	return PRTCL
end

for _, c in pairs(CharacterA:GetChildren()) do
	if c.ClassName == "Part" then
		c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	end
end

CharacterA.Parent = Character

Characterb.Parent = Character


local SKILLTEXTCOLOR = C3(1,1,1)
local SKILLFONT = ""
local SKILLTEXTSIZE = 7

Humanoid.Died:connect(function()
	ATTACK = true
end)

--[[local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.1, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.63, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.215, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.525, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")
local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 5 Frame")
]]
--[[local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Banish Bullet", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 1")
local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B] Ability 2", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 2")
local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C] Ability 3", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 3")
local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V] Ability 4", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 4")
local SKILL5TEXT = CreateLabel(SKILL5FRAME, "[X] Mercy", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 5")
]]

function chatfunc(text)
	local chat = coroutine.wrap(function()
	if Character:FindFirstChild("TalkingBillBoard")~= nil then
		Character:FindFirstChild("TalkingBillBoard"):destroy()
	end
	local Bill = Instance.new("BillboardGui",Character)
	Bill.Size = UDim2.new(0,100,0,40)
	Bill.StudsOffset = Vector3.new(0,3,0)
	Bill.Adornee = Character.Head
	Bill.Name = "TalkingBillBoard"
	local Hehe = Instance.new("TextLabel",Bill)
	Hehe.BackgroundTransparency = 1
	Hehe.BorderSizePixel = 0
	Hehe.Text = ""
	Hehe.Font = "SourceSansItalic"
	Hehe.TextSize = 40
	Hehe.TextStrokeTransparency = 0
	Hehe.Size = UDim2.new(1,0,0.5,0)
	coroutine.resume(coroutine.create(function()
		while Hehe ~= nil do
			Swait()	
			Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
			Hehe.Rotation = math.random(-5,5)
			Hehe.TextColor3 = Color3.new(0,0,0)
			Hehe.TextStrokeColor3 = Color3.new(1,1,1)
		end
	end))
	for i = 1,string.len(text),1 do
		Swait()
		Hehe.Text = string.sub(text,1,i)
	end
	Swait(90)--Re[math.random(1, 93)]
	for i = 0, 1, .025 do
		Swait()
		Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
		Hehe.TextStrokeTransparency = i
		Hehe.TextTransparency = i
	end
	Bill:Destroy()
	end)
chat()
end

function onChatted(msg)
	chatfunc(msg)
end

Player.Chatted:connect(onChatted)

function printbye(Name)
	local MESSAGES = {"You cannot struggle, ","Your existance is an insult, ","Fade, ","Your existance is not desired, ","You are not permitted here, ","You are not to decide your fate, ","Be gone, ","You are already dead, ","Your live is an anomaly, ","Don't dare to return, ","Why are you resisting, ","You cannot exist here, ","Why are you struggling, ","Your fate was already decided, ","Goodbye, ","You cannot ignore my command, ","You cannot resist my command, ","You already died, "}
	chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
end

workspace.ChildAdded:connect(function(instance)
    for BANISH = 1, #TOBANISH do
		if TOBANISH[BANISH] ~= nil then
			if instance.Name == TOBANISH[BANISH] then
				coroutine.resume(coroutine.create(function()
					printbye(instance.Name)
					instance:ClearAllChildren()
					Debris:AddItem(instance,0.0005)
				end))
			end
		end
	end
end)

--//=================================\\
--||			DAMAGING
--\\=================================//

function Banish(Foe)
	if Foe then
		coroutine.resume(coroutine.create(function()
			--if game.Players:FindFirstChild(Foe.Name) then
				table.insert(TOBANISH,Foe.Name)
				printbye(Foe.Name)
			--end
			Foe.Archivable = true
			local CLONE = Foe:Clone()
			Foe:Destroy()
			CLONE.Parent = Effects
			CLONE:BreakJoints()
			local MATERIALS = {"Glass","Neon"}
			for _, c in pairs(CLONE:GetDescendants()) do
				if c:IsA("BasePart") then
					if c.Name == "Torso" or c.Name == "UpperTorso" or c == CLONE.PrimaryPart then
 						CreateSound(340722848, c, 10, 1, false)
					end
					c.Anchored = true
					c.Transparency = c.Transparency + 0.2
					c.Material = MATERIALS[MRANDOM(1,2)]
					c.Color = C3(1,1,1)
					if c.ClassName == "MeshPart" then
						c.TextureID = ""
					end
					if c:FindFirstChildOfClass("SpecialMesh") then
						c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
					end
					if c:FindFirstChildOfClass("Decal") then
						c:FindFirstChildOfClass("Decal"):remove()
					end
					c.Name = "Banished"
					c.CanCollide = false
				else
					c:remove()
				end
			end
			local A = false
			for i = 1, 35 do
				if A == false then
					A = true
				elseif A == true then
					A = false
				end
				for _, c in pairs(CLONE:GetDescendants()) do
					if c:IsA("BasePart") then
						c.Anchored = true
						c.Material = MATERIALS[MRANDOM(1,2)]
						c.Transparency = c.Transparency + 0.8/35
						if A == false then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)
						elseif A == true then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)						
						end
					end
				end
				Swait()
			end
			CLONE:remove()
		end))
	end
end

function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end


function ManualDamage(Humanoid,Damage,TorsoPart)
	local defence = Instance.new("BoolValue",Humanoid.Parent)
	defence.Name = ("HitBy"..Player.Name)
	game:GetService("Debris"):AddItem(defence, 0.001)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health ~= 0 then
		local CritChance = MRANDOM(1,100)
		if Damage > Humanoid.Health then
			Damage = math.ceil(Humanoid.Health)
			if Damage == 0 then
				Damage = 0.1
			end
		end
		Humanoid.Health = Humanoid.Health - Damage
	end
end

local asd = Instance.new("ParticleEmitter")
asd.Color = ColorSequence.new(Color3.new(0.5, 0, 0), Color3.new(.3, 0, 0))
asd.LightEmission = .1
asd.Texture = "http://www.roblox.com/asset/?ID=291880914"
aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6),NumberSequenceKeypoint.new(1, 2)})
bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
asd.Transparency = bbb
asd.Size = aaa
asd.ZOffset = .9
asd.Acceleration = Vector3.new(0, -15, 0)
asd.LockedToPart = false
asd.EmissionDirection = "Back"
asd.Lifetime = NumberRange.new(1, 2)
asd.Rotation = NumberRange.new(-100, 100)
asd.RotSpeed = NumberRange.new(-100, 100)
asd.Speed = NumberRange.new(10)
asd.Enabled = false
asd.VelocitySpread = 999

function getbloody(victim,amount)
	local PART = CreatePart(3, Effects, "Metal", 0, 1, "Mid gray", "Blood", victim.Size)
	PART.CFrame = victim.CFrame
	local HITPLAYERSOUNDS = {"356551938","264486467"}
	Debris:AddItem(PART,5)
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	local prtcl = asd:Clone()
	prtcl.Parent = PART
	prtcl:Emit(amount*10)
end

function ManualAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ManualDamage(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function KickThatNigga(CHARACTER)
	g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 1
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
	 CreateSound("527749592", CHARACTER, 600, 1, false)
	for i,v in ipairs(CHARACTER:GetChildren()) do
		if v.ClassName == "Part" or v.ClassName == "MeshPart" then
			if v.Name ~= "HumanoidRootPart" then
				local BOD = v:Clone()
				BOD.CanCollide = false
				BOD.Anchored = true
				BOD.CFrame = v.CFrame
				BOD.Parent = kickfolder
				BOD.Material = "Granite"
				BOD.Color = C3(.3,0,0)
				if BOD:FindFirstChildOfClass("Decal") then
					BOD:FindFirstChildOfClass("Decal"):remove()
				end
				if BOD.Name == "Head" then
					naeeym2.Adornee = BOD
				end
				if BOD.ClassName == "MeshPart" then
					BOD.TextureID = ""
				end
			end
		end
	end
	for i,v in pairs(g) do
	v:remove()
	end 
	if CHARACTER ~= Character then
	CHARACTER:remove()
	end
	if CHARACTER.Name == "Helkern" then
		Character:BreakJoints()
	end
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
end

function ApplyAoE(POSITION,RANGE,ISKICKED)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISKICKED == true then
							KickThatNigga(CHILD)
						else
							if ISKICKED == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISKICKED == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

local BEANED = {}

function Ban(bitch)	
if bitch then	
g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 0
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
-- CreateSound("2570187601", bitch, 600, 1, false)
local Players = game:GetService("Players")
local fag = Players:FindFirstChild(bitch.Name)
--faggut:Kick()
	if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
		if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
		end
			if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
			end
				if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
				end
					if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
					end
						if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
						end
												if Players:FindFirstChild("Drago_TH") then
						end
						table.insert(BEANED,bitch.name)
	--]]
			--CreateSound("527749592", game.Workspace, 700, 1, false)
	--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
	--wait(6)
	--bitch:Remove()
end
end

local function CheckForBan(player)
	for i = 1, #BEANED do
		if player.Name == BEANED[i] then
			player:Kick("Ur mom gay skids") --Ban Reason Change between the '' to change the reason!
		end
	end
end


game.Players.PlayerAdded:connect(function()
	for i,v in pairs(game.Players:GetPlayers())do
		CheckForBan(v)
	end  
end)


function Kick(bitch)
g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 0
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
-- CreateSound("2570187601", bitch, 600, 1, false)
local Players = game:GetService("Players")
local fag = Players:FindFirstChild(bitch.Name)
--faggut:Kick()
	if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
		if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
		end
			if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
			end
				if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
				end
					if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
					end
						if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
	--[[
		for i,v in pairs(fag.Name) do
		if (v:lower() == newPlayer.Name:lower()) then
			newPlayer:Remove()
		end
	end]]--
			--CreateSound("527749592", game.Workspace, 700, 1, false)
	--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
	--wait(6)
	--bitch:Remove()
end


function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

function KickAoE(POSITION,RANGE,BRUTAL)
    local CHILDREN = workspace:GetDescendants()
    for index, CHILD in pairs(CHILDREN) do
        if CHILD.ClassName == "Model" and CHILD ~= Character then
            local HUM = CHILD:FindFirstChildOfClass("Humanoid")
            if HUM then
                local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                if TORSO then
                    if (TORSO.Position - POSITION).Magnitude <= RANGE then
                        if BRUTAL == true then
	if Type == "Banish" then
                            KickThatNigger(CHILD)
	elseif Type == "Ban" then
		Ban(CHILD)
	elseif Type == "Kick" then
		Kick(CHILD)
			--elseif Type == "Tangle" then
		--Entangle(CHILD)
		end
                        else
                            CHILD:BreakJoints()
                        end
                    end
                end
            end
        end
    end
end

local PE=Instance.new("ParticleEmitter",art)
PE.LightEmission=.8
PE.Color = ColorSequence.new(BRICKC("Really red").Color)
PE.Lifetime=NumberRange.new(0.35,1.5)
PE.Rotation=NumberRange.new(0,360)
PE.Rate=999
PE.VelocitySpread = 10000
PE.Acceleration = Vector3.new(0,0,0)
PE.Drag = 5
PE.Speed = NumberRange.new(0,0,0)
PE.Texture="http://www.roblox.com/asset/?id=833874434"
PE.ZOffset = -1.5
PE.Name = "PE"
PE.Enabled = false

function particles(art)
	local PARTICLES = PE:Clone()
	PARTICLES.Parent = art
end

function KillChildren(v)
	v:BreakJoints()
	for _, c in pairs(v:GetChildren()) do
		if c.ClassName == "Part" or c.ClassName == "MesPart" then
			if c.Transparency < 1 then
				if c:FindFirstChildOfClass("Decal") then
					c:FindFirstChildOfClass("Decal"):remove()
				end
				particles(c)
				c.PE.Enabled = true
				c.Parent = Effects
				c.CanCollide = false
				c.Material = "Neon"
				c.Color = C3(1,0,0)
				c.Transparency = 0.5
				local grav = Instance.new("BodyPosition",c)
				grav.P = 20000
				grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
				grav.position = c.Position + VT(MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1))
				grav.Name = "GravityForce"
				coroutine.resume(coroutine.create(function()
				for i = 1, 50 do
					Swait()
					c.Transparency = c.Transparency + 0.01
				end
				c.PE.Enabled = false
				Debris:AddItem(c,2)
				end))
			end
		end
	end
end

function killnearest(position,range)
	for i,v in ipairs(workspace:GetChildren()) do
	local body = v:GetChildren()
		for part = 1, #body do
			if((body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character) then
				if(body[part].Position - position).Magnitude < range then
					if v.ClassName == "Model" then
						KillChildren(v)
					end
				end
			end
		end
	end
end

function Dismember(MAN,DOWHAT)
	for index, CHILD in pairs(MAN:GetDescendants()) do
		if CHILD:IsA("Script") or CHILD:IsA("LocalScript") then
			CHILD:Destroy()
		end
	end
	if DOWHAT == "Ragdoll" then
		local HUM = MAN:FindFirstChildOfClass("Humanoid")
		if HUM then
			HUM.Health = 0
		end
		if MAN:FindFirstChild("UpperTorso") then
			local SCRIPT = script.R15Ragdoll:Clone()
			SCRIPT.Parent = MAN
			SCRIPT.Disabled = false
		else
			local SCRIPT = script.R6Ragdoll:Clone()
			SCRIPT.Parent = MAN
			SCRIPT.Disabled = false
		end
		MAN:BreakJoints()
	else
		local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
		local HED = MAN:FindFirstChild("Head")
		if TORSO and HED then
			if DOWHAT == "Head" then
				if TORSO:FindFirstChild("TorsoA4") then
					TORSO:FindFirstChild("TorsoA4"):Remove()
				elseif MAN:FindFirstChild("RagdollConstraintHead") then
					MAN:FindFirstChild("RagdollConstraintHead"):Remove()
				end
				HED:BreakJoints()
			elseif DOWHAT == "RightArm" then
				if TORSO:FindFirstChild("TorsoA3") then
					TORSO:FindFirstChild("TorsoA3"):Remove()
				elseif MAN:FindFirstChild("RagdollConstraintRightUpperArm") then
					MAN:FindFirstChild("RagdollConstraintRightUpperArm"):Remove()
				end
			elseif DOWHAT == "LeftArm" then
				if TORSO:FindFirstChild("TorsoA2") then
					TORSO:FindFirstChild("TorsoA2")
				elseif MAN:FindFirstChild("RagdollConstraintLeftUpperArm") then
					MAN:FindFirstChild("RagdollConstraintLeftUpperArm"):Remove()
				end
			elseif DOWHAT == "Legs" then
				if TORSO.Name == "Torso" then
					if TORSO:FindFirstChild("TorsoA") then
						TORSO:FindFirstChild("TorsoA"):Remove()
					end
					if TORSO:FindFirstChild("TorsoA1") then
						TORSO:FindFirstChild("TorsoA1"):Remove()
					end
				elseif MAN:FindFirstChild("RagdollConstraintUpperTorso") then
					MAN:FindFirstChild("RagdollConstraintUpperTorso"):Remove()
				end
			end
		end
	end
end

function OofOuchBlood(LOCATION,TO,AMOUNT)
	local P = CreatePart(3, Effects, "Granite", 0, 1, BRICKC("Pearl"), "Blood", VT(0,0,0), true)
	P.CFrame = CF(LOCATION,TO)
	local BLOOD = MODULE.Blood:Clone()
	BLOOD.Parent = P
	BLOOD:Emit(AMOUNT)
	Debris:AddItem(P,2)
end

local DETECTKILL = function(HIT,POS,FORCE)
		if HIT.Parent:FindFirstChildOfClass("Humanoid") then
			if HIT.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
				local BV = IT("BodyVelocity")
				BV.MaxForce = BV.MaxForce * 500
				BV.Velocity = CF(RootPart.Position,HIT.Position+VT(0,5,0)).lookVector*(FORCE or 25)
				BV.Parent = HIT
				Debris:AddItem(BV,0.05)
				OofOuchBlood(POS,RootPart.Position,150)
			else
				OofOuchBlood(POS,RootPart.Position,2)
			end
		end
	end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

function Zone()
	ATTACK = true
	Rooted = true
	for i=0, 5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(-18)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-5), RAD(12), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function meme()
local TARGET = Mouse.Target
	if TARGET ~= nil then
		if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
			local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
			local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
			if ROOT and HUM.Health > 0 then
			local FOE = Mouse.Target.Parent
			RootPart.CFrame = ROOT.CFrame*CF(0.3,0,6)
			ROOT.Anchored = true
   local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
	if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
	 local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
	  local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
	   if TORSO and HUM.Health > 0 then
			ATTACK = true
			Rooted = false
			CreateSound(429459101, TORSO, 0.5, 1, false)
	for i=0, 2, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(85), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(90), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
		WACKYEFFECT({Time = 18, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(Hole.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = 136523485, SoundPitch = 1, SoundVolume = 5})
		for i=0, 0.5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.5, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(-6), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.2, -0.8) * ANGLES(RAD(85), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.4, -0.3) * ANGLES(RAD(90), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-25)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
		getbloody(TORSO,1)
	--	SHAKECAM(HITPOS, 15, 2, 130)
		killnearest(TORSO.Position, 5, 5)
		WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(10,10,10), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 0, SoundPitch = MRANDOM(13,15)/10, SoundVolume = 3})
		WACKYEFFECT({EffectType = "Sphere", Size = VT(6,6,6), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	ATTACK = false
	Rooted = false
		 end
	end
			end
		end
		end
			end

function Dance()
	ATTACK = true
	Rooted = true
	local LOOP = true
	KEY = Mouse.KeyDown:connect(function(NEWKEY)
		if NEWKEY == "t" then
			KEY:Disconnect()
			LOOP = false
		end
	end)
	repeat
		for i = 0, 0.4, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0.1 + ((1) - 1)) * ANGLES(RAD(-8), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.2, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(15)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(15)), 1 / Animation_Speed)
	end
		for i = 0, 1, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(26)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(26)), 1 / Animation_Speed)
	end
		for i = 0, 0.4, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0.1 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.2, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-15)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-15)), 1 / Animation_Speed)
	end
		for i = 0, 1, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-26)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-26)), 1 / Animation_Speed)
	end
	until LOOP == false
	ATTACK = false
	Rooted = false
end


--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//

-------------------------------------

Humanoid.Animator.Parent = nil

-------------------------------------


function MouseDown(Mouse)
	if ATTACK == false then
	end
end


function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "v" and ATTACK == false then
		meme()
		end
		
	if Key == "t" and ATTACK == false then
		Dance()
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

--//=================================\\
--\\=================================//


function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end


--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

local CONNECT = nil

while true do
	Swait()
	ANIMATE.Parent = nil
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.2 * COS(SINE / (WALKSPEEDVALUE))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 100, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 25), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1 - 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1 + 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
	end
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(15)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(45)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 0.15 / Animation_Speed)
			if MRANDOM(1,50) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-10,10)), RAD(MRANDOM(-10,10)), RAD(MRANDOM(-10,10))), 1 / Animation_Speed)
			end	
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.3, 0) * ANGLES(RAD(15 - 15 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 15 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.8, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(86), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-86), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
	end
	unanchor()
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	if sick.Parent ~= Torso then
	sick = IT("Sound", Torso)
	end
	sick.Parent = Torso
	sick.Playing = true
    sick.Looped = true
	sick.Volume = 2
	sick.Pitch = 1
	sick.SoundId = "rbxassetid://549162782"
	sick.Name = "Dead"
end

--//=================================\\
--\\=================================//




local basetpart = game.Workspace.non:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner()
--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--

    end


if string.sub(msg, 1, 10) == (prefix.."traprifle") then
------------------------
--Aiju Love Trap Rifle--
----------------------------------------------------------------
--By CKbackup (Sugarie Saffron)                               --
--YT: https://www.youtube.com/channel/UC8n9FFz7e6Zo13ob_5F9MJw--
--Discord: Sugarie Saffron#4705                               --
----------------------------------------------------------------
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


local pee = game.Players.LocalPlayer.Character["METALXLIGHTSEER77Accessory"]
local gold = game.Players.LocalPlayer.Character["METALXLIGHTSEER77Accessory"].Handle
gold.AccessoryWeld:Destroy()




local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = gold
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true

attachment1.CFrame = CFrame.Angles(-2,4.6,-.9) 
  attachment0.CFrame = CFrame.new(1.2,0,-.3)
  
  

 -- local toolgoflingfling = Instance.new("BodyVelocity", gold)
--toolgoflingfling.MaxForce = Vector3.new(90000,90000,90000)
--toolgoflingfling.Velocity = Vector3.new(90000,90000,90000)
 
 
function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end



--loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()

wait(10)


wait(1/60)
Effects = { }
local Player = game:service'Players'.localPlayer
loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()
playerss = workspace.non
local chara = workspace.non
local Humanoid = chara:FindFirstChildOfClass("Humanoid")
local Mouse = Player:GetMouse()
local LeftArm = chara["Left Arm"]
local RightArm = chara["Right Arm"]
local LeftLeg = chara["Left Leg"]
local RightLeg = chara["Right Leg"]
local Head = chara.Head
local Torso = chara.Torso
local Camera = workspace.CurrentCamera
local RootPart = chara.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local attack = false
local Anim = 'Idle'
local attacktype = 1
local delays = false
local play = true
local targetted = nil
local Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
local velocity = RootPart.Velocity.y
local sine = 0
local change = 1
local doe = 0
local Create = LoadLibrary("RbxUtility").Create
local debby = game:GetService("Debris")
Humanoid.WalkSpeed = 16

Humanoid.Animator.Parent = nil
chara.Animate.Parent = nil

local newMotor = function(part0, part1, c0, c1)
local w = Create('Motor'){
Parent = part0,
Part0 = part0,
Part1 = part1,
C0 = c0,
C1 = c1,
}
return w
end

function clerp(a, b, t)
return a:lerp(b, t)
end

RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

local RW = newMotor(Torso, RightArm, CFrame.new(1.5, 0, 0), CFrame.new(0, 0, 0)) 
local LW = newMotor(Torso, LeftArm, CFrame.new(-1.5, 0, 0), CFrame.new(0, 0, 0))
local RH = newMotor(Torso, RightLeg, CFrame.new(.5, -2, 0), CFrame.new(0, 0, 0))
local LH = newMotor(Torso, LeftLeg, CFrame.new(-.5, -2, 0), CFrame.new(0, 0, 0))
RootJoint.C1 = CFrame.new(0, 0, 0)
RootJoint.C0 = CFrame.new(0, 0, 0)
Torso.Neck.C1 = CFrame.new(0, 0, 0)
Torso.Neck.C0 = CFrame.new(0, 1.5, 0)

local rarmc1 = RW.C1
local larmc1 = LW.C1
local rlegc1 = RH.C1
local llegc1 = LH.C1

local resetc1 = false

function PlayAnimationFromTable(table, speed, bool)
RootJoint.C0 = clerp(RootJoint.C0, table[1], speed) 
Torso.Neck.C0 = clerp(Torso.Neck.C0, table[2], speed) 
RW.C0 = clerp(RW.C0, table[3], speed) 
LW.C0 = clerp(LW.C0, table[4], speed) 
RH.C0 = clerp(RH.C0, table[5], speed) 
LH.C0 = clerp(LH.C0, table[6], speed) 
if bool == true then
if resetc1 == false then
resetc1 = true
RootJoint.C1 = RootJoint.C1
Torso.Neck.C1 = Torso.Neck.C1
RW.C1 = rarmc1
LW.C1 = larmc1
RH.C1 = rlegc1
LH.C1 = llegc1
end
end
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")
frame = 0.03333333333333
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
tf = tf + s
if tf >= frame then
if allowframeloss then
script.Heartbeat:Fire()
lastframe = tick()
else
for i = 1, math.floor(tf / frame) do
script.Heartbeat:Fire()
end
lastframe = tick()
end
if tossremainder then
tf = 0
else
tf = tf - frame * math.floor(tf / frame)
end
end
end)
function swait(num)
if num == 0 or num == nil then
ArtificialHB.Event:wait()
else
for i = 0, num do
ArtificialHB.Event:wait()
end
end
end

function RemoveOutlines(part)
part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

function so(id,par,pit,vol)
local sou = Instance.new("Sound", par or workspace)
if par == chara then
sou.Parent = chara.Torso
end
sou.Volume = vol
sou.Pitch = pit or 1
sou.SoundId = "rbxassetid://" .. id
sou.PlayOnRemove = true
sou:Destroy()
end

--This is just for builds--
New = function(Object, Parent, Name, Data)
local Object = Instance.new(Object)
for Index, Value in pairs(Data or {}) do
Object[Index] = Value
end
Object.Parent = Parent
Object.Name = Name
return Object
end


function rayCast(Position, Direction, Range, Ignore)
return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) 
end 

function FindNearestTorso(Position, Distance, SinglePlayer)
if SinglePlayer then
return (SinglePlayer.Head.CFrame.p - Position).magnitude < Distance
end
local List = {}
for i, v in pairs(workspace:GetDescendants()) do
if v:IsA("Model") then
if v:findFirstChild("Head") then
if v ~= chara then
if (v.Head.Position - Position).magnitude <= Distance then
table.insert(List, v)
end 
end 
end 
end 
end
return List
end

EffectModel = Create("Model"){
Parent = chara,
Name = "Effects",
}

--Effect Functions--
Effects = {

Block = function(cf,partsize,meshstart,meshadd,matr,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("BlockMesh",p)
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
if spin == true then
p.CFrame = p.CFrame * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
end
end
p:Destroy()
end)()
return p
end,

Sphere = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshType = "Sphere"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Cylinder = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("CylinderMesh",p)
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Wave = function(cf,meshstart,meshadd,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://20329976"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Ring = function(cf,meshstart,meshadd,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://3270017"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Meshed = function(cf,meshstart,meshadd,colour,meshid,textid,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = meshid
m.TextureId = textid
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Explode = function(cf,partsize,meshstart,meshadd,matr,colour,move,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf * CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshType = "Sphere"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.new(0,move,0)
end
p:Destroy()
end)()
return p
end,

}

function GetDudesTorso(c)
local torsy = (c:findFirstChild("Torso") or c:findFirstChild("UpperTorso"))
if torsy ~= nil then
return torsy
end
end

function BodyVel(part,faws)
local bodyvel = Instance.new("BodyVelocity",part)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = faws
debby:AddItem(bodyvel,.2)
end

function Dmg(dude)
if dude and dude ~= chara and dude.Name ~= "CKbackup" then
if dude:FindFirstChild("TURAPPU") then return end
local debounce = Instance.new("BoolValue",dude)
debounce.Name = "TURAPPU"
coroutine.wrap(function()
local torsy = GetDudesTorso(dude)
if torsy then
local b = Instance.new("Part",dude)
b.BrickColor = BrickColor.new("Pink")
b.Size = Vector3.new(.1,.1,.1)
b.CanCollide = false
b.Transparency = 1
b.Material = "Neon"
b:BreakJoints()
so(113952851,b,1,3)
local bw = Instance.new("Weld",b)
bw.Part0 = b
bw.Part1 = torsy
local bm = Instance.new("SpecialMesh",b)
bm.MeshType = "Sphere"
bm.Scale = Vector3.new()
for i=0,1,.05 do
swait()
b.Transparency = 1-i
bm.Scale = Vector3.new(65*i,65*i,65*i)
end
coroutine.wrap(function()
swait(20)
for i=0,1,.05 do
swait()
b.Transparency = i
bm.Scale = Vector3.new(65+100*i,65+100*i,65+100*i)
end
b:Destroy()
end)()
end
for i,v in pairs(dude:children()) do
if v:IsA("Clothing") or v:IsA("BodyColors") or v:IsA("Accoutrement") then v:Destroy() end
end
local hedcol = dude:FindFirstChild("Head").BrickColor
local bcols = Instance.new("BodyColors",dude)
bcols.Name = "NeoCols"
bcols.HeadColor = hedcol
bcols.LeftArmColor = hedcol
bcols.RightArmColor = hedcol
bcols.TorsoColor = hedcol
bcols.LeftLegColor = hedcol
bcols.RightLegColor = hedcol
local Heiru = nil
local hacho = math.random(1,6)
if hacho == 1 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999847, 3.29998803, -42.2000351, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.075000003, 0.0599999987, 0.0599999987),MeshId = "rbxassetid://506240548",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(-7.62939453e-06, -1.19999862, 0.200000763, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 2 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.5, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.5499878, 4.29998732, -42.1000366, -1, 0, 0, 0, 1, 0, 0, 0, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(1.04999995, 1.04999995, 1.04999995),MeshId = "rbxassetid://398987591",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),C1 = CFrame.new(0.0499954224, -0.199999332, 0.100002289, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 3 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.5, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4499893, 3.89998746, -42.1000366, -1, 0, 0, 0, 1, 0, 0, 0, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{MeshId = "rbxassetid://164382853",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),C1 = CFrame.new(-0.0500030518, -0.599999189, 0.100002289, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 4 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999771, 2.79998851, -43.3000183, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.109999999, 0.0799999982, 0.0850000009),MeshId = "rbxassetid://561963999",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(-1.52587891e-05, -1.69999814, 1.29998398, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 5 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999847, 3.69998765, -42.600029, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.0450000018, 0.0450000018, 0.0450000018),MeshId = "rbxassetid://487000462",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(-7.62939453e-06, -0.799998999, 0.599994659, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 6 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.5, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.5499802, 3.29998803, -42.0000381, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.0649999976, 0.0599999987, 0.0599999987),MeshId = "rbxassetid://437152207",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(0.049987793, -1.19999862, 3.81469727e-06, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
end
local haircol = {"Pink","Baby blue","Magenta","Brown","Black","Really black","White","CGA brown","Cool yellow"}
Heiru.BrickColor = BrickColor.new(haircol[math.random(1,#haircol)])
local ercho = math.random(1,8)
if ercho == 1 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 4.59999943, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{Scale = Vector3.new(1.04999995, 1, 1.04999995),MeshId = "rbxassetid://10871984",TextureId = "rbxassetid://10871968",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.100012779, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 2 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 5.39999866, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{MeshId = "rbxassetid://1072759",TextureId = "rbxassetid://1072760",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.900012016, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 3 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.300000012, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.5499954, 5.29999876, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{Scale = Vector3.new(1.20000005, 1.20000005, 1.20000005),MeshId = "rbxassetid://1374148",TextureId = "rbxassetid://413143035",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0.0500030518, 0.800012112, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 4 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 5.29999876, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{Scale = Vector3.new(0.699999988, 0.5, 0.600000024),MeshId = "rbxassetid://361948302",TextureId = "rbxassetid://361948503",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.800012112, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 5 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 5.09999895, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{MeshId = "rbxassetid://1095510",TextureId = "rbxassetid://1095511",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.600012302, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
end
local oucho = math.random(1,6)
local sh = Instance.new("Shirt",dude)
local pn = Instance.new("Pants",dude)
if oucho == 1 then
pn.PantsTemplate = "rbxassetid://56903591"
sh:Destroy()
elseif oucho == 2 then
sh.ShirtTemplate = "rbxassetid://242933637"
pn.PantsTemplate = "rbxassetid://745334066"
elseif oucho == 3 then
sh.ShirtTemplate = "rbxassetid://1238151974"
pn.PantsTemplate = "rbxassetid://1340645290"
elseif oucho == 4 then
sh.ShirtTemplate = "rbxassetid://583471131"
pn.PantsTemplate = "rbxassetid://460147365"
elseif oucho == 5 then
pn.PantsTemplate = "rbxassetid://45541243"
sh:Destroy()
elseif oucho == 6 then
pn.PantsTemplate = "rbxassetid://41162775"
sh:Destroy()
end
Instance.new("Decal",dude:FindFirstChild("Head")).Texture = "rbxassetid://985062039"
coroutine.wrap(function()
swait(40)
local naeeym2 = Instance.new("BillboardGui",dude)
naeeym2.Size = UDim2.new(0,100,0,40)
naeeym2.StudsOffset = Vector3.new(0,3,0)
naeeym2.Adornee = dude:FindFirstChild("Head")
naeeym2.Name = "TalkingBillBoard"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.BorderSizePixel = 0
tecks2.Text = "Trapped! In another sense.."
tecks2.Font = "Cartoon"
tecks2.TextSize = 24
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(1,.6,.7)
tecks2.TextStrokeColor3 = Color3.new(1,1,1)
tecks2.Size = UDim2.new(1,0,0.5,0)
swait(10)
for i = 0,1,.05 do
swait()
tecks2.Position = tecks2.Position - UDim2.new(0,0,.005,0)
tecks2.TextStrokeTransparency = i
tecks2.TextTransparency = i
end
naeeym2:Destroy()
end)()
end)()
end
end

function MagnitudeDmg(par,magni)
for _, c in pairs(workspace:GetDescendants()) do
local hum = c:FindFirstChildOfClass("Humanoid")
if hum ~= nil and c:FindFirstChild("IsTeamMateOfCK")==nil then
local head = GetDudesTorso(c)
if head ~= nil then
local targ = head.Position - par.Position
local mag = targ.magnitude
if magni >= mag and c ~= chara then
Dmg(c)
end
end
end
end
end

local mus = Instance.new("Sound",Head)
mus.Name = "mus"
mus.SoundId = "rbxassetid://1131624146"
mus.Looped = true
mus.Volume = 1
mus:Play()

zhold = false
function shoot()
attack = true
for i=0,1,.3 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(0.0823832005, 1.55974865, -0.0981806219, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
CFrame.new(1.02804303, 0.5, -0.52656126, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
CFrame.new(-1.28728318, 0.203263342, -0.756378591, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
CFrame.new(0.499997735, -1.99999893, -1.11758709e-06, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
CFrame.new(-0.500001431, -1.99999893, -9.983778e-07, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
}, .4, false)
end
Humanoid.WalkSpeed = 2
local ref = Instance.new("Part",chara)
ref.Size = Vector3.new(0,0,0)
ref.Anchored = true
ref.CanCollide = false
ref.Transparency = 1
repeat
so(1145251796,ShotPt,math.random(95,105)/100,3)
ref.CFrame = Mouse.Hit
MagnitudeDmg(ref,2)
--Effects.Block(ShotPt.CFrame,Vector3.new(1,1,1),Vector3.new(),Vector3.new(.2,.2,.2),"Neon","Pink",true,false,.1)
--Effects.Block(CFrame.new((ShotPt.Position + Mouse.Hit.p)/2,Mouse.Hit.p),Vector3.new(1,1,(ShotPt.Position - Mouse.Hit.p).magnitude),Vector3.new(.2,.2,1),Vector3.new(.1,.1,0),"Neon","Pink",false,false,.1)
--Effects.Block(Mouse.Hit,Vector3.new(1,1,1),Vector3.new(),Vector3.new(.2,.2,.2),"Neon","Pink",true,false,.1)
for i=0,1,.5 do
swait()
PlayAnimationFromTable({		
CFrame.new(2.25380063e-06, 0, 0.100001052, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(0.0823859125, 1.55974913, -0.0981838703, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
CFrame.new(1.25785875, 0.5, -0.333723217, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
CFrame.new(-1.05747044, 0.203263938, -0.563540041, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
CFrame.new(0.423390329, -1.99999893, -0.0642812699, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
CFrame.new(-0.57660532, -1.99999893, -0.0642794371, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
}, .4, false)
end
for i=0,1,.5 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(0.0823832005, 1.55974865, -0.0981806219, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
CFrame.new(1.02804303, 0.5, -0.52656126, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
CFrame.new(-1.28728318, 0.203263342, -0.756378591, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
CFrame.new(0.499997735, -1.99999893, -1.11758709e-06, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
CFrame.new(-0.500001431, -1.99999893, -9.983778e-07, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
}, .4, false)
end
until zhold == false
ref:Destroy()
Humanoid.WalkSpeed = 16
attack = false
end

function doge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
local bodyvel = Instance.new("BodyVelocity",RootPart)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.413182259, -0.492409885, 1, 0, 0, 0, 0.173647001, 0.984807968, 0, -0.984807968, 0.173647001),
CFrame.new(0, 1.39017391, 0.409808099, 1, 0, 0, 0, 0.499998748, -0.866026163, 0, 0.866026163, 0.499998748),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(-0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -1.30470812, -0.622091293, 1, 0, 0, 0, -0.866025984, 0.499998987, 0, -0.499998987, -0.866025984),
CFrame.new(0, 1.47984993, -0.230206192, 1, 0, 0, 0, 0.939693034, 0.34201926, 0, -0.34201926, 0.939693034),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(-0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -2.22375727, 0.305265486, 1, 0, 0, 0, 0.500000238, -0.866025388, 0, 0.866025388, 0.500000238),
CFrame.new(0, 1.35128808, -0.383415997, 1, 0, 0, 0, 0.766043901, 0.642788529, 0, -0.64278847, 0.766043901),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999337, -0.599998593, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024),
CFrame.new(-0.500003815, -1.35979521, -0.923200667, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
bodyvel:Destroy()
Humanoid.WalkSpeed = 16
attack = false
end

function bdoge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
local bodyvel = Instance.new("BodyVelocity",RootPart)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = RootPart.CFrame.lookVector*-50
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -2.22375727, 0.305265486, 1, 0, 0, 0, 0.500000238, -0.866025388, 0, 0.866025388, 0.500000238),
CFrame.new(0, 1.35128808, -0.383415997, 1, 0, 0, 0, 0.766043901, 0.642788529, 0, -0.64278847, 0.766043901),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999337, -0.599998593, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024),
CFrame.new(-0.500003815, -1.35979521, -0.923200667, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*-50
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -1.30470812, -0.622091293, 1, 0, 0, 0, -0.866025984, 0.499998987, 0, -0.499998987, -0.866025984),
CFrame.new(0, 1.47984993, -0.230206192, 1, 0, 0, 0, 0.939693034, 0.34201926, 0, -0.34201926, 0.939693034),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(-0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*-50
end
bodyvel:Destroy()
Humanoid.WalkSpeed = 16
attack = false
end

function adoge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
Effects.Wave(RootPart.CFrame*CFrame.Angles(math.rad(90),0,0),Vector3.new(),Vector3.new(1,.1,1),"White",math.random(-10,10),false,.1)
BodyVel(RootPart,RootPart.CFrame.lookVector*50)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.095761165, -0.251516223, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
CFrame.new(0, 1.43075883, 0.149916381, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.96527231, 0.196966231, 1, 0, 0, 0, 0.984807789, 0.173648685, 0, -0.173648715, 0.984807789),
CFrame.new(-0.5, -1.43618584, -0.205210268, 1, 0, 0, 0, 0.939692438, 0.342020929, 0, -0.342020959, 0.939692438),
}, .4, false)
end
Humanoid.WalkSpeed = 16
attack = false
end

function badoge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
Effects.Wave(RootPart.CFrame*CFrame.Angles(math.rad(-90),0,0),Vector3.new(),Vector3.new(1,.1,1),"White",math.random(-10,10),false,.1)
BodyVel(RootPart,RootPart.CFrame.lookVector*-50)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.210508779, 0.312937856, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
CFrame.new(0, 1.4075644, -0.288293391, 1, 0, 0, 0, 0.866025388, 0.500000238, 0, -0.500000238, 0.866025388),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.9652698, 0.196958005, 1, 0, 0, 0, 0.984807789, 0.173648715, 0, -0.173648685, 0.984807789),
CFrame.new(-0.5, -1.43618536, -0.205215126, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676),
}, .4, false)
end
Humanoid.WalkSpeed = 16
attack = false
end

Mouse.Button1Down:connect(function()
if attack == false then
zhold = true
shoot()
end
end)

Mouse.Button1Up:connect(function()
zhold = false
end)

local sprintt = 0
Mouse.KeyDown:connect(function(k)
k = k:lower()
if k=='m' then
if mus.IsPlaying == true then
mus:Stop()
elseif mus.IsPaused == true then
mus:Play()
end
end
if attack == false then
if k == 'q' then
if Anim == "Fall" or Anim == "Jump" then
badoge()
else
bdoge()
end
elseif k == 'e' then
if Anim == "Fall" or Anim == "Jump" then
adoge()
else
doge()
end
end
end
end)

Mouse.KeyUp:connect(function(k)
k = k:lower()
if k == 'z' then
zhold = false
end
end)

coroutine.wrap(function()
while 1 do
swait()
if doe <= 360 then
doe = doe + 2
else
doe = 0
end
end
end)()
while true do
swait()
while true do
swait()
if Head:FindFirstChild("mus")==nil then
mus = Instance.new("Sound",Head)
mus.Name = "mus"
mus.SoundId = "rbxassetid://1131624146"
mus.Looped = true
mus.Volume = 1
mus:Play()
end
if sprintt >= 1 then
sprintt = sprintt - 1
end
Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
velocity = RootPart.Velocity.y
sine = sine + change
local hit, pos = rayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, chara)
if RootPart.Velocity.y > 1 and hit == nil then 
Anim = "Jump"
if attack == false then
PlayAnimationFromTable({
CFrame.new(0, 0.0382082276, -0.0403150208, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
CFrame.new(0, 1.46579528, 0.0939689279, 1, 0, 0, 0, 0.939692855, -0.342019796, 0, 0.342019796, 0.939692855),
CFrame.new(1.20945489, -0.213504896, 3.55388607e-07, 0.939692736, 0.342019916, 1.53461215e-07, -0.342019945, 0.939692736, 1.93715096e-07, -8.56816769e-08, -2.23517418e-07, 1.00000012),
CFrame.new(-1.20945573, -0.213503733, 5.0439985e-07, 0.939692736, -0.342019916, -1.53461215e-07, 0.342019945, 0.939692736, 1.93715096e-07, 8.56816769e-08, -2.23517418e-07, 1.00000012),
CFrame.new(0.5, -1.99739456, -0.0180913229, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
CFrame.new(-0.5, -1.30000103, -0.39999947, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676),
}, .3, false)
end
elseif RootPart.Velocity.y < -1 and hit == nil then 
Anim = "Fall"
if attack == false then
PlayAnimationFromTable({
CFrame.new(0, -0.0646628663, 0.0399149321, 1, 0, 0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849),
CFrame.new(0, 1.4913609, -0.128171027, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
CFrame.new(1.55285025, 0.466259956, -9.26282269e-08, 0.766043842, -0.642788351, -6.46188241e-08, 0.642788291, 0.766043961, -7.4505806e-08, 1.04308128e-07, 1.49011612e-08, 1.00000012),
CFrame.new(-1.5605253, 0.475036323, -2.10609159e-07, 0.766043842, 0.642788351, 6.46188241e-08, -0.642788291, 0.766043961, -7.4505806e-08, -1.04308128e-07, 1.49011612e-08, 1.00000012),
CFrame.new(0.500000954, -1.9973948, -0.0180922765, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
CFrame.new(-0.499999046, -1.30000043, -0.400000483, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
}, .3, false)
end
elseif Torsovelocity < 1 and hit ~= nil then
Anim = "Idle"
if attack == false then
change = 1
PlayAnimationFromTable({
CFrame.new(-0.0769465268, -7.7815578e-08, -0.031559173, 0.939695537, 1.01607293e-06, 0.342021346, 7.9855522e-07, 1.00000191, 5.12654879e-07, -0.342019558, 2.16066837e-07, 0.939692855) * CFrame.new(0,.05 * math.cos((sine)/10), 0),
CFrame.new(0.0615186803, 1.4999913, 0.0559706129, 0.939695537, 7.9855522e-07, -0.342019558, 1.01607293e-06, 1.00000191, 2.16066837e-07, 0.342021346, 5.12654879e-07, 0.939692855),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.500003159, -2.00000715, -1.98185444e-06, 0.939692736, 0, -0.342019916, 0, 1, 0, 0.342019886, 0, 0.939692736) * CFrame.new(0,-.05 * math.cos((sine)/10), 0),
CFrame.new(-0.500018835, -2.0000062, 2.08616257e-07, 0.939692438, 0, 0.342020929, 0, 1, 0, -0.342020959, 0, 0.939692438) * CFrame.new(0,-.05 * math.cos((sine)/10), 0),
}, .3, false)
end
elseif Torsovelocity > 2 and hit ~= nil then
Anim = "Walk"
if attack == false then
Humanoid.WalkSpeed = 16
PlayAnimationFromTable({
CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0, 0- .08 * math.cos((sine) / 2.5), 0) * CFrame.Angles(0, 0, 0),
CFrame.new(0, 1.48263013, -0.0984808952, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.540300786, -1.99793816, -9.82598067e-07, 0.998698533, -0.0510031395, 6.36324955e-07, 0.0510031395, 0.998698533, -1.00461093e-05, -8.35937328e-08, 1.08393433e-05, 1.00000024) * CFrame.new(0, 0, 0+ .5 * math.cos((sine) / 5)) * CFrame.Angles(math.rad(0 - 30 * math.cos((sine) / 5)), 0, 0), 
CFrame.new(-0.539563596, -1.99794078, 1.12228372e-06, 0.998635888, 0.0523072146, -1.77852357e-07, -0.0523072146, 0.998635888, -1.00715051e-05, -3.89727461e-07, 1.08406466e-05, 1.00000024) * CFrame.new(0, 0, 0- .5 * math.cos((sine) / 5)) * CFrame.Angles(math.rad(0 + 30 * math.cos((sine) / 5)), 0, 0), 
}, .3, false)
end
end
end
end
local basetpart = game.Players.Character:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
  sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end
end

if string.sub(msg, 1, 6) == (prefix.."sonic") then
       --[[KillerDarkness0105's/Codex's Sonic script]]--

 sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
       --sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)

function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end

loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()


wait(0.07)
Player=game:GetService("Players").LocalPlayer
Character=workspace.non
PlayerGui=Player.PlayerGui
Backpack=Player.Backpack
Torso=Character.Torso
Head=Character["Head"]
Humanoid=Character.Humanoid
LeftArm=Character["Left Arm"]
LeftLeg=Character["Left Leg"]
RightArm=Character["Right Arm"]
RightLeg=Character["Right Leg"]
LS=Torso["Left Shoulder"]
LH=Torso["Left Hip"]
RS=Torso["Right Shoulder"]
RH=Torso["Right Hip"]
Face = Head.face
Neck=Torso.Neck
it=Instance.new
attacktype=1
attacktype2=1
vt=Vector3.new
cf=CFrame.new
cn=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
combo = 0
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false
attackdebounce = false
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
stance = false
local ff = 2
noleg = false
evadecooldown = false
Humanoid.Animator.Parent = nil
equip = false
local Effects = {}
 attackspeed = 0.14 
 df = false
 Swing = 1
local sine = 0
local change = 1
local val = 0
local speed = 0
local rs = game:GetService("RunService").RenderStepped
cam = workspace.CurrentCamera
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create
deb = game:GetService("Debris")
Face.Transparency = 0
--Face.Texture = "rbxassetid://176217905" --176217905
Humanoid.WalkSpeed = 64
local freefall = 0

local boost = false
Humanoid.JumpPower = 88
local musicnum = 1
    
     local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
 local GravPoint = RootPart.Velocity.y
 local NV = Vector3.new(0,0,0)
print("Move list")
print("---------")
print("Shift = Boost")
print("Ctrl = Mach Speed Boost")
print("Q = Left QuickStep, E  = Right QuickStep")
print("C = Slide, in air to stomp")
print("Jump Then Hold B near a wall to wallrun")
print("M to change music, if you're standing still you'll do a special animation!")
print("Space near a wall to walljump, away from a wall homing attack")
		music = Instance.new("Sound",PlayerGui)
		music.Volume = 1
		music.TimePosition = 0
		music.Pitch = 1
		music.SoundId = "rbxassetid://1251555494"
		music.Looped = true
		music:Play()
		

		boostsound = Instance.new("Sound",PlayerGui)
		boostsound.Volume = .6
		boostsound.TimePosition = 0
		boostsound.Pitch = 1
		boostsound.SoundId = "rbxassetid://924922553"
		boostsound.Looped = false



		stompsound = Instance.new("Sound",PlayerGui)
		stompsound.Volume = 2
		stompsound.TimePosition = 0
		stompsound.Pitch = 1
		stompsound.SoundId = "rbxassetid://1295424184"
		stompsound.Looped = false



			       so = function(id,par,vol,pit)
		coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound",par or workspace)
		sou.Volume=vol
		sou.Pitch=pit or 1
		sou.SoundId=id
		sou:play()
		game:GetService("Debris"):AddItem(sou,8)
		end))
		end
		
		--save shoulders
		RSH, LSH=nil, nil
		--welds
		RW, LW=Instance.new("Weld"), Instance.new("Weld")
		RW.Name="Right Shoulder" LW.Name="Left Shoulder"
		LH=Torso["Left Hip"]
		RH=Torso["Right Hip"]
		TorsoColor=Torso.BrickColor
		function NoOutline(Part)
		Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
		end
		player=Player
		ch=Character
		RSH=ch.Torso["Right Shoulder"]
		LSH=ch.Torso["Left Shoulder"]
		--
		RSH.Parent=nil
		LSH.Parent=nil
		--
		RW.Name="Right Shoulder"
		RW.Part0=ch.Torso
		RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5)
		RW.C1=cf(0, 0.5, 0)
		RW.Part1=ch["Right Arm"]
		RW.Parent=ch.Torso
		--
		LW.Name="Left Shoulder"
		LW.Part0=ch.Torso
		LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8)
		LW.C1=cf(0, 0.5, 0)
		LW.Part1=ch["Left Arm"]
		LW.Parent=ch.Torso
		 
		 
		newWeld = function(wp0, wp1, wc0x, wc0y, wc0z)
		    local wld = Instance.new("Weld", wp1)
		    wld.Part0 = wp0
		    wld.Part1 = wp1
		    wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
		end
		 local rs = game:GetService("RunService").RenderStepped
		 
		newWeld(RootPart, Torso, 0, -1, 0)
		Torso.Weld.C1 = CFrame.new(0, -1, 0)
		newWeld(Torso, LeftLeg, -0.5, -1, 0)
		LeftLeg.Weld.C1 = CFrame.new(0, 1, 0)
		newWeld(Torso, RightLeg, 0.5, -1, 0)
		RightLeg.Weld.C1 = CFrame.new(0, 1, 0)
		
		    Player=game:GetService('Players').LocalPlayer
		    Character=Player.Character
		    mouse=Player:GetMouse()
		    m=Instance.new('Model',Character)
		 
		 
		    local function weldBetween(a, b)
		        local weldd = Instance.new("ManualWeld")
		        weldd.Part0 = a
		        weldd.Part1 = b
		        weldd.C0 = CFrame.new()
		        weldd.C1 = b.CFrame:inverse() * a.CFrame
		        weldd.Parent = a
		        return weldd
		    end
		   
		    ArtificialHB = Instance.new("BindableEvent", script)
		ArtificialHB.Name = "Heartbeat"
		 
		script:WaitForChild("Heartbeat")
		 
		frame = 1 / 80
		tf = 0
		allowframeloss = false
		tossremainder = false
		lastframe = tick()
		script.Heartbeat:Fire()
		game:GetService("RunService").Heartbeat:connect(function(s, p)
		    tf = tf + s
		    if tf >= frame then
		        if allowframeloss then
		            script.Heartbeat:Fire()
		            lastframe = tick()
		        else
		            for i = 1, math.floor(tf / frame) do
		                script.Heartbeat:Fire()
		            end
		            lastframe = tick()
		        end
		        if tossremainder then
		            tf = 0
		        else
		            tf = tf - frame * math.floor(tf / frame)
		        end
		    end
		end)
		 
--[[]
		function swait(num)
		    if num == 0 or num == nil then
		        ArtificialHB.Event:wait()
		    else
		        for i = 0, num do
		            ArtificialHB.Event:wait()
		        end
		    end
	end

	]]
	



	function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait()
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait()
		end
	end
end

		function RemoveOutlines(part)
		    part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
		end
		   
		
		part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
		  local fp = it("Part")
		  fp.formFactor = formfactor
		  fp.Parent = parent
		  fp.Reflectance = reflectance
		  fp.Transparency = transparency
		  fp.CanCollide = false
		  fp.Locked = true
		  fp.BrickColor = brickcolor
		  fp.Name = name
		  fp.Size = size
		  fp.Position = Torso.Position
		  NoOutline(fp)
		  if fp.BrickColor == BrickColor.new("Dark indigo") then
		    fp.Material = "Neon"
		  else
		    if fp.BrickColor == BrickColor.new("Really black") then
		      fp.BrickColor = BrickColor.new("Really black")
		      fp.Material = "Metal"
		    else
		      fp.Material = "Neon"
		    end
		  end
		  fp:BreakJoints()
		  return fp
		end
		
		mesh = function(Mesh, part, meshtype, meshid, offset, scale)
		  local mesh = it(Mesh)
		  mesh.Parent = part
		  if Mesh == "SpecialMesh" then
		    mesh.MeshType = meshtype
		    mesh.MeshId = meshid
		  end
		  mesh.Offset = offset
		  mesh.Scale = scale
		  return mesh
		end
		
		weld = function(parent, part0, part1, c0)
		  local weld = it("Weld")
		  weld.Parent = parent
		  weld.Part0 = part0
		  weld.Part1 = part1
		  weld.C0 = c0
		  return weld
		end
		
		F1 = Instance.new("Folder", Character)
		F1.Name = "Effects Folder"
		F2 = Instance.new("Folder", F1)
		F2.Name = "Effects"
		Triangle = function(a, b, c)
		end
		
		MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CanCollide = false
		  prt.CFrame = cframe
		  prt.Name = "prt"
		  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Block1", delay, x3, y3, z3})
		end
		
		
		
		MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CanCollide = false
		  prt.CFrame = cframe
		  prt.Name = "prt"
		  local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3})
		end
		
		MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CFrame = cframe
		  local msh = mesh("SpecialMesh", prt, "FileMesh", "http://www.roblox.com/asset/?id=20329976", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3})
		end
		
		MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt(0.2, 0.2, 0.2))
		  prt.Anchored = true
		  prt.CFrame = cframe
		  msh = mesh("SpecialMesh", prt, "Head", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  Effects[#Effects + 1] = {prt, "Cylinder", delay, x3, y3, z3}
		end
		
		MagicCylinder2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt(0.2, 0.2, 0.2))
		  prt.Anchored = true
		  prt.CFrame = cframe
		  msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  Effects[#Effects + 1] = {prt, "Cylinder", delay, x3, y3, z3}
		end
		
		MagicBlood = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CFrame = cframe
		  local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Blood", delay, x3, y3, z3})
		end
		
		ElecEffect = function(cff, x, y, z)
		  local prt = part(3, F2, 0, 0, BrickColor.new("Dark indigo"), "Part", vt(1, 1, 1))
		  prt.Anchored = true
		  prt.CFrame = cff * cf(math.random(-x, x), math.random(-y, y), math.random(-z, z))
		  prt.CFrame = cf(prt.Position)
		  game:GetService("Debris"):AddItem(prt, 2)
		  xval = math.random() / 2
		  yval = math.random() / 2
		  zval = math.random() / 2
		  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(xval, yval, zval))
		  Effects[#Effects + 1] = {prt, "Elec", 0.1, x, y, z, xval, yval, zval}
		end
		
		function FindNearestTorso(Position, Distance, SinglePlayer)
			if SinglePlayer then
				return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
			end
			local List = {}
			for i, v in pairs(workspace:GetChildren()) do
				if v:IsA("Model") then
					if v:findFirstChild("Torso") then
						if v ~= Character then
							if (v.Torso.Position - Position).magnitude <= Distance then
								table.insert(List, v)
							end 
						end 
					end 
				end 
			end
			return List
		end
		
		
		function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end
	
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh){
		Parent = Part,
		Offset = OffSet,
		Scale = Scale,
	}
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
		
		
		
function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {
			prt,
			"Block1",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 2 then
		table.insert(Effects, {
			prt,
			"Block2",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
end

function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay,material)
local prt=CreatePart(workspace,material,0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh,num) 
for i=0,1,delay do
swait()
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,(math.random(0,1)+math.random())/5)
end

function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end


function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function BreakEffect(brickcolor, cframe, x1, y1, z1)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	local num = math.random(10, 50) / 1000
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Shatter",
		num,
		prt.CFrame,
		math.random() - math.random(),
		0,
		math.random(50, 100) / 100
	})
end
		
		local lerp = function(a, b, t)
	return a * (1 - t) + b * t
end
		
		function clerp(a,b,t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1-t
		return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t))
		end
		 
		function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5/s
		return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5
		else
		local i = 0
		if m11 > m00 then
		i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
		i = 2
		end
		if i == 0 then
		local s = math.sqrt(m00-m11-m22+1)
		local recip = 0.5/s
		return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip
		elseif i == 1 then
		local s = math.sqrt(m11-m22-m00+1)
		local recip = 0.5/s
		return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip
		elseif i == 2 then
		local s = math.sqrt(m22-m00-m11+1)
		local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip
		end
		end
		end
		

		function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w*xs, w*ys, w*zs
		local xx = x*xs
		local xy = x*ys
		local xz = x*zs
		local yy = y*ys
		local yz = y*zs
		local zz = z*zs
		return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy))
		end
		function QuaternionSlerp(a, b, t)
		local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
		local theta = math.acos(cosTheta)
		local invSinTheta = 1/math.sin(theta)
		startInterp = math.sin((1-t)*theta)*invSinTheta
		finishInterp = math.sin(t*theta)*invSinTheta  
		else
		startInterp = 1-t
		finishInterp = t
		end
		else
		if (1+cosTheta) > 0.0001 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1/math.sin(theta)
		startInterp = math.sin((t-1)*theta)*invSinTheta
		finishInterp = math.sin(t*theta)*invSinTheta
		else
		startInterp = t-1
		finishInterp = t
		end
		end
		return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp
		end
		 
		function weld5(part0, part1, c0, c1)
		    weeld=Instance.new("Weld", part0)
		    weeld.Part0=part0
		    weeld.Part1=part1
		    weeld.C0=c0
		    weeld.C1=c1
		    return weeld
		end
		 
		--Example: Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
		 
		function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
	end
	
	
	



Character.Humanoid.MaxHealth = 120
Character.Humanoid.Health = 120
 
 local f = 0
 local b = Instance.new("BlurEffect",cam)
local    c = Instance.new('PointLight', Torso)
c.Range = 16
c.Color = Color3.new(0, 1,1)
c.Brightness = 1.5
 game:GetService("RunService"):BindToRenderStep("W0tT", 0, function()

b.Size = b.Size - 4
if boost == true then
c.Enabled = true
    cam.FieldOfView = lerp(cam.FieldOfView, 110, 0.5)
   -- cam.FieldOfView = 110
    freefall = 0
    Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,3),0.25)
 SphereEffect(BrickColor.new("Cyan"),RightLeg.CFrame*CFrame.new(0,-1,0)*angles(math.random(-180,180),math.random(-180,180),math.random(-180,180)),1.4,12,1.4,2.8,26,2.8,0.07)
  SphereEffect(BrickColor.new("Cyan"),LeftLeg.CFrame*CFrame.new(0,-1,0)*angles(math.random(-180,180),math.random(-180,180),math.random(-180,180)),1.4,12,1.4,2.8,26,2.8,0.07)
  if hitfloor ~= nil and Anim ~= "runIdle" then
  SpecialEffect(BrickColor.new("Cyan"),RootPart.CFrame*CFrame.new(0,-3.4,.78) ,2,2,2, 1.5,1.5,1.5,.09)
  end
end
if boost == false then
    cam.FieldOfView = lerp(cam.FieldOfView, 70, 0.076)
    --cam.FieldOfView = 70
    c.Enabled = false
end
end)



						 mouse.KeyDown:connect(function(key)
    if string.byte(key) == 48 then
        b.Size = 40
		Swing = 2
		freefall = 0
		
coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))
        Humanoid.WalkSpeed = 180
        RootPart.Velocity = RootPart.CFrame.lookVector*150
        RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-9.2) , 1, 1, 1, 8, 8, 8, 0.14,"Neon") 
        boost = true
        boostsound:Play()
end
end)

mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
		Swing = 1
        Humanoid.WalkSpeed = 64
        boost = false
        boostsound:Stop()

end
end)




						 mouse.KeyDown:connect(function(key)
    if string.byte(key) == 50 then
        b.Size = 40
        freefall = 0
		Swing = 2
		
coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.35*2.8,0.35*2.8),math.random(-0.35*2.8,0.35*2.8),math.random(-0.35*2.8,0.35*2.8)),0.48)
end
end))
		
        Humanoid.WalkSpeed = 320
        RootPart.Velocity = RootPart.CFrame.lookVector*550
        RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-9.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
        RingEffect(BrickColor.new("White"), RootPart.CFrame*CFrame.new(0,0,-11.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
        RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-13.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
        boost = true
        boostsound:Play()
end
end)

mouse.KeyUp:connect(function(key)
    if string.byte(key) == 50 then
		Swing = 1
        Humanoid.WalkSpeed = 64
        boost = false
        boostsound:Stop()

end
end)


local lastwall = nil
local jumped = false



		 
		 
		 
		 local vwall = false
		 
		 		 mouse.KeyDown:connect(function(key)
		     if key == 'b' and hitfloor == nil and attack == false then
	vrun()
end
 end)
 
 
 function vrun()
     		 	local ray = Ray.new(
		RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
	)
	local hit, position, normal = workspace:FindPartOnRay(ray, character)
	
	if hit then
	    if hit.Parent.Parent ~= Character and hit.Parent ~= Character and hit.Name ~= "prt" and hit.CanCollide == true then
	    vwall = true
	        local NV = Vector3.new(0,0,0)
	             local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
 local GravPoint = RootPart.Velocity.y
		local velo = Instance.new("BodyVelocity",Torso)
		velo.MaxForce = Vector3.new(400000,400000,400000)

		attack = true
while vwall == true and ray and hit do
swait()
change = 0.84+ Humanoid.WalkSpeed/132
if Humanoid.WalkSpeed > 40 and Humanoid.WalkSpeed < 70 then
velo.Velocity =  Vector3.new(0,40,0)
end
if Humanoid.WalkSpeed > 70 and Humanoid.WalkSpeed < 200 then
		velo.Velocity =  Vector3.new(0,80,0)
		end
		if Humanoid.WalkSpeed > 200 then
		velo.Velocity =  Vector3.new(0,130,0)
		end
		 ray = Ray.new(
		RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
	)
	hit, position, normal = workspace:FindPartOnRay(ray, character)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/2), .6) * angles(math.rad(96), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+20*math.sin(sine/2)),math.rad(0),math.rad(0+5*math.sin(sine/4)) + RootPart.RotVelocity.Y / 13),.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.1) * angles(math.rad(-90-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(15+2*math.sin(sine/4))- RootPart.RotVelocity.Y / 34),.15)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.1)*angles(math.rad(-90-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-15+2*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34),.15)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.28*math.cos(sine/4), 0-0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0+104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.3+ Humanoid.WalkSpeed/272)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.28*math.cos(sine/4),0+0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0-104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.3+ Humanoid.WalkSpeed/272)
end
		velo:Destroy()
		wait(0.07)

if vwall == false then

 RootPart.Velocity = -RootPart.CFrame.lookVector*68 + Vector3.new(0,86,0)

--[[]
		for i = 0,5,0.2 do
rs:wait()
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.79, 0) * CFrame.Angles(math.rad(0+100*i), math.rad(0), math.rad(0)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(0)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(180), math.rad(-60), math.rad(40)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(180), math.rad(60), math.rad(-40)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
end
]]


for i = 0,4,0.1 do
swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
end

 		attack = false


end


		if vwall == true then
 RootPart.Velocity = RootPart.CFrame.lookVector*38 + Vector3.new(0,86,0)

--[[]
		for i = 0,5,0.2 do
rs:wait()
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.79, 0) * CFrame.Angles(math.rad(0+100*i), math.rad(0), math.rad(0)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(0)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(180), math.rad(-60), math.rad(40)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(180), math.rad(60), math.rad(-40)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
end
]]


for i = 0,4,0.15 do
swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0-260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
end

 		attack = false

end


end
end
end
 
 

 
 	 mouse.KeyUp:connect(function(key)
		     if key == 'b' and vwall == true then
	         vwall = false
	         end
	         end)
		 


		 
		 
function Ldash()
    
    

evadecooldown = true
attack = true
k = math.random(1,2) 
if k == 1 then
so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
else
 so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
 end
 
 
 


 --+173.8*i
for i = 0,.7,0.1 do
swait()
Head.Velocity = Head.CFrame.rightVector * -135
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(32)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(-9),math.rad(-14)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.2) * angles(math.rad(27), math.rad(0), math.rad(30)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(30)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(12)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(8)), 0.2)
end

attack = false
wait(0.08)
evadecooldown = false
 
 
end





function Rdash()
    
    

evadecooldown = true
attack = true
k = math.random(1,2) 
if k == 1 then
so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
else
 so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
 end
 
 
 
 

 --+173.8*i
for i = 0,.7,0.1 do
swait()
Head.Velocity = Head.CFrame.rightVector * 135
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-32)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(9),math.rad(14)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(-30)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.2) * angles(math.rad(27), math.rad(0), math.rad(-30)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-8)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-12)), 0.2)
end

attack = false
wait(0.08)
evadecooldown = false
 
 
end
local sliding = false


function Slide()
    
     local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
     spd = spd + 30
local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
 local GravPoint = RootPart.Velocity.y
 if spd > 40 and hitfloor ~= nil then
noleg = true

attack = true
k = math.random(1,2) 
if k == 1 then
so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
else
 so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
 end
 
 
 

 
 
 

 
 
 local NV = Vector3.new(0,0,0)
local bv = Instance.new("BodyVelocity", Torso)
bv.maxForce = Vector3.new(1/0,1/0,1/0)
bv.velocity = dir*spd
	        local bg = Instance.new("BodyGyro", Torso)
bg.maxTorque = Vector3.new(1/0,1/0,1/0)
bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)
Head.Running.SoundId = "rbxassetid://1295468446"
Head.Running.TimePosition = 0

Humanoid.PlatformStand = true
while spd > 2 and hitfloor ~= nil and sliding == true do
swait()
spd = spd - 0.95
bv.velocity = dir*spd + Vector3.new(0,0,0)
bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -2.3, 0) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(12)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(34),math.rad(0),math.rad(12)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(110), math.rad(0), math.rad(70)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.2) * angles(math.rad(0), math.rad(0), math.rad(-60)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -0.56, -0.2) * CFrame.Angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
end
bv:Destroy()
bg:Destroy()
Head.Running.SoundId = "rbxassetid://758199523"
Head.Running.TimePosition = 0
Humanoid.PlatformStand = false
attack = false
sliding = false
wait(0.05)
evadecooldown = false
 
 
end
end

function land()
    attack = true
   RootPart.Velocity = Vector3.new(0,0,0)
    WaveEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,-1,0) , 1, 1, 1, 3, 0.8, 3, 0.06) 
     so("http://www.roblox.com/asset/?id=1295424585", Torso, 3.5, 1)

coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.55*2.8,0.55*2.8),math.random(-0.55*2.8,0.55*2.8),math.random(-0.55*2.8,0.55*2.8)),0.44)
        Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -2, 0) * CFrame.Angles(math.rad(-16), math.rad(0), math.rad(0)), 0.5)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(7),math.rad(0),math.rad(0)),.5)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(87)),.5)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0) * angles(math.rad(0), math.rad(0), math.rad(-87)),.5)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, 0, -0.5) * CFrame.Angles(math.rad(16), math.rad(0), math.rad(0)), 0.5)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1.14, 0.2) * CFrame.Angles(math.rad(-17), math.rad(0), math.rad(0)), 0.5)
       
end
attack = false


end))



end




function stomp()
    attack = true
    stompsound:Play()
    
   while hitfloor == nil do 
       swait()
       b.Size = 12
        WaveEffect(BrickColor.new("Cyan"), LeftLeg.CFrame*CFrame.new(0,-2.4,0) , 1, 1, 1, 0.8, 0.8, 0.8, 0.14) 
       RootPart.Velocity = Vector3.new(0,RootPart.Velocity.y/1.6,0) +Vector3.new(0,-150,0)
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(0+4*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(140+12*math.cos(sine/1.3))), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(-140+12*math.cos(sine/1.3))), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(60+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3), -0.13) * CFrame.Angles(math.rad(0+4*math.cos(sine/1.3)), math.rad(3), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, .27+0.17*math.cos(sine/1.3), -0.56) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(0), math.rad(0)), 0.1)

end
 stompsound:Stop()
land()


end


function changemusic()
    musicnum = musicnum + 1
    music.TimePosition = 0
    local osix = false
    local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude
    if musicnum > 14 then
        musicnum = 1
    end
    if musicnum == 1 then
        music.SoundId = "rbxassetid://179029173"
    end
    if musicnum == 2 then
        music.SoundId = "rbxassetid://146443855"
        end
        if musicnum == 3 then
           music.SoundId = "rbxassetid://1342408291" 
          end
          if musicnum == 4 then
            music.SoundId = "rbxassetid://201219416"  
        end
        if musicnum == 5 then
music.SoundId = "rbxassetid://1390472571" 
end
        if musicnum == 6 then
            osix = true
music.SoundId = "rbxassetid://249974783" 
end
if musicnum == 7 then
    music.SoundId = "rbxassetid://1851880603"
end
if musicnum == 8 then
 music.SoundId = "rbxassetid://412034984"
end
if musicnum == 9 then
   music.SoundId = "rbxassetid://536915629"
end
if musicnum == 10 then
music.SoundId = "rbxassetid://1200005861"
end
if musicnum == 11 then
    music.SoundId = "rbxassetid://1055930631"
end
if musicnum == 12 then
    music.SoundId = "rbxassetid://300269553"
end
if musicnum == 13 then
    music.SoundId = "rbxassetid://199897052"
end
if musicnum == 14 then
  music.SoundId = "rbxassetid://638115895"  
end

if spd < 14 then
Humanoid.Jump = true

if osix == false then
so("rbxassetid://537371462",PlayerGui,2,1)
end


RootPart.Velocity = Vector3.new(0,102,0)
attack = true
wait(0.08)
for i = 0,7,0.1 do
    swait()
    RootPart.Velocity = Vector3.new(0,2,0)
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0-260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)

end
b.Size = 40
MoonEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,0) , 1, 1, 1, 8, 8, 8, 0.06) 

if osix == true then
osix = false
so("rbxassetid://156821036",PlayerGui,2,1)
end

Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -3, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 1)
for i = 0,5,0.1 do
    swait()
RootPart.Velocity = Vector3.new(0,3.5,0)
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1+0.1*i, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.21)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(22-2*i),math.rad(0),math.rad(0)),.21)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.09*i, 0) * angles(math.rad(20-6*i), math.rad(0), math.rad(90+13*i)), 0.21)
LW.C0 = clerp(LW.C0, CFrame.new(-1.0-0.12*i, 0.5, -0.4+0.05*i) * angles(math.rad(20+13*i), math.rad(0), math.rad(20-13*i)), 0.21)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(-22-4*i)), 0.21)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(22+4*i)), 0.21)
end
attack = false
end
end


  mouse.KeyDown:connect(function(key)
if key == 'q' and attack == false and evadecooldown == false then
Ldash()
end
end)
 
 
 
   mouse.KeyDown:connect(function(key)
if key == 'e' and attack == false and evadecooldown == false then
Rdash()
end
end)

   mouse.KeyDown:connect(function(key)
if key == 'c' and attack == false and evadecooldown == false and hitfloor ~= nil then
     sliding = true
Slide()
end
end)

   mouse.KeyDown:connect(function(key)
if key == 'c' and attack == false and hitfloor == nil then
     stomp()
end
end)


local walljump = false


function walljumpp()
    	local ray = Ray.new(
		Torso.CFrame.p, RootPart.CFrame.lookVector *5
	)
	local hit, position, normal = workspace:FindPartOnRay(ray, character)
	
	if hit then
	    if  hit.Parent.Parent ~= Character and hit.Parent ~= Character then
	    local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
	    GravPoint = 0
 	    freefall = 0
	    walljump = true 
	    Humanoid.AutoRotate = false
		local velo = Instance.new("BodyVelocity",Torso)
		velo.MaxForce = Vector3.new(400000,400000,400000)
		--game.Debris:AddItem(velo,0.1)
		attack = true
while hitfloor == nil and walljump == true and ray and hit  do
swait()
freefall = 0
GravPoint = GravPoint - 0.36
		 ray = Ray.new(
		RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
	)
	hit, position, normal = workspace:FindPartOnRay(ray, character)
velo.Velocity = vt(0,GravPoint,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.9) * CFrame.Angles(math.rad(5), math.rad(90), math.rad(8)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(7),math.rad(0),math.rad(86)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(120)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-60)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-6), math.rad(14), math.rad(-12)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(23)), 0.2)
end
if walljump == false then
    k = math.random(1,3) 
if k == 1 then
so("http://www.roblox.com/asset/?id=800121776", Head, 2.5, 1)
else if k == 2 then
 so("http://www.roblox.com/asset/?id=804889329", Head, 2.5, 1)
else if k == 3 then
     so("http://www.roblox.com/asset/?id=804907617", Head, 2.5, 1)
     end
     end
end
 
    velo:Destroy()
        attack = false
    coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
end
end))
    
    Humanoid.AutoRotate = true
    RootPart.Velocity = RootPart.CFrame.lookVector * -137 + Vector3.new(0,136,0)
    wait(0.07)
     RootPart.CFrame = CFrame.new(RootPart.CFrame.p,-RootPart.CFrame.lookVector)
end
if walljump == true then
 		attack = false
walljump = false
Humanoid.AutoRotate = true
velo:Destroy()
end
end
end
end

    
    local homed = nil
    function home()
        if walljump ~= true then
        		    	for i, v in pairs(FindNearestTorso(Torso.CFrame.p, 80)) do
				if v:FindFirstChild('Head') then
					Grabbed = true
					homed = v
				end
			end
    
    if homed ~= nil and homed:FindFirstChildOfClass("Humanoid").Health > 1 and walljump == false then
        					    so("http://www.roblox.com/asset/?id=162460823", Head, 1, .8)
        					    	   local SBall = Instance.new("Part",Character)
	SBall.Name = "Homing Ball"
	SBall.CanCollide = false
	SBall.Anchored = false
	SBall.Transparency = 0.64
	SBall.CFrame = CFrame.new(RootPart.CFrame.p)
	SBall.BrickColor = BrickColor.new("Toothpaste")
	SBall.Size = Vector3.new(1,1,1)
	SBall.Material = "Neon"
	SBallweld = Instance.new("Weld")
SBallweld.Parent = SBall
SBallweld.Part0 = RootPart
SBallweld.Part1 = SBall
SBallweld.C1 = CFrame.new(0, 1, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
        SBallweld.Part0 = RootPart
	local SBallmesh = Instance.new("SpecialMesh",SBall)
	SBallmesh.MeshType = "Sphere"
	SBallmesh.Scale = Vector3.new(6,6,6)
        	trail = Instance.new("Trail", Character)
a2 = Instance.new("Attachment", Torso) a2.Position = Vector3.new(0,2,0)
a3 = Instance.new("Attachment", Torso)a3.Position = Vector3.new(0,-2.5,0)
trail.Texture = "rbxassetid://0"
trail.Attachment0 = a2
trail.Attachment1 = a3
trail.Lifetime  =  0.353
trail.MinLength = 0.03
trail.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,1)})
trail.Color = ColorSequence.new(Color3.new(0,1,1), Color3.new(0, 0,0))
trail.LightEmission = 4.8
trail.TextureLength = 0.034
        trail.Enabled = true
 attack = true
	local position = Instance.new("BodyPosition",Torso)
	position.P = 68350
	position.maxForce = Vector3.new(math.huge,math.huge,math.huge)
	
        while homed ~= nil and (homed.Torso.Position-RootPart.Position).magnitude > 8 do
        swait()
        SBall.CFrame = CFrame.new(RootPart.CFrame.p)
    Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+420*math.abs(sine/3.2)), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
    position.Position = homed.Torso.Position + Vector3.new(0,2,0) 
end
		local bodvol=Instance.new("BodyVelocity")
bodvol.velocity= RootPart.CFrame.lookVector*240 + Vector3.new(0,30,0)
bodvol.P= 35200
bodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
bodvol.Parent=homed.Head
game:GetService("Debris"):AddItem(bodvol, 0.2)
homed:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(10,30))

position:Destroy()
trail.Enabled = false
SBall:Destroy()
RootPart.Velocity = Vector3.new(0,93.5,0)
    coroutine.resume(coroutine.create(function()
for i = 0,5,0.26 do
    swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1+0.1*i, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.21)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(22-2*i),math.rad(0),math.rad(0)),.21)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.09*i, 0) * angles(math.rad(20-6*i), math.rad(0), math.rad(90+13*i)), 0.21)
LW.C0 = clerp(LW.C0, CFrame.new(-1.0-0.12*i, 0.5, -0.4+0.05*i) * angles(math.rad(20+13*i), math.rad(0), math.rad(20-13*i)), 0.21)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(-22-4*i)), 0.21)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(22+4*i)), 0.21)
end
homed = nil
attack = false
end))

end
    
end


end











    










    
		 		 mouse.KeyDown:connect(function(key)
		 		     wait(0.16)
		     if string.byte(key) == 32 and hitfloor == nil and attack == false and walljump == false and Humanoid.Jump == true then
		 walljumpp()
	 end
	 		     if string.byte(key) == 32 and hitfloor == nil and attack == false and walljump == false and Humanoid.Jump == true then
		 home()
	 end
	 
if string.byte(key) == 32 and hitfloor == nil and attack == true and walljump == true then
walljump = false
end
	 end)
		 



   mouse.KeyDown:connect(function(key)
if key == 'm' and attack == false then
changemusic()
end
end)






   mouse.KeyUp:connect(function(key)
       wait(0.05)
if key == 'c' and sliding == true then
     sliding = false
end
end)
local look = 0



				while true do
    swait()
sine = sine + change
--speed = speed + music.PlaybackLoudness/90
local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
	
    local TiltVelocity = CFrame.new(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity))

local rlegray = Ray.new(RightLeg.Position+Vector3.new(0,0.54,0),Vector3.new(0, -1.75, 0))
local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, Character)

local llegray = Ray.new(LeftLeg.Position+Vector3.new(0,0.54,0),Vector3.new(0, -1.75, 0))
local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, Character)

    	local waterthing = Ray.new(RootPart.CFrame.p,Vector3.new(0,-1,0))
	local start, position = workspace:FindPartOnRay(waterthing, character)
	
	if start ~= nil and start.Material == "Water" then
	
    RootPart.Velocity = RootPart.Velocity + Vector3.new(0,6,0)
    
    end

if torvel<1  and Swing == 2 then
    boost = false
elseif torvel>1   and Swing == 2 then
    boost = true
    freefall = 0
end
if hitfloor ~= nil and freefall < 150 then
    freefall = 0
end
if freefall > 150 and hitfloor ~= nil then
land()
freefall = 0
end







		if RootPart.Velocity.y > 1 and hitfloor==nil then
Anim="Jump"





if attack==false then
change = 1
look = 0
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(4), math.rad(0), math.rad(0)), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10+2.05*math.cos(sine/5)),math.rad(0),math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20+2.05*math.cos(sine/5)), math.rad(-10), math.rad(50-2.05*math.cos(sine/5))), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20+2.05*math.cos(sine/5)), math.rad(-10), math.rad(-50+2.05*math.cos(sine/5))), 0.07)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, -0.6) * CFrame.Angles(math.rad(-25+3.05*math.cos(sine/5)), math.rad(-3), math.rad(0)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.47, -0.7) * CFrame.Angles(math.rad(-12+3.05*math.cos(sine/5)), math.rad(0), math.rad(0)), 0.1)
end

elseif RootPart.Velocity.y < -1 and freefall <150 and hitfloor==nil then
Anim="Fall"
change = 1
freefall = freefall +0.77


if attack==false then
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(7+4*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(140+12*math.cos(sine/1.3))), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(-140+12*math.cos(sine/1.3))), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(40+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3), -0.13) * CFrame.Angles(math.rad(18+7*math.cos(sine/1.3)), math.rad(3), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.37+0.17*math.cos(sine/1.3), -0.2) * CFrame.Angles(math.rad(32+7*math.cos(sine/1.3)), math.rad(0), math.rad(0)), 0.1)
end



elseif RootPart.Velocity.y < -1 and freefall > 150 and hitfloor==nil then
Anim="FreeFall"
change = 1


if attack==false then
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(-90+3*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(14+12*math.cos(sine/1.3)), math.rad(0), math.rad(110)), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(14+12*math.cos(sine/1.3)), math.rad(0), math.rad(-110)), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-12+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3),0.2) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(3), math.rad(-46)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.17*math.cos(sine/1.3), 0.2) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(0), math.rad(46)), 0.1)
end

elseif torvel<1 and hitfloor~=nil then
Anim="Idle"
change = 1
if attack==false and equip == false then
  
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.04*math.cos(sine/40), -0) * CFrame.Angles(math.rad(0-0.81*math.cos(sine/40)), math.rad(-40), math.rad(0)), 0.1)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0+2.6*math.sin(sine/40)),math.rad(0),math.rad(40)),0.1)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.55+0.04*math.sin(sine/40), 0-0.04*math.cos(sine/40)) * angles(math.rad(-2+1.3*math.cos(sine/40)), math.rad(0+4*math.sin(sine/40)), math.rad(6.3+2.2*math.cos(sine/40))),0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.55+0.04*math.sin(sine/40), 0-0.04*math.cos(sine/40)) * angles(math.rad(2+1.3*math.cos(sine/40)), math.rad(0-4*math.sin(sine/40)), math.rad(-6.3-2.2*math.cos(sine/40))),0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, llegendPoint.Y-LeftLeg.Position.Y+0.04*math.cos(sine/40), 0) * CFrame.Angles(math.rad(0+0.81*math.cos(sine/40)), math.rad(18+0.81*math.cos(sine/40)), math.rad(-2-0.81*math.cos(sine/40))),0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.57, rlegendPoint.Y-RightLeg.Position.Y+0.04*math.cos(sine/40), 0)  * CFrame.Angles(math.rad(0+0.81*math.cos(sine/40)), math.rad(-2+0.81*math.cos(sine/40)), math.rad(3-0.81*math.cos(sine/40))),0.1)
end


	
elseif torvel>1.5 and torvel<70 and hitfloor~=nil then
Anim="Walk"
change = 0.84+ Character.Humanoid.WalkSpeed/132
look = 0
if attack==false and equip == false then
					       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/2), -.8) * angles(math.rad(-26), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+20*math.sin(sine/2)),math.rad(0),math.rad(0+5*math.sin(sine/4)) + RootPart.RotVelocity.Y / 13),.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.1) * angles(math.rad(-60-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(15+2*math.sin(sine/4))- RootPart.RotVelocity.Y / 34),.15)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.1)*angles(math.rad(-60-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-15+2*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34),.15)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.28*math.cos(sine/4), 0-0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0+104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.3)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.28*math.cos(sine/4),0+0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0-104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.3)
end


		elseif torvel>=70 and torvel<200 and hitfloor~=nil then
		Anim="Run"
		change = 0.84+ Character.Humanoid.WalkSpeed/142
		if attack==false and equip == false then
					       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/1.5), -.8) * angles(math.rad(-37), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+25*math.sin(sine/1.5)),math.rad(0),math.rad(0+5*math.sin(sine/3)) + RootPart.RotVelocity.Y / 13),.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.3) * angles(math.rad(-72-8*math.sin(sine/1.5))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(1+0*math.cos(sine/3))- RootPart.RotVelocity.Y / 34),.25)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.3)*angles(math.rad(-72-8*math.sin(sine/1.5))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-1+0*math.cos(sine/3))+ RootPart.RotVelocity.Y / -34),.25)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.32*math.cos(sine/3), 0-0.42*math.cos(sine/3)) * CFrame.Angles(math.rad(0+134*math.sin(sine/3)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.44)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.32*math.cos(sine/3),0+0.42*math.cos(sine/3)) * CFrame.Angles(math.rad(0-134*math.sin(sine/3)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.44)
		end
		
		--[[
		if attack==false then
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1-0.4*math.cos(sine/5.5)/2, 0 *math.sin(sine/6.6)/2) * CFrame.Angles(math.rad(0) + -math.sin(sine/5.5)/1.2, math.rad(0), 0), .8)
		RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.4*math.cos(sine/5.5)/2,0 *-math.sin(sine/6.6)/2) * CFrame.Angles(math.rad(0) + math.sin(sine/5.5)/1.2, math.rad(0), 0), .8)
		end
		]]
		if attack==true and noleg == false then
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1-0.24*math.cos(sine/5), 0.+0.24*math.cos(sine/5)) * CFrame.Angles(math.rad(0-74*math.sin(sine/5)), math.rad(0), math.rad(0)), 0.3)
		   RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.24*math.cos(sine/5),0.-0.24*math.cos(sine/5)) * CFrame.Angles(math.rad(0+74*math.sin(sine/5)), math.rad(0), math.rad(0)), 0.3)
		end
		
		
		
				elseif torvel>=200 and hitfloor~=nil then
		Anim="MachRun"
		change = 0.84+ Character.Humanoid.WalkSpeed/182
		if attack==false and equip == false then
					       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/1), -3.8) * angles(math.rad(-44), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .2)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+25*math.sin(sine/1)),math.rad(0),math.rad(0+5*math.sin(sine/2)) + RootPart.RotVelocity.Y / 13),.2)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.5) * angles(math.rad(-78-12*math.sin(sine/1))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(-24+0*math.cos(sine/2))- RootPart.RotVelocity.Y / 34),.35)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.5)*angles(math.rad(-78-12*math.sin(sine/1))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(24+0*math.cos(sine/2))+ RootPart.RotVelocity.Y / -34),.35)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.42*math.cos(sine/2), 0-0.62*math.cos(sine/2)) * CFrame.Angles(math.rad(0+134*math.sin(sine/2)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.52)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.42*math.cos(sine/2),0+0.62*math.cos(sine/2)) * CFrame.Angles(math.rad(0-134*math.sin(sine/2)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.52)
		end
		
		

end









 if 0 < #Effects then
      for e = 1, #Effects do
        if Effects[e] ~= nil then
          local Thing = Effects[e]
          if Thing ~= nil then
            local Part = Thing[1]
            local Mode = Thing[2]
            local Delay = Thing[3]
            local IncX = Thing[4]
            local IncY = Thing[5]
            local IncZ = Thing[6]
            if Thing[1].Transparency <= 1 then
              if Thing[2] == "Block1" then
                Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                Mesh = Thing[1]:FindFirstChild("Mesh")
                if not Mesh then
                  Mesh = Instance.new("BlockMesh")
                end
                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
              elseif Thing[2] == "Cylinder" then
                  Mesh = Thing[1]:FindFirstChild("Mesh")
                  if not Mesh then
                    Mesh = Instance.new("BlockMesh")
                  end
                  Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                elseif Thing[2] == "Blood" then
                    Mesh = Thing[1]:FindFirstChild("Mesh")
                    if not Mesh then
                      Mesh = Instance.new("BlockMesh")
                    end
                    Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
                    Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                    Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                  elseif Thing[2] == "Elec" then
                      Mesh = Thing[1]:FindFirstChild("Mesh")
                      if not Mesh then
                        Mesh = Instance.new("BlockMesh")
                      end
                      Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                    elseif Thing[2] == "Disappear" then
                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                      end
            else
              Part.Parent = nil
              game:GetService("Debris"):AddItem(Part, 0)
              table.remove(Effects, e)
            end
          end
        end
      end
    end

end
local basetpart = game.workspace.non:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end
end







end)

-- end chat command
Mouse.KeyDown:connect(function(Key)
	if Key == prefix then
		BAR:CaptureFocus()
	end
end)

BAR.FocusLost:connect(function(enterPressed)
	if enterPressed then
	if string.sub(BAR.Text, 1, 6) == ("hammer") then
			

Bypass = "death"
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)




local pee = game.Players.LocalPlayer.Character["MARTILLO"]
local gold = game.Players.LocalPlayer.Character["MARTILLO"].Handle
gold.AccessoryWeld:Destroy()




local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = gold
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true

attachment1.CFrame = CFrame.Angles(-25.7,5,20) 
  attachment0.CFrame = CFrame.new(1,-3,-.1)
  
  




  
  ----fling attachments
  
 
--  local toolgoflingfling = Instance.new("BodyVelocity", gold)
--toolgoflingfling.MaxForce = Vector3.new(90000,90000,90000)
--toolgoflingfling.Velocity = Vector3.new(90000,90000,90000)

  

wait(0.1)

warn([[Have fun with sangWARE!]])

--loadstring(game:GetObjects("rbxassetid://4480871791")[1].Source)()
--wait(5)

-- 5325226148
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(0.1)



playerss = workspace.non

local ToolName = pee

Bypass = "death"


local IsDead = false
local StateMover = true



Bypass = "death"
plr = game.Players.LocalPlayer
--dead = false
char = plr.Character



wait(4)




--



-- game:GetService("Workspace").GoldAxe.Handle.Rotation = Vector3.new(-0,0,-50)


 --local lol = Instance.new("Attachment",Right Arm)

--The reality of my life isn't real but a Universe -makhail07
wait()
local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name)
print('God Loaded')
print('hahahAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')
char = playerss
local hum = char.Humanoid
local hed = char.Head
local lol = Instance.new("Attachment",char["Right Arm"])
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")



function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end

function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end






-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end


function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end


local kan = Instance.new("Sound",char)
kan.Volume = 1.25
kan.TimePosition = 0
kan.PlaybackSpeed = 1
kan.Pitch = 1
kan.SoundId = "rbxassetid://853707984"
kan.Name = "wrecked"
kan.Looped = true
kan:Play()

local currentThemePlaying = kan.SoundId
local currentPitch = kan.Pitch
local currentVol = kan.Volume
function newTheme(ID,timepos,pitch,vol)
local kanz = kan
--kanz:Stop()
kanz.Volume = vol
--kanz.TimePosition = timepos
kanz.PlaybackSpeed = pitch
kanz.Pitch = pitch
kanz.SoundId = ID
kanz.Name = "wrecked"
kanz.Looped = true
currentThemePlaying = kanz.SoundId
currentVol = kanz.Volume
currentPitch = kanz.Pitch
--kanz:Play()
--coroutine.resume(coroutine.create(function()
--wait(0.05)
--end))
end

--newTheme("rbxassetid://853707984",0,1.01,0.85)

function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end


--local RbxUtility = LoadLibrary("RbxUtility")
--local Create = RbxUtility.Create

local function Create(A)
local A = Instance.new(A)
return function(B)
for i,v in pairs(B) do
A[i] = v
end
return A
end
end
-------------------------------------------------------
-----------------------hammer--------------------------
---- WEAPON OR STUFF
local rarmor = CreateParta(m,1,0,"SmoothPlastic",BrickColor.Random())
----local weaponweld = CreateWeld(rarmor,tors,rarmor,-3,0,-0.5,math.rad(0),math.rad(0),math.rad(-40),0,0,0,math.rad(0),math.rad(0),math.rad(0))
--local MainWeldS = CreateWeld(Part475,rarmor,Part475,0,0,0,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local A0 = Instance.new("Attachment",rarmor)
local A1 = Instance.new("Attachment",rarmor)
tl1 = Instance.new('Trail',rarmor)
tl1.Attachment0 = A0
tl1.Attachment1 = A1
tl1.LightEmission = 1
tl1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
tl1.Lifetime = 0.6
tl1.Enabled = false


rarmor.Attachment.Name = "Attachment2"


-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
    --    if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
 --       hit.Parent:FindFirstChild("Head"):BreakJoints()
  --     end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
   --     if insta == true then
--      hit.Parent:FindFirstChild("Head"):BreakJoints()
  --      end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:service("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end


function Eviscerate(dude)
	if dude.Name ~= char then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
	--	d//ude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
				end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
					v:Destroy()
				end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
					for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
							o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							v.Color = maincolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.08
								end
								wait(0.5)
								PartEmmit1.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
function chatfunc(text, color)
	local chat = coroutine.wrap(function()
		if char:FindFirstChild("TalkingBillBoard") ~= nil then
			char:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local naeeym2 = Instance.new("BillboardGui", char)
		naeeym2.Size = UDim2.new(0, 100, 0, 40)
		naeeym2.StudsOffset = Vector3.new(0, 5, 0)
		naeeym2.Adornee = hed
		naeeym2.Name = "TalkingBillBoard"
		local tecks2 = Instance.new("TextLabel", naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SciFi"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 0
		tecks2.TextColor3 = color
		tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
		tecks2.Size = UDim2.new(1, 0, 0.5, 0)
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
				tecks2.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
				tecks2.Rotation = math.random(-5, 5)
			end
		end))
		for i = 1, string.len(text) do
			CFuncs.Sound.Create("rbxassetid://274118116", hed, 5.25, 0.115)
			tecks2.Text = string.sub(text, 1, i)
			swait(1)
		end
		wait(1)
		naeeym2:Destroy()
	end)
	chat()
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 703597239
local SONG2 = 853707984
local Music = Instance.new("Sound",tors)
Music.Volume = 2.5
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
----------------------------------------------------------------------------------
hum.WalkSpeed = 16
hum.JumpPower = 57
hum.Animator.Parent = nil
----------------------------------------------------------------------------------
--local Blobby = Instance.new("Part", char)
--Blobby.Name = "Blob"
--Blobby.CanCollide = false
--Blobby.BrickColor = BrickColor.new("Really black")
--Blobby.Transparency = 0
--Blobby.Material = "Plastic"
--Blobby.Size = Vector3.new(1, 1, 2)
--Blobby.TopSurface = Enum.SurfaceType.Smooth
--Blobby.BottomSurface = Enum.SurfaceType.Smooth

--local Weld = Instance.new("Weld", Blobby)
--Weld.Part0 = ra
--Weld.Part1 = Blobby
--Weld.C1 = CFrame.new(0, -2, 1.1)
--Weld.C0 = CFrame.Angles(Rad(-86),0,0)

--local M2 = Instance.new("SpecialMesh")
--M2.Parent = Blobby
--M2.MeshId = "http://www.roblox.com/asset/?id=10604848"
--M2.TextureId = "http://www.roblox.com/asset/?id=10605252"
--M2.Scale = Vector3.new(1, 1, 1)

--[[local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0, 3.5, 0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"
--naeeym2.PlayerToHideFrom = Player
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Fight Me"
tecks2.Font = Enum.Font.Bodoni
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(0, 0, 0)
tecks2.TextStrokeColor3 = Color3.new(1, 1, 1)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2]]
-------------------------------------------------------
--End Customization--
-------------------------------------------------------


-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
function Ban()
	attack = true
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
 --	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 9.5)) do
--		if v:FindFirstChild("Head") then
--			Eviscerate(v)
--		end
--	end
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
	attack = false
end
function BigBan()
	attack = true
--	Weld.C0 = CFrame.Angles(Rad(-90), Rad(-25), Rad(0))
	for i = 0, 3.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-6), Rad(45)), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
 --	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 14.5)) do
--		if v:FindFirstChild("Head") then
--			Eviscerate(v)
---		end
--	end
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(75), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-6), Rad(45)), 0.2)
	end
--	Weld.C0 = CFrame.Angles(Rad(-86),0,0)
	attack = false
end
function BANN()
	attack = true
--	M2.Scale = Vector3.new(2, 2, 2)
	for i = 0, 4.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(-20)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(.6* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-.8* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(156), Rad(-.6), Rad(45)), 0.2)
	end
	Cso("147722910", char, 10, 1)
	CameraEnshaking(2, 35)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
	Effects.Ring.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0) * angles(math.rad(90), math.rad(0), math.rad(0)), 0.5, 0.5, 0.1, 2, 2, 0, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 7, 10, 15, -0.1, 15, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 6, 10, 15, -0.1, 15, 0.02)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 4, 10, 15, -0.1, 15, 0.01)
 --	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 19.5)) do
--		if v:FindFirstChild("Head") then
--			Eviscerate(v)
--		end
--	end
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
--	M2.Scale = Vector3.new(1, 1, 1)
	attack = false
end


-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------

game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(k)
   -- if string.byte(key) == 48 then
   Swing = 2
     hum.WalkSpeed = 38.82
--	end
end)
mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 1
        hum.WalkSpeed = 16
	end
end)
mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 'e' then
			BigBan()
		elseif key == 'r' then
			BANN()
		elseif key == 't' then
			Cso("1450018171", hed, 10, 1)
		end
	end
end)
mouse.Button1Down:connect(function(key)
    

    
    
	if attack == false then
		Ban()
	end
end)
 






-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		--Aura(5, 0.15, "Add", root.CFrame * CFrame.new(math.random(-5, 5), -10, math.random(-5, 5)) * CFrame.Angles(math.rad(90), 0, 0), 1.5, 1.5, 10, -0.015, maincolor, 0, "Sphere")
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(190), Rad(-.6), Rad(13)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel > 2 and torvel < 25 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(6 - 6.5 * Sin(sine / 7)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8* Player_Size - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8* Player_Size + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(190) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-37)  * Cos(sine / 7) , Rad(8 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
			end
		elseif torvel >= 25 and hitfloor ~= nil then
			Anim = "Sprint"
			change = 1.35
			if attack == false then
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
			RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925* Player_Size - 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         	LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925* Player_Size + 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(215) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-75) , Rad(8 * Cos(sine / 7)) ,	Rad(-13) + la.RotVelocity.Y / 75), 0.15)
			end
		end
	end
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 1.5
	Music.Parent = tors
	Music:Resume()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
	end
	if string.sub(BAR.Text, 1, 7) == ("shotgun") then
			
--//====================================================\\--
--||			   CREATED BY SHACKLUSTER shotgun script
--\\====================================================//--
--repeat wait() until script:WaitForChild'Owner'.Value

wait(0.1)

Bypass = "death"
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
        sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
        sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


local shottie = game.Players.LocalPlayer.Character["Type-12Accessory"].Handle
shottie.AccessoryWeld:Destroy()
shottie.BodyBackAttachment:Destroy()


local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = shottie
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true


attachment0.CFrame = CFrame.new(0.3,1.9,-.1)
attachment1.CFrame = CFrame.Angles(4,1.7,-10) 


loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(1)



	
wait(0.2)
Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = workspace.non
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local MOUSEPOS = RootPart.Position
local TIME = 0
local sick = Instance.new("Sound",Torso)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 3
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Type = "Ban"
local reason = "Ur damn skids nigga"
local Rooted = false
local SINE = 0
local SIZE = 1
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "BanishV3Gui"
local Characterb = IT("Model")
Characterb.Name = "shackisgaylol"
local CharacterA = IT("Model")
CharacterA.Name = "shackismegagaylol"
local Effects = IT("Folder", CharacterA)
Effects.Name = "Effects"
local Effects2 = IT("Folder", Characterb)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true
local TOBANISH = {}
script.Parent = PlayerGui

--//=================================\\
--\\=================================//


--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

local BODY = {}
for _, c in pairs(Character:GetDescendants()) do
	if c:IsA("BasePart") and c.Name ~= "Handle" then
		if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency})
	elseif c:IsA("JointInstance") then
		table.insert(BODY,{c,c.Parent,nil,nil,nil})
	end
end
for e = 1, #BODY do
	if BODY[e] ~= nil then
		local STUFF = BODY[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
		if PART.ClassName == "Part" and PART ~= RootPart then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)
	end
end

function refit()
	Character.Parent = workspace
	for e = 1, #BODY do
		if BODY[e] ~= nil then
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART:IsA("BasePart") and PART ~= RootPart then
				PART.Material = MATERIAL
				PART.Color = COLOR
				PART.Transparency = TRANSPARENCY+EXTRATRANS
			end
			if PART.Parent ~= PARENT then
				Humanoid:remove()
				PART.Parent = PARENT
				Humanoid = IT("Humanoid",Character)
			end
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end


function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "White", "Trail", VT(0,0,0))
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(0.5,DIST,0.5)
	else
		TRAIL.Size = VT(0.25,DIST,0.25)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.1
		end
		TRAIL:remove()
	end))
end

function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MagicSphereCo(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MagicBlock(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "ForceField", 0, 0.5, BRICKC(COLOR), "Effect", VT(SIZE,SIZE,SIZE), true)
	local mesh = IT("BlockMesh",wave)
	wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function CreateRing(SIZE, DOESROT, ROT, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
	local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "559831844", "", SIZE, VT(0, 0, 0))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
			end
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

local DECAL = IT("Decal")
function MagicRing()
	local RING = CreatePart(3, Effects, "Granite", 0, 1, "Maroon", "MagicRing", VT(0,0,0),true)
	local MESH = IT("BlockMesh",RING)
	local BOTTOMTEXTURE = DECAL:Clone()
	BOTTOMTEXTURE.Parent = RING
	BOTTOMTEXTURE.Face = "Bottom"
	BOTTOMTEXTURE.Name = "BottomTexture"
	local TOPTEXTURE = DECAL:Clone()
	TOPTEXTURE.Parent = RING
	TOPTEXTURE.Face = "Top"
	TOPTEXTURE.Name = "TopTexture"
	BOTTOMTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	TOPTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	BOTTOMTEXTURE.Color3 = C3(0,0,0)
	TOPTEXTURE.Color3 = C3(1,1,1)
	return RING,MESH,TOPTEXTURE,BOTTOMTEXTURE
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

--function SHAKECAM(POSITION, RANGE, INTENSITY, TIME)
--	local CHILDREN = workspace:GetDescendants()
--	for index, CHILD in pairs(CHILDREN) do
--		if CHILD.ClassName == "Model" then
	--		local HUM = CHILD:FindFirstChildOfClass("Humanoid")
		--	if HUM then
		--		local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
			--	if TORSO and RANGE >= (TORSO.Position - POSITION).Magnitude then
				--	local CAMSHAKER = script.CamShake:Clone()
				--	CAMSHAKER.Shake.Value = INTENSITY
				---	CAMSHAKER.Timer.Value = TIME
				--	CAMSHAKER.Parent = CHILD
				--	CAMSHAKER.Disabled = false
			--	end
	--		end
	--	end
--	end
--nd

--//=================================\\
--||	     WEAPON CREATION
--\\=================================//

--local Shotgun = script.Shotgun:Clone()
--Shotgun.Parent = RightArm
--CreateWeld(Shotgun.Handle,RightArm,Shotgun.Handle,0.2,-0.1,0.5,math.rad(90),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local Hole = shottie

local Particle = IT("ParticleEmitter",nil)
Particle.Enabled = false
Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
Particle.LightEmission = 0.5
Particle.Rate = 150
Particle.ZOffset = 0.2
Particle.Rotation = NumberRange.new(-180, 180)
Particle.RotSpeed = NumberRange.new(-180, 180)
Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
Particle.Color = ColorSequence.new(C3(0,1,0),C3(0,1.1,0))

--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
function ParticleEmitter(Table)
	local PRTCL = Particle:Clone()
	local Speed = Table.Speed or 5
	local Drag = Table.Drag or 0
	local Size1 = Table.Size1 or 1
	local Size2 = Table.Size2 or 5
	local Lifetime1 = Table.Lifetime1 or 1
	local Lifetime2 = Table.Lifetime2 or 1.5
	local Parent = Table.Parent or Torso
	local Emit = Table.Emit or 100
	local Offset = Table.Offset or 360
	local Acel = Table.Acel or VT(0,0,0)
	local Enabled = Table.Enabled or false
	PRTCL.Parent = Parent
	PRTCL.Size = NumberSequence.new(Size1,Size2)
	PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
	PRTCL.Speed = NumberRange.new(Speed)
	PRTCL.VelocitySpread = Offset
	PRTCL.Drag = Drag
	PRTCL.Acceleration = Acel
	if Enabled == false then
		PRTCL:Emit(Emit)
		Debris:AddItem(PRTCL,Lifetime2)
	else
		PRTCL.Enabled = true
	end
	return PRTCL
end

for _, c in pairs(CharacterA:GetChildren()) do
	if c.ClassName == "Part" then
		c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	end
end

CharacterA.Parent = Character

Characterb.Parent = Character


local SKILLTEXTCOLOR = C3(1,1,1)
local SKILLFONT = ""
local SKILLTEXTSIZE = 7

Humanoid.Died:connect(function()
	ATTACK = true
end)

--[[local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.1, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.63, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.215, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.525, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")
local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 5 Frame")
]]
--[[local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Banish Bullet", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 1")
local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B] Ability 2", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 2")
local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C] Ability 3", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 3")
local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V] Ability 4", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 4")
local SKILL5TEXT = CreateLabel(SKILL5FRAME, "[X] Mercy", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 5")
]]

function chatfunc(text)
	local chat = coroutine.wrap(function()
	if Character:FindFirstChild("TalkingBillBoard")~= nil then
		Character:FindFirstChild("TalkingBillBoard"):destroy()
	end
	local Bill = Instance.new("BillboardGui",Character)
	Bill.Size = UDim2.new(0,100,0,40)
	Bill.StudsOffset = Vector3.new(0,3,0)
	Bill.Adornee = Character.Head
	Bill.Name = "TalkingBillBoard"
	local Hehe = Instance.new("TextLabel",Bill)
	Hehe.BackgroundTransparency = 1
	Hehe.BorderSizePixel = 0
	Hehe.Text = ""
	Hehe.Font = "SourceSansItalic"
	Hehe.TextSize = 40
	Hehe.TextStrokeTransparency = 0
	Hehe.Size = UDim2.new(1,0,0.5,0)
	coroutine.resume(coroutine.create(function()
		while Hehe ~= nil do
			Swait()	
			Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
			Hehe.Rotation = math.random(-5,5)
			Hehe.TextColor3 = Color3.new(0,0,0)
			Hehe.TextStrokeColor3 = Color3.new(1,1,1)
		end
	end))
	for i = 1,string.len(text),1 do
		Swait()
		Hehe.Text = string.sub(text,1,i)
	end
	Swait(90)--Re[math.random(1, 93)]
	for i = 0, 1, .025 do
		Swait()
		Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
		Hehe.TextStrokeTransparency = i
		Hehe.TextTransparency = i
	end
	Bill:Destroy()
	end)
chat()
end

function onChatted(msg)
	chatfunc(msg)
end

Player.Chatted:connect(onChatted)

function printbye(Name)
	local MESSAGES = {"You cannot struggle, ","Your existance is an insult, ","Fade, ","Your existance is not desired, ","You are not permitted here, ","You are not to decide your fate, ","Be gone, ","You are already dead, ","Your live is an anomaly, ","Don't dare to return, ","Why are you resisting, ","You cannot exist here, ","Why are you struggling, ","Your fate was already decided, ","Goodbye, ","You cannot ignore my command, ","You cannot resist my command, ","You already died, "}
	chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
end

workspace.ChildAdded:connect(function(instance)
    for BANISH = 1, #TOBANISH do
		if TOBANISH[BANISH] ~= nil then
			if instance.Name == TOBANISH[BANISH] then
				coroutine.resume(coroutine.create(function()
					printbye(instance.Name)
					instance:ClearAllChildren()
					Debris:AddItem(instance,0.0005)
				end))
			end
		end
	end
end)

--//=================================\\
--||			DAMAGING
--\\=================================//

function Banish(Foe)
	if Foe then
		coroutine.resume(coroutine.create(function()
			--if game.Players:FindFirstChild(Foe.Name) then
				table.insert(TOBANISH,Foe.Name)
				printbye(Foe.Name)
			--end
			Foe.Archivable = true
			local CLONE = Foe:Clone()
			Foe:Destroy()
			CLONE.Parent = Effects
			CLONE:BreakJoints()
			local MATERIALS = {"Glass","Neon"}
			for _, c in pairs(CLONE:GetDescendants()) do
				if c:IsA("BasePart") then
					if c.Name == "Torso" or c.Name == "UpperTorso" or c == CLONE.PrimaryPart then
 						CreateSound(340722848, c, 10, 1, false)
					end
					c.Anchored = true
					c.Transparency = c.Transparency + 0.2
					c.Material = MATERIALS[MRANDOM(1,2)]
					c.Color = C3(1,1,1)
					if c.ClassName == "MeshPart" then
						c.TextureID = ""
					end
					if c:FindFirstChildOfClass("SpecialMesh") then
						c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
					end
					if c:FindFirstChildOfClass("Decal") then
						c:FindFirstChildOfClass("Decal"):remove()
					end
					c.Name = "Banished"
					c.CanCollide = false
				else
					c:remove()
				end
			end
			local A = false
			for i = 1, 35 do
				if A == false then
					A = true
				elseif A == true then
					A = false
				end
				for _, c in pairs(CLONE:GetDescendants()) do
					if c:IsA("BasePart") then
						c.Anchored = true
						c.Material = MATERIALS[MRANDOM(1,2)]
						c.Transparency = c.Transparency + 0.8/35
						if A == false then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)
						elseif A == true then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)						
						end
					end
				end
				Swait()
			end
			CLONE:remove()
		end))
	end
end

function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end


function ManualDamage(Humanoid,Damage,TorsoPart)
	local defence = Instance.new("BoolValue",Humanoid.Parent)
	defence.Name = ("HitBy"..Player.Name)
	game:GetService("Debris"):AddItem(defence, 0.001)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health ~= 0 then
		local CritChance = MRANDOM(1,100)
		if Damage > Humanoid.Health then
			Damage = math.ceil(Humanoid.Health)
			if Damage == 0 then
				Damage = 0.1
			end
		end
		Humanoid.Health = Humanoid.Health - Damage
	end
end

local asd = Instance.new("ParticleEmitter")
asd.Color = ColorSequence.new(Color3.new(0.5, 0, 0), Color3.new(.3, 0, 0))
asd.LightEmission = .1
asd.Texture = "http://www.roblox.com/asset/?ID=291880914"
aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6),NumberSequenceKeypoint.new(1, 2)})
bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
asd.Transparency = bbb
asd.Size = aaa
asd.ZOffset = .9
asd.Acceleration = Vector3.new(0, -15, 0)
asd.LockedToPart = false
asd.EmissionDirection = "Back"
asd.Lifetime = NumberRange.new(1, 2)
asd.Rotation = NumberRange.new(-100, 100)
asd.RotSpeed = NumberRange.new(-100, 100)
asd.Speed = NumberRange.new(10)
asd.Enabled = false
asd.VelocitySpread = 999

function getbloody(victim,amount)
	local PART = CreatePart(3, Effects, "Metal", 0, 1, "Mid gray", "Blood", victim.Size)
	PART.CFrame = victim.CFrame
	local HITPLAYERSOUNDS = {"356551938","264486467"}
	Debris:AddItem(PART,5)
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	local prtcl = asd:Clone()
	prtcl.Parent = PART
	prtcl:Emit(amount*10)
end

function ManualAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ManualDamage(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function KickThatNigga(CHARACTER)
	g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 1
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
	 CreateSound("527749592", CHARACTER, 600, 1, false)
	for i,v in ipairs(CHARACTER:GetChildren()) do
		if v.ClassName == "Part" or v.ClassName == "MeshPart" then
			if v.Name ~= "HumanoidRootPart" then
				local BOD = v:Clone()
				BOD.CanCollide = false
				BOD.Anchored = true
				BOD.CFrame = v.CFrame
				BOD.Parent = kickfolder
				BOD.Material = "Granite"
				BOD.Color = C3(.3,0,0)
				if BOD:FindFirstChildOfClass("Decal") then
					BOD:FindFirstChildOfClass("Decal"):remove()
				end
				if BOD.Name == "Head" then
					naeeym2.Adornee = BOD
				end
				if BOD.ClassName == "MeshPart" then
					BOD.TextureID = ""
				end
			end
		end
	end
	for i,v in pairs(g) do
	v:remove()
	end 
	if CHARACTER ~= Character then
	CHARACTER:remove()
	end
	if CHARACTER.Name == "Helkern" then
		Character:BreakJoints()
	end
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
end

function ApplyAoE(POSITION,RANGE,ISKICKED)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISKICKED == true then
							KickThatNigga(CHILD)
						else
							if ISKICKED == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISKICKED == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

local BEANED = {}

function Ban(bitch)	
if bitch then	
g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 0
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
-- CreateSound("2570187601", bitch, 600, 1, false)
local Players = game:GetService("Players")
local fag = Players:FindFirstChild(bitch.Name)
--faggut:Kick()
	if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
		if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
		end
			if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
			end
				if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
				end
					if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
					end
						if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
						end
												if Players:FindFirstChild("Drago_TH") then
						end
						table.insert(BEANED,bitch.name)
	--]]
			--CreateSound("527749592", game.Workspace, 700, 1, false)
	--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
	--wait(6)
	--bitch:Remove()
end
end

local function CheckForBan(player)
	for i = 1, #BEANED do
		if player.Name == BEANED[i] then
			player:Kick("Ur mom gay skids") --Ban Reason Change between the '' to change the reason!
		end
	end
end


game.Players.PlayerAdded:connect(function()
	for i,v in pairs(game.Players:GetPlayers())do
		CheckForBan(v)
	end  
end)


function Kick(bitch)
g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 0
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
-- CreateSound("2570187601", bitch, 600, 1, false)
local Players = game:GetService("Players")
local fag = Players:FindFirstChild(bitch.Name)
--faggut:Kick()
	if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
		if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
		end
			if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
			end
				if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
				end
					if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
					end
						if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
	--[[
		for i,v in pairs(fag.Name) do
		if (v:lower() == newPlayer.Name:lower()) then
			newPlayer:Remove()
		end
	end]]--
			--CreateSound("527749592", game.Workspace, 700, 1, false)
	--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
	--wait(6)
	--bitch:Remove()
end


function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

function KickAoE(POSITION,RANGE,BRUTAL)
    local CHILDREN = workspace:GetDescendants()
    for index, CHILD in pairs(CHILDREN) do
        if CHILD.ClassName == "Model" and CHILD ~= Character then
            local HUM = CHILD:FindFirstChildOfClass("Humanoid")
            if HUM then
                local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                if TORSO then
                    if (TORSO.Position - POSITION).Magnitude <= RANGE then
                        if BRUTAL == true then
	if Type == "Banish" then
                            KickThatNigger(CHILD)
	elseif Type == "Ban" then
		Ban(CHILD)
	elseif Type == "Kick" then
		Kick(CHILD)
			--elseif Type == "Tangle" then
		--Entangle(CHILD)
		end
                        else
                            CHILD:BreakJoints()
                        end
                    end
                end
            end
        end
    end
end

local PE=Instance.new("ParticleEmitter",art)
PE.LightEmission=.8
PE.Color = ColorSequence.new(BRICKC("Really red").Color)
PE.Lifetime=NumberRange.new(0.35,1.5)
PE.Rotation=NumberRange.new(0,360)
PE.Rate=999
PE.VelocitySpread = 10000
PE.Acceleration = Vector3.new(0,0,0)
PE.Drag = 5
PE.Speed = NumberRange.new(0,0,0)
PE.Texture="http://www.roblox.com/asset/?id=833874434"
PE.ZOffset = -1.5
PE.Name = "PE"
PE.Enabled = false

function particles(art)
	local PARTICLES = PE:Clone()
	PARTICLES.Parent = art
end

function KillChildren(v)
	v:BreakJoints()
	for _, c in pairs(v:GetChildren()) do
		if c.ClassName == "Part" or c.ClassName == "MesPart" then
			if c.Transparency < 1 then
				if c:FindFirstChildOfClass("Decal") then
					c:FindFirstChildOfClass("Decal"):remove()
				end
				particles(c)
				c.PE.Enabled = true
				c.Parent = Effects
				c.CanCollide = false
				c.Material = "Neon"
				c.Color = C3(1,0,0)
				c.Transparency = 0.5
				local grav = Instance.new("BodyPosition",c)
				grav.P = 20000
				grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
				grav.position = c.Position + VT(MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1))
				grav.Name = "GravityForce"
				coroutine.resume(coroutine.create(function()
				for i = 1, 50 do
					Swait()
					c.Transparency = c.Transparency + 0.01
				end
				c.PE.Enabled = false
				Debris:AddItem(c,2)
				end))
			end
		end
	end
end

function killnearest(position,range)
	for i,v in ipairs(workspace:GetChildren()) do
	local body = v:GetChildren()
		for part = 1, #body do
			if((body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character) then
				if(body[part].Position - position).Magnitude < range then
					if v.ClassName == "Model" then
						KillChildren(v)
					end
				end
			end
		end
	end
end

function Dismember(MAN,DOWHAT)
	for index, CHILD in pairs(MAN:GetDescendants()) do
		if CHILD:IsA("Script") or CHILD:IsA("LocalScript") then
			CHILD:Destroy()
		end
	end
	if DOWHAT == "Ragdoll" then
		local HUM = MAN:FindFirstChildOfClass("Humanoid")
		if HUM then
			HUM.Health = 0
		end
		if MAN:FindFirstChild("UpperTorso") then
			local SCRIPT = script.R15Ragdoll:Clone()
			SCRIPT.Parent = MAN
			SCRIPT.Disabled = false
		else
			local SCRIPT = script.R6Ragdoll:Clone()
			SCRIPT.Parent = MAN
			SCRIPT.Disabled = false
		end
		MAN:BreakJoints()
	else
		local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
		local HED = MAN:FindFirstChild("Head")
		if TORSO and HED then
			if DOWHAT == "Head" then
				if TORSO:FindFirstChild("TorsoA4") then
					TORSO:FindFirstChild("TorsoA4"):Remove()
				elseif MAN:FindFirstChild("RagdollConstraintHead") then
					MAN:FindFirstChild("RagdollConstraintHead"):Remove()
				end
				HED:BreakJoints()
			elseif DOWHAT == "RightArm" then
				if TORSO:FindFirstChild("TorsoA3") then
					TORSO:FindFirstChild("TorsoA3"):Remove()
				elseif MAN:FindFirstChild("RagdollConstraintRightUpperArm") then
					MAN:FindFirstChild("RagdollConstraintRightUpperArm"):Remove()
				end
			elseif DOWHAT == "LeftArm" then
				if TORSO:FindFirstChild("TorsoA2") then
					TORSO:FindFirstChild("TorsoA2")
				elseif MAN:FindFirstChild("RagdollConstraintLeftUpperArm") then
					MAN:FindFirstChild("RagdollConstraintLeftUpperArm"):Remove()
				end
			elseif DOWHAT == "Legs" then
				if TORSO.Name == "Torso" then
					if TORSO:FindFirstChild("TorsoA") then
						TORSO:FindFirstChild("TorsoA"):Remove()
					end
					if TORSO:FindFirstChild("TorsoA1") then
						TORSO:FindFirstChild("TorsoA1"):Remove()
					end
				elseif MAN:FindFirstChild("RagdollConstraintUpperTorso") then
					MAN:FindFirstChild("RagdollConstraintUpperTorso"):Remove()
				end
			end
		end
	end
end

function OofOuchBlood(LOCATION,TO,AMOUNT)
	local P = CreatePart(3, Effects, "Granite", 0, 1, BRICKC("Pearl"), "Blood", VT(0,0,0), true)
	P.CFrame = CF(LOCATION,TO)
	local BLOOD = MODULE.Blood:Clone()
	BLOOD.Parent = P
	BLOOD:Emit(AMOUNT)
	Debris:AddItem(P,2)
end

local DETECTKILL = function(HIT,POS,FORCE)
		if HIT.Parent:FindFirstChildOfClass("Humanoid") then
			if HIT.Parent:FindFirstChildOfClass("Humanoid").Health > 0 then
				local BV = IT("BodyVelocity")
				BV.MaxForce = BV.MaxForce * 500
				BV.Velocity = CF(RootPart.Position,HIT.Position+VT(0,5,0)).lookVector*(FORCE or 25)
				BV.Parent = HIT
				Debris:AddItem(BV,0.05)
				OofOuchBlood(POS,RootPart.Position,150)
			else
				OofOuchBlood(POS,RootPart.Position,2)
			end
		end
	end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

function Zone()
	ATTACK = true
	Rooted = true
	for i=0, 5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(-18)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-5), RAD(12), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function meme()
local TARGET = Mouse.Target
	if TARGET ~= nil then
		if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
			local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
			local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
			if ROOT and HUM.Health > 0 then
			local FOE = Mouse.Target.Parent
			RootPart.CFrame = ROOT.CFrame*CF(0.3,0,6)
			ROOT.Anchored = true
   local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
	if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
	 local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
	  local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
	   if TORSO and HUM.Health > 0 then
			ATTACK = true
			Rooted = false
			CreateSound(429459101, TORSO, 0.5, 1, false)
	for i=0, 2, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(85), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(90), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
		WACKYEFFECT({Time = 18, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(Hole.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,0), SoundID = 136523485, SoundPitch = 1, SoundVolume = 5})
		for i=0, 0.5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.5, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(-6), RAD(0), RAD(-60)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.2, -0.8) * ANGLES(RAD(85), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.4, -0.3) * ANGLES(RAD(90), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-25)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
		getbloody(TORSO,1)
	--	SHAKECAM(HITPOS, 15, 2, 130)
		killnearest(TORSO.Position, 5, 5)
		WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(10,10,10), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 0, SoundPitch = MRANDOM(13,15)/10, SoundVolume = 3})
		WACKYEFFECT({EffectType = "Sphere", Size = VT(6,6,6), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	ATTACK = false
	Rooted = false
		 end
	end
			end
		end
		end
			end

function Dance()
	ATTACK = true
	Rooted = true
	local LOOP = true
	KEY = Mouse.KeyDown:connect(function(NEWKEY)
		if NEWKEY == "t" then
			KEY:Disconnect()
			LOOP = false
		end
	end)
	repeat
		for i = 0, 0.4, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0.1 + ((1) - 1)) * ANGLES(RAD(-8), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.2, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(15)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(15)), 1 / Animation_Speed)
	end
		for i = 0, 1, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(26)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(26)), 1 / Animation_Speed)
	end
		for i = 0, 0.4, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0.1 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.2, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-15)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-15)), 1 / Animation_Speed)
	end
		for i = 0, 1, 0.1 / Animation_Speed do
			Swait()
			if LOOP == false then
				break
			end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-26)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-26)), 1 / Animation_Speed)
	end
	until LOOP == false
	ATTACK = false
	Rooted = false
end


--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//

-------------------------------------

Humanoid.Animator.Parent = nil

-------------------------------------


function MouseDown(Mouse)
	if ATTACK == false then
	end
end


function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "v" and ATTACK == false then
		meme()
		end
		
	if Key == "t" and ATTACK == false then
		Dance()
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

--//=================================\\
--\\=================================//


function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end


--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

local CONNECT = nil

while true do
	Swait()
	ANIMATE.Parent = nil
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.2 * COS(SINE / (WALKSPEEDVALUE))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 100, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 25), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1 - 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1 + 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
	end
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(15)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(45)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 0.15 / Animation_Speed)
			if MRANDOM(1,50) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MRANDOM(-10,10)), RAD(MRANDOM(-10,10)), RAD(MRANDOM(-10,10))), 1 / Animation_Speed)
			end	
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.3, 0) * ANGLES(RAD(15 - 15 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 15 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.8, 0.2, -0.8) * ANGLES(RAD(65), RAD(0), RAD(-70)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, -0.3) * ANGLES(RAD(80), RAD(70), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(86), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-86), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end
	end
	unanchor()
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	if sick.Parent ~= Torso then
	sick = IT("Sound", Torso)
	end
	sick.Parent = Torso
	sick.Playing = true
    sick.Looped = true
	sick.Volume = 2
	sick.Pitch = 1
	sick.SoundId = "rbxassetid://549162782"
	sick.Name = "Dead"
end

--//=================================\\
--\\=================================//





--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--

	end
	
	
	    
	
	
	if string.sub(BAR.Text, 1, 3) == ("rpg") then

--//====================================================\\--
--||                       BASIS
--\\====================================================//--


 sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
       --sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


local rpg = game.Players.LocalPlayer.Character["Back Attack Missle Launcher"].Handle
rpg.AccessoryWeld:Destroy()



local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = rpg
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true


attachment0.CFrame = CFrame.new(1.8,.5,-.3)
attachment1.CFrame = CFrame.Angles(.4,5,20) 

loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(1)




local MODULE = script
local CHARACTER = workspace.non
local PLAYER = game:GetService("Players"):GetPlayerFromCharacter(CHARACTER)
local HUM = CHARACTER.Humanoid
--local REMOTE = MODULE.Event
local ROOT = HUM.Torso
local HEAD = CHARACTER.Head
local TORSO = CHARACTER.Torso
local RIGHTARM = CHARACTER["Right Arm"]
local LEFTARM = CHARACTER["Left Arm"]
local RIGHTLEG = CHARACTER["Right Leg"]
local LEFTLEG = CHARACTER["Left Leg"]
local ROOTJOINT = ROOT["RootJoint"]
local NECK = TORSO["Neck"]
local RIGHTSHOULDER = TORSO["Right Shoulder"]
local LEFTSHOULDER = TORSO["Left Shoulder"]
local RIGHTHIP = TORSO["Right Hip"]
local LEFTHIP = TORSO["Left Hip"]
local MOUSEPOS = ROOT.Position
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor


--//====================================================\\--
--||                  BACKGROUND VALUES
--\\====================================================//--
local ANIM_SPEED = 3
local MOUSE = game.Players.LocalPlayer:GetMouse()
local Mouse = game.Players.LocalPlayer:GetMouse()
local MOUSEPOS = Mouse.Hit.p
local FRAME_SPEED = 1 / 60 -- (1 / 30) OR (1 / 60)
local CHANGE = 2 / ANIM_SPEED
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local KEYHOLD = false
local MOUSEHOLD = false
local SINE = 0
local ATTACKING = false
local Debris = game:GetService("Debris")
local Effects = IT("Folder",CHARACTER)
Effects.Name = "FXFolder"
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local BGM = 213546066
local BOMB = 2671146857
local STORED = 9999999999999
--//====================================================\\--
--||                     HEARTBEAT
--\\====================================================//--
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = FRAME_SPEED
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end
--//====================================================\\--
--||                       CLERP
--\\====================================================//--
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
--//====================================================\\--
--||                     FUNCTIONS
--\\====================================================//--
function WeldParts(A,B)
	local WLD = IT("ManualWeld")
	WLD.Part0 = A
	WLD.Part1 = B
	WLD.C1 = B.CFrame:inverse() * A.CFrame
	WLD.Parent = A
	return WLD
end
--NewSound({ID = 0,PARENT = ROOT,VOLUME = 0.5,PITCH = 1,LOOP = false,MAXDISTANCE = 1000,EMITTERSIZE = 10,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
function NewSound(TABLE)
	local ID = "rbxassetid://"..(TABLE.ID or 0)
	local PARENT = (TABLE.PARENT or ROOT)
	local VOLUME = (TABLE.VOLUME or 0.5)
	local PITCH = (TABLE.PITCH or 1)
	local LOOP = (TABLE.LOOP or false)
	local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
	local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
	local PLAYING = (TABLE.PLAYING or true)
	local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
	local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
	if ID ~= "rbxassetid://0" then
		local SOUND = IT("Sound",PARENT)
		SOUND.SoundId = ID
		SOUND.Volume = VOLUME
		SOUND.Pitch = PITCH
		SOUND.Looped = LOOP
		SOUND.MaxDistance = MAXDISTANCE
		SOUND.EmitterSize = EMITTERSIZE
		SOUND.PlayOnRemove = PLAYONREMOVE
		if DOESDEBRIS == true and PLAYING == true and LOOP == false then
			Debris:AddItem(SOUND,SOUND.TimeLength+5)
		end
		if PLAYING == true then
			SOUND:Play()
		end
		return SOUND
	end
end
function ManSlaughter(MAN)
	if MAN then
		local ROOT = MAN:FindFirstChild("HumanoidRootPart")
		if ROOT then
			ROOT:Remove()
		end
		local MANHUM = MAN:FindFirstChildOfClass("Humanoid")
		if MANHUM then
			MANHUM.BreakJointsOnDeath = false
			MANHUM.Health = 0
		end
		if MAN:FindFirstChild("R6Ragdoll") == nil and MAN:FindFirstChild("R15Ragdoll") == nil then
			if MAN:FindFirstChild("UpperTorso") then
				local SCRIPT = script.R15Ragdoll:Clone()
				SCRIPT.Parent = MAN
				SCRIPT.Disabled = false
			else
				local SCRIPT = script.R6Ragdoll:Clone()
				SCRIPT.Parent = MAN
				SCRIPT.Disabled = false
			end
			local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
			if TORSO then
				NewSound({ID = 146594648,PARENT = TORSO,VOLUME = 1,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 75,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
			end
		end
		MAN:BreakJoints()
		if MAN:FindFirstChild("Slaughtered") == nil then
			local MARK = IT("Folder",MAN)
			MARK.Name = "Slaughtered"
		else
			if MAN:FindFirstChild("Slaughtered") then
				local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
				if TORSO then
					TORSO.RotVelocity = VT(0,MRANDOM(-25,25),0)
				end
			end
		end
	end
end
function AreaOfEffect(AREA,RANGE,FLING,RETURN)
	local HIT = {}
	for index, CHILD in pairs(workspace:GetChildren()) do
		if CHILD:FindFirstChildOfClass("Humanoid") then
			local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
			local ROOT = HUMAN.Torso
			if ROOT then
				if (ROOT.Position - AREA).Magnitude <= RANGE then
					if RETURN == true then
						if CHILD ~= CHARACTER then
							table.insert(HIT,{CHILD,HUMAN,ROOT})
						end
					else
						if CHILD ~= CHARACTER then
							ManSlaughter(CHILD)
						end
						local BV = IT("BodyVelocity")
						BV.MaxForce = BV.MaxForce * 500
						BV.Velocity = CF(AREA,ROOT.Position+VT(0,0.5,0)).lookVector*FLING
						BV.Parent = ROOT
						Debris:AddItem(BV,0.05)
					end
				end
			end
		end
	end
	if RETURN == true then
		return HIT
	end
end
function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = ROOT.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end
function CameraShake(AREA,RANGE,SHAKE,TIMER)
	for index, CHILD in pairs(workspace:GetChildren()) do
		if CHILD:FindFirstChildOfClass("Humanoid") then
			local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
			local ROOT = HUMAN.Torso
			if ROOT and game.Players:GetPlayerFromCharacter(CHILD) then
				if (ROOT.Position - AREA).Magnitude <= RANGE then
					if CHILD:FindFirstChild("CamShake") then
						Debris:AddItem(CHILD:FindFirstChild("CamShake"),0.05)
					end
					local CAMSHAKE = script.CamShake:Clone()
					CAMSHAKE.Parent = CHILD
					local TIMER_V = IT("NumberValue",CAMSHAKE)
					TIMER_V.Name = "Timer"
					TIMER_V.Value = TIMER
					local SHAKE_V = IT("NumberValue",CAMSHAKE)
					SHAKE_V.Name = "Shake"
					SHAKE_V.Value = SHAKE
					CAMSHAKE.Disabled = false
					Debris:AddItem(CAMSHAKE,15)
				end
			end
		end
	end
end
--//====================================================\\--
--||                     CHARACTER
--\\====================================================//--

for index, CHILD in pairs(CHARACTER:GetChildren()) do
	if CHILD ~= ROOT then
		if CHILD:IsA("Accessory") then
			CHILD:Remove()
		end
	end
end
local FACE = HEAD.face
FACE.Texture = "rbxassetid://559113097"
--HELMET.CFrame = HEAD.CFrame*CF(0,0.5,0)
--HELMET.Anchored = false
--WeldParts(HEAD,HELMET)
--local BAZOOKA = MODULE.Bazooka
--.Parent = CHARACTER
--BAZOOKA.Anchored = false
--local GRIP = IT("Motor6D")
--GRIP.Part0 = RIGHTARM
--GRIP.Part1 = BAZOOKA
--GRIP.C0 = CF(0,-1,-0.5)*ANGLES(RAD(-90),0,0)*CF(0,0,1.85)
--local G_C0 = GRIP.C0
--GRIP.Parent = RIGHTARM
for i = 1, 15 do
	local FACE = CreatePart(3, CHARACTER, "Fabric", 0, 0+(i-1)/15.2, "Dark stone grey", "FaceGradient", VT(1.01,0.58,1.01),false)
	FACE.Color = C3(0,0,0)
	HEAD:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
	FACE.CFrame = HEAD.CFrame*CF(0,0.3-(i-1)/35,0)
	WeldParts(HEAD,FACE)
end
--local MISSILE = MODULE.Missile
--MISSILE.Parent = nil

--//====================================================\\--
--||                     ABILITIES
--\\====================================================//--
function Fire_in_the_hole()
	if STORED > 0 then
		ATTACKING = true
		local GYRO = IT("BodyGyro")
		GYRO.D = 50
		GYRO.P = 5000
		GYRO.MaxTorque = VT(0,4000000,0)
		GYRO.CFrame = CF(ROOT.Position,Mouse.Hit.p)
		GYRO.Parent = ROOT
		ATTACKING = true
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				GYRO.CFrame = CF(ROOT.Position,Mouse.Hit.p)
			until ATTACKING == false
			GYRO:Remove()
		end))
		repeat
			for i=0, 0.06, 0.1 / ANIM_SPEED do
				Swait()
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
			end
		--	AddTo(-1)
			coroutine.resume(coroutine.create(function()
				local GOTO = Mouse.Hit.p
				local ROCKET = MISSILE:Clone()
				ROCKET.Parent = Effects
				ROCKET.CFrame = CF(BAZOOKA.CFrame*CF(0,0,-2).p,GOTO)
				NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				NewSound({ID = 440145223,PARENT = ROCKET,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for i = 1, 200 do
					Swait()
					local HIT,POS = Raycast(ROCKET.Position,ROCKET.CFrame.lookVector,5,CHARACTER)
					if HIT then
						ROCKET.CFrame = CF(POS)
						break
					end
					ROCKET.CFrame = ROCKET.CFrame*CF(0,0,-4)
				end
				ROCKET.Transparency = 1
				ROCKET.Hind:Remove()
				ROCKET.CFrame = CF(ROCKET.Position)
				ROCKET.Size = VT(0,0,0)
				NewSound({ID = 142070127,PARENT = ROCKET,VOLUME = 7,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 300,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for index, CHILD in pairs(script.Grenade:GetChildren()) do
					local C = CHILD:Clone()
					C.Parent = ROCKET
					C:Emit(125)
				end
				CameraShake(ROCKET.Position,50,125,70)
				AreaOfEffect(ROCKET.Position,35,200,false)
				Debris:AddItem(ROCKET,2)
			end))
			for i=0, 0.025, 0.1 / ANIM_SPEED do
				Swait()
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(200), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
			end
		until MOUSEHOLD == false or STORED <= 0
		if STORED <= 0 then
			STORED = 0
			STOREDGUI.Text = "STORED: 0"
		end
		ATTACKING = false
	end
end
function Store()
	HUM.WalkSpeed = 0
	HUM.JumpPower = 0
	ATTACKING = true
	repeat
		for i=0, 0.01, 0.1 / ANIM_SPEED do
			Swait()
	--		GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
	
		for i=0, 0.02, 0.1 / ANIM_SPEED do
			Swait()
		--	GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.675, 0.45, 0.3) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
		for i=0, 0.02, 0.1 / ANIM_SPEED do
			Swait()
		--	GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
		NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 1,PITCH = MRANDOM(9,11)/6,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		for i=0, 0.05, 0.1 / ANIM_SPEED do
			Swait()
		--	GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.75, 0.45, -0.1) * ANGLES(RAD(45), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-0.9, 0.5, -0.75) * ANGLES(RAD(60), RAD(0), RAD(37.5)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
		end
	--	ROCKET:Remove()
	--	BAZOOKA.Face.Pop:Emit(5)
	--	AddTo(1)
	until KEYHOLD == false
	ATTACKING = false
	HUM.WalkSpeed = 100
	HUM.JumpPower = 50
end
function Dance()
	HUM.WalkSpeed = 0
	HUM.JumpPower = 0
	ATTACKING = true
	local REMOVETRACK = false
	local TRACK = nil
	if ROOT:FindFirstChild("BGM_MUSIC") then
		TRACK = ROOT:FindFirstChild("BGM_MUSIC")
		TRACK.Volume = 5
	else
		TRACK = NewSound({ID = BOMB,PARENT = ROOT,VOLUME = 5,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		REMOVETRACK = true
	end
	TRACK.SoundId = "rbxassetid://"..BOMB
	TRACK:Play()
	local DONEWITHDANCING = false
	local NC = mouse.KeyDown:connect(function(key)
		key=key:lower()
		local V2 = key
		if V2 == "m" then
			DONEWITHDANCING = true
			ATTACKING = false
			if REMOVETRACK == true then
				TRACK:Remove()
			else
				TRACK:Play()
				TRACK.Volume = 1.25
				TRACK.SoundId = "rbxassetid://"..BGM
			end
		end
	end)
	local I = 0
	local RAVE = IT("PointLight",ROOT)
	RAVE.Brightness = 25
	RAVE.Color = BrickColor.random().Color
	repeat
		I = I + 2
		Swait()
		RAVE.Color = BrickColor.random().Color
		ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0 - 0.32 * SIN(I / 10), 0, -0.55 - 0.05 * COS(I / 5)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
		NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
		RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(170), RAD(10), RAD(-35 * COS(I/10)))  *CF(0,-1,0) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
		LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(170), RAD(-10), RAD(-35 * COS(I/10))) * CF(0,-1,0) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
		RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1.35, -0.475 + 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-12 - 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
		LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.35, -0.475 - 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-12 + 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
	until DONEWITHDANCING == true
	RAVE:Remove()
	NC:Disconnect()
	if REMOVETRACK == true then
		TRACK:Remove()
	else
		TRACK:Play()
		TRACK.Volume = 1.25
		TRACK.SoundId = "rbxassetid://"..BGM
	end
	ATTACKING = false
	HUM.WalkSpeed = 100
	HUM.JumpPower = 50
end
--//====================================================\\--
--||                       WRAP
--\\====================================================//--
game.Players.LocalPlayer:GetMouse().Button1Down:connect(function()
	MOUSEHOLD = true
	if ATTACKING == false then
		Fire_in_the_hole()
	end
end)
game.Players.LocalPlayer:GetMouse().Button1Up:connect(function()
	MOUSEHOLD = false
end)
game.Players.LocalPlayer:GetMouse().KeyDown:connect(function(key)
	key=key:lower()
	local V2 = key
	KEYHOLD = true
				if V2 == "z" then
					Store()
				elseif V2 == "m" then
					Dance()
				elseif V2 == "t" then
					NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				elseif V2 == "e" then
					if ROOT:FindFirstChild("BGM_MUSIC") then
						ROOT:FindFirstChild("BGM_MUSIC"):Remove()
					else
						local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						M.Name = "BGM_MUSIC"
					end
				end
end)
game.Players.LocalPlayer:GetMouse().KeyUp:connect(function()
	KEYHOLD = false
end)
--[[
REMOTE.OnServerEvent:Connect(function(PLR,V1,V2)
	if PLR == PLAYER and ANIM ~= "Sit" then
		--if V1 == "MousePositionUpdate" then
			--MOUSEPOS = V2
		if V1 == "KeyUp" then
			KEYHOLD = false
		elseif V1 == "MouseUp" then
			MOUSEHOLD = false
		end
		if ATTACKING == false then
			if V1 == "MouseDown" then
				MOUSEHOLD = true
				Fire_in_the_hole()
			elseif V1 == "KeyDown" then
				KEYHOLD = true
				if V2 == "z" then
					Store()
				elseif V2 == "m" then
					Dance()
				elseif V2 == "t" then
					NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				elseif V2 == "e" then
					if ROOT:FindFirstChild("BGM_MUSIC") then
						ROOT:FindFirstChild("BGM_MUSIC"):Remove()
					else
						local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						M.Name = "BGM_MUSIC"
					end
				end
			end
		end
	end
end)
]]--
local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
M.Name = "BGM_MUSIC"
HUM.WalkSpeed = 100
while true do
	Swait()
	local MOUSEPOS = Mouse.Hit.p
	SINE = SINE + CHANGE
	if CHARACTER:FindFirstChild("Animate") then
		CHARACTER:FindFirstChild("Animate"):Destroy()
	end
	if CHARACTER:FindFirstChild("Sound") then
		CHARACTER:FindFirstChild("Sound"):Destroy()
	end
	for _,v in next, HUM:GetPlayingAnimationTracks() do
		v:Stop();
	end
	local TORSOVELOCITY = (ROOT.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = ROOT.Velocity.y
	local HITFLOOR = Raycast(ROOT.Position, (CF(ROOT.Position, ROOT.Position + VT(0, -1, 0))).lookVector, 4+HUM.HipHeight, CHARACTER)
	local WALKSPEEDVALUE = 0.5
	local SITTING = HUM.Sit
	if ANIM == "Walk" and TORSOVELOCITY > 1 and SITTING == false then
		RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 0.875 - 0.3 * SIN(SINE / WALKSPEEDVALUE), -0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RIGHTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
		LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 0.875 + 0.3 * SIN(SINE / WALKSPEEDVALUE), 0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LEFTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) or SITTING == true then
		RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
		LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
	end
---	if ATTACKING == false then
--		GRIP.C0 = Clerp(GRIP.C0, G_C0, 1.5 / ANIM_SPEED)
--	end
	if SITTING == false then
		if HITFLOOR then
			if TORSOVELOCITY < 1 and HITFLOOR ~= nil then
				ANIM = "Idle"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 6)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(100), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25 - 2.5 * COS(SINE / 6))) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
				end
			elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
				ANIM = "Walk"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.05 + 0.05 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(135), RAD(0), RAD(5 + 2.5 * COS(SINE / WALKSPEEDVALUE))) * RIGHTSHOULDERC0, 2 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(0), RAD(-25 - 2.5 * COS(SINE / WALKSPEEDVALUE))) * LEFTSHOULDERC0, 2 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1 , -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-15)), 2 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(15)), 2 / ANIM_SPEED)
				end
			end
		else
			if TORSOVERTICALVELOCITY > 0 then
				ANIM = "Jump"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(10)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 1 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
			    end
			else
				ANIM = "Fall"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(150), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / ANIM_SPEED)
				end
			end
		end
	else
		ANIM = "Sit"
		if ATTACKING == false then
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.65, 0) * ANGLES(RAD(50), RAD(-10), RAD(45))*CF(0,-0.25,0) * LEFTSHOULDERC0, 1.25 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.25, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.25 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -0.25, -1) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1.25 / ANIM_SPEED)
		end
	end
end
local basetpart = game.workspace.non:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end

	end
	if string.sub(BAR.Text, 1, 6) == ("insane") then
			

spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
        sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
        sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)
loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(5)

Ply = game.Players.LocalPlayer
--FIXED WITH TRIGECTORY's CheatSheet--
cheatsheetplr = game.Players.LocalPlayer
i = Instance.new("NumberValue", cheatsheetplr )
i.Name = "FPSCH"
Bin = Instance.new("HopperBin", cheatsheetplr .Backpack)
script.Parent = Bin
local cf = CFrame.new
local function Create(A)
local A = Instance.new(A)
return function(B)
for i,v in pairs(B) do
A[i] = v
end
return A
end
end
RW = Create("Weld")({Name = "Right Shoulder", Part0 = Tor, C0 = CFrame.new(1.5, 0.5, 0), C1 = CFrame.new(0, 0.5, 

0), Part1 = RA, Parent = Tor})
LW = Create("Weld")({Name = "Left Shoulder", Part0 = Tor, C0 = CFrame.new(-1.5, 0.5, 0), C1 = CFrame.new(0, 0.5, 

0), Part1 = LA, Parent = Tor})
wait(.05)
--Saz

debounce=true
etime=0
etimem=20
down=false

vPlayer=game.Players.LocalPlayer
cPlayer=nil
Humanoid=nil

Welds={}

stopVictoly=function()
	
	for _,v in pairs(Welds) do
		v.Parent = cPlayer.Torso
	end
	
	wait(.2)
	
	g1:Remove() g2:Remove() g3:Remove() g4:Remove() g5:Remove()
	
	b1:Remove() b2:Remove()
	
	p1:Remove() p2:Remove()
	
	bpos:Remove()
	brot:Remove()
	
	Head.Anchored=false
	
	Humanoid.PlatformStand=false
	
end
startVictoly=function()
	
	Welds={}

	cPlayer=workspace.non
	Humanoid = nil
	for _,v in pairs(cPlayer:children()) do
		if v.className=="Humanoid" then
			Humanoid=v
		end
		if v.Name=="Torso" then
			for __,vv in pairs(v:children()) do
				if vv:IsA("JointInstance") then
					table.insert(Welds,vv)
				end
			end
		end
	end
	
	Torso = cPlayer.Torso
	Head = cPlayer.Head
	RightArm = cPlayer["Right Arm"]
	LeftArm = cPlayer["Left Arm"]
	RightLeg = cPlayer["Right Leg"]
	LeftLeg = cPlayer["Left Leg"]
	
	Head.Anchored=true
	
	headpos = Head.CFrame.p
	
	print("DEAD")
	
	Humanoid.PlatformStand=true
	
	Torso.Anchored=true
	
	p1=Instance.new("Part",cPlayer)
	p1.Anchored=true
	p1.formFactor="Custom"
	p1.Size=Vector3.new(1,1,1)
	p1.TopSurface=0
	p1.BottomSurface=0
	p1.CanCollide=false
	p1.Name="AnchorR"
	p1.CFrame = Torso.CFrame * CFrame.new(.5,-3.5,0)
	p1.Transparency=1
	
	p2=Instance.new("Part",cPlayer)
	p2.Anchored=true
	p2.formFactor="Custom"
	p2.Size=Vector3.new(1,1,1)
	p2.TopSurface=0
	p2.BottomSurface=0
	p2.CanCollide=false
	p2.Name="AnchorL"
	p2.CFrame = Torso.CFrame * CFrame.new(-.5,-3.5,0)
	p2.Transparency=1
	
	g1=Instance.new("Glue",RightLeg)
	g1.Part0 = Torso
	g1.Part1 = RightLeg
	g1.C0 = CFrame.new(.5,-2,0)
	g1.C1 = CFrame.new(0,0,0)
	g1.F0 = Vector3.new(0,1,0)
	g1.F1 = Vector3.new(0,1,0)
	g1.F2 = Vector3.new(0,1,0)
	g1.F3 = Vector3.new(0,1,0)
	
	g2=Instance.new("Glue",p1)
	g2.Part0 = p1
	g2.Part1 = RightLeg
	g2.C0 = CFrame.new(0,1.5,0)
	g2.C1 = CFrame.new(0,0,0)
	g2.F0 = Vector3.new(.25,-1,.25)
	g2.F1 = Vector3.new(.25,-1,-.25)
	g2.F2 = Vector3.new(-.25,-1,.25)
	g2.F3 = Vector3.new(-.25,-1,-.25)
	
	g3=Instance.new("Glue",LeftLeg)
	g3.Part0 = Torso
	g3.Part1 = LeftLeg
	g3.C0 = CFrame.new(-.5,-2,0)
	g3.C1 = CFrame.new(0,0,0)
	g3.F0 = Vector3.new(0,1,0)
	g3.F1 = Vector3.new(0,1,0)
	g3.F2 = Vector3.new(0,1,0)
	g3.F3 = Vector3.new(0,1,0)
	
	g4=Instance.new("Glue",p2)
	g4.Part0 = p2
	g4.Part1 = LeftLeg
	g4.C0 = CFrame.new(0,1.5,0)
	g4.C1 = CFrame.new(0,0,0)
	g4.F0 = Vector3.new(.25,-1,.25)
	g4.F1 = Vector3.new(.25,-1,-.25)
	g4.F2 = Vector3.new(-.25,-1,.25)
	g4.F3 = Vector3.new(-.25,-1,-.25)
	
	g5=Instance.new("Glue",Torso)
	g5.Part0 = Head
	g5.Part1 = Torso
	g5.C0 = CFrame.new(0,0,0)
	g5.C1 = CFrame.new(0,1.5,0)
	g5.F0 = Vector3.new(0,0,0)
	g5.F1 = Vector3.new(0,0,0)
	g5.F2 = Vector3.new(0,0,0)
	g5.F3 = Vector3.new(0,0,0)
	
	for _,v in pairs(Welds) do
		if v.Name~="Neck" then
			print(v.Name)
			v.Parent = nil
			if v.Name=="Right Shoulder" then
				RSC0 = v.C0
				RSC1 = v.C1
			elseif v.Name=="Left Shoulder" then
				LSC0 = v.C0
				LSC1 = v.C1				
			end
		end
	end
	
	b1=Instance.new("Motor6D",RightArm)
	b1.Part0 = Torso
	b1.Part1 = RightArm
	b1.C0 = RSC0
	b1.C1 = RSC1 * CFrame.new(0,.25,0)
	
	b2=Instance.new("Motor6D",LeftArm)
	b2.Part0 = Torso
	b2.Part1 = LeftArm
	b2.C0 = LSC0
	b2.C1 = LSC1 * CFrame.new(0,.25,0)
	
	pos=Torso.Position
	brot=Instance.new("BodyAngularVelocity",Torso)
	brot.P=2250
	brot.maxTorque=Vector3.new(8000000,8000000,8000000)
	bpos=Instance.new("BodyPosition",Torso)
	bpos.P=4250
	bpos.D=150
	bpos.maxForce=Vector3.new(8000000000,0,8000000000)
	bpos.position=Torso.Position
	
	Torso.RotVelocity=Vector3.new()
	Torso.Velocity=Vector3.new()
	
	
	for i=1, 5 do
		for _,v in pairs(cPlayer:children()) do
			if v:IsA("BasePart") then
				v.Velocity=Vector3.new()
				v.RotVelocity=Vector3.new()
			end
		end
		wait(.05)
	end
	
	Torso.Neck.Parent=nil
	Torso.Anchored=false
	
	ex=0
	em = 0
	elo = 0
	
	local mus = Instance.new("Sound",Torso)
	mus.Volume = 1
	mus.SoundId="http://www.roblox.com/asset/?id=230597205"
	mus:Play()
	
	ded=false
	
	wait()
	
	li=Instance.new("PointLight",Torso)
	li.Range=25
	li.Brightness=5
	li.Shadows=true
	
	pos=Torso.CFrame
	
	while down do
		game:GetService("RunService").Heartbeat:wait()
		em = em+1
		elo = elo+1
		if em == 11 then
			brot.angularvelocity=Vector3.new(math.random(-26,26),math.random(-20,20)/6,math.random(-26,26)/2)
			bpos.position = (pos * CFrame.new(math.random(-20,20)/10,0,math.random(-20,20)/20)).p
			em = math.random(0,4)
			li.Color=Color3.new(math.random(100,255)/255,math.random(100,255)/255,math.random(100,255)/255)
		end
		
		b1.C0 = RSC0 * CFrame.new(math.cos(math.rad(elo*15))/20,.5,math.sin(math.rad(elo*15))/30) * CFrame.Angles(math.rad(ex/8)*elo - math.pi/3,math.cos(math.rad(elo*15))/100,math.sin(elo/8)*7)
		b2.C0 = LSC0 * CFrame.new(math.cos(math.rad(elo*15))/20,.5,math.sin(math.rad(elo*15))/30) * CFrame.Angles(math.rad(-ex/8)*elo - math.pi/3,math.sin(math.rad(elo*15))/100,-math.cos(elo/8)*7)
		
		ex = ex + math.random(-5,5)/5
		if ex > 50 then
			ex = 50
		elseif ex < 10 then
			ex = 20
		end
		
		if elo > 15 then
		
			if g1.Parent==nil or g2.Parent==nil or g3.Parent==nil or g4.Parent==nil or g5.Parent==nil or Humanoid.Health <= 0 then
				ded = true
				break
			end
			if g1.Part0==nil or g2.Part0==nil or g3.Part0==nil or g4.Part0==nil or g5.Part0==nil then
				ded = true
				break
			end
			if RightArm.Parent == nil or LeftArm.Parent == nil or LeftLeg.Parent==nil or RightLeg.Parent==nil then
				ded=true
				break
			end
		
		end
		
	end
	
	li:Remove()
	
	mus:Stop()
	
	if ded then
		Head.Anchored=false
		
		for _,v in pairs(cPlayer:children()) do
			if v:IsA("BasePart") then
				v:BreakJoints()
				v.CFrame = CFrame.new(Torso.Position + Vector3.new(math.random(-2,2),math.random(-1,2),math.random(-2,2))) * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
				v.Velocity=Vector3.new(0,0,0)
			end
		end
		
		e=Instance.new("Explosion",workspace)
		e.BlastRadius=10
		e.BlastPressure=0
		e.Position=Torso.Position
		e.Hit:connect(function(hit) if hit.Parent == cPlayer and hit.Name~="AnchorR" and hit.Name~="AnchorL" then if hit:FindFirstChild("Fire") == nil then Instance.new("Fire",hit) end hit:BreakJoints() hit.Velocity = (e.Position - hit.Position).unit * 80 hit.RotVelocity = hit.Velocity end end)
		
		s=Instance.new("Sound",Head)
		s.SoundId="http://www.roblox.com/asset/?id=230597277"
		s.Volume=1
		s:Play()
		
		s=Instance.new("Sound",p1)
		s.SoundId="http://www.roblox.com/asset/?id=221920821"
		s.Volume=1
		s.Pitch=1.25
		s:Play()
	end
	
	wait(.5)
	mus:Remove()
	
end

onEquip=function(mouse)
	mouse.Button1Down:connect(function() down=true startVictoly() end)
	mouse.Button1Up:connect(function() down=false stopVictoly() end)
end
script.Parent.Selected:connect(onEquip)



	end
	
		if string.sub(BAR.Text, 1, 9) == ("traprifle") then
------------------------
--Aiju Love Trap Rifle--
----------------------------------------------------------------
--By CKbackup (Sugarie Saffron)                               --
--YT: https://www.youtube.com/channel/UC8n9FFz7e6Zo13ob_5F9MJw--
--Discord: Sugarie Saffron#4705                               --
----------------------------------------------------------------
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


local pee = game.Players.LocalPlayer.Character["METALXLIGHTSEER77Accessory"]
local gold = game.Players.LocalPlayer.Character["METALXLIGHTSEER77Accessory"].Handle
gold.AccessoryWeld:Destroy()




local righthandlo = game.Players.LocalPlayer.Character["Right Arm"]


local attachment0 = Instance.new("Attachment")
attachment0.Parent = gold
 
local attachment1 = Instance.new("Attachment")
attachment1.Parent = righthandlo


local alignorientation = Instance.new("AlignOrientation")
alignorientation.Parent = righthandlo
alignorientation.Attachment0 = attachment0
alignorientation.Attachment1 = attachment1
alignorientation.RigidityEnabled = true


local AlignPosition = Instance.new("AlignPosition")
AlignPosition.Parent = righthandlo
AlignPosition.Attachment0 = attachment0
AlignPosition.Attachment1 = attachment1
AlignPosition.RigidityEnabled = true

attachment1.CFrame = CFrame.Angles(-2,4.6,-.9) 
  attachment0.CFrame = CFrame.new(1.2,0,-.3)
  
  

 -- local toolgoflingfling = Instance.new("BodyVelocity", gold)
--toolgoflingfling.MaxForce = Vector3.new(90000,90000,90000)
--toolgoflingfling.Velocity = Vector3.new(90000,90000,90000)
  plr = game.Players.LocalPlayer
dead = false
char = plr.Character
 
bullet = char["LongStraightHair"]
bhandle = bullet.Handle
bhandle.Mesh:Destroy()
wait()
bullet.Parent = workspace
 
mouse = plr:GetMouse()
head = char.Head
camera = workspace.CurrentCamera
lt = true
ltt = false
 
local function IsFirstPerson()
     return (head.CFrame.p - camera.CFrame.p).Magnitude < 1
end
 
     bbv = Instance.new("BodyVelocity",bhandle)
     
     mouse.Button1Down:Connect(function()
         if dead == false then
        lt = false
        ltt = true
      ltt = false
             bbav = Instance.new("BodyAngularVelocity",bhandle)
     bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
     bbav.P = 1000000000000000000000000000
     bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
        if game.Players:GetPlayerFromCharacter(mouse.Target.Parent) then
              repeat 
            game:GetService("RunService").RenderStepped:Wait()
            bhandle.Position = mouse.Target.Parent.HumanoidRootPart.CFrame.p
          print("haha no")
            wait(0.23)
           until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
        elseif game.Players:GetPlayerFromCharacter(mouse.Target.Parent.Parent) then
            repeat 
            game:GetService("RunService").RenderStepped:Wait()
            bhandle.Position = mouse.Target.Parent.Parent.HumanoidRootPart.CFrame.p
            wait(0.23)
            until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
 
            else
        repeat 
        game:GetService("RunService").RenderStepped:Wait()
        bhandle.Position = mouse.Hit.p
        wait(0.23)
        until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
        end
        wait()
        lt = true
         end
         end)
 
     char.Humanoid.Died:Connect(function()
         dead = true
     end)
     repeat 
         game:GetService("RunService").RenderStepped:Wait()
         if dead == false and bhandle.CanCollide == true then
         bhandle.CanCollide = false
         end
         if lt == true and dead == false then
         bhandle.CFrame = char.Head.CFrame + Vector3.new(0,-15,0)
         elseif ltt == true and dead == false then
        bhandle.CFrame = ghandle.CFrame * CFrame.new(-1.7,-2,0)
        bhandle.Rotation = char.HumanoidRootPart.Rotation
         end
    until char.Humanoid.Health == 0
 
function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end



--loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()

wait(10)


wait(1/60)
Effects = { }
local Player = game:service'Players'.localPlayer
loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()
playerss = workspace.non
local chara = workspace.non
local Humanoid = chara:FindFirstChildOfClass("Humanoid")
local Mouse = Player:GetMouse()
local LeftArm = chara["Left Arm"]
local RightArm = chara["Right Arm"]
local LeftLeg = chara["Left Leg"]
local RightLeg = chara["Right Leg"]
local Head = chara.Head
local Torso = chara.Torso
local Camera = workspace.CurrentCamera
local RootPart = chara.HumanoidRootPart
local RootJoint = RootPart.RootJoint
local attack = false
local Anim = 'Idle'
local attacktype = 1
local delays = false
local play = true
local targetted = nil
local Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude 
local velocity = RootPart.Velocity.y
local sine = 0
local change = 1
local doe = 0
local Create = LoadLibrary("RbxUtility").Create
local debby = game:GetService("Debris")
Humanoid.WalkSpeed = 16

Humanoid.Animator.Parent = nil
chara.Animate.Parent = nil

local newMotor = function(part0, part1, c0, c1)
local w = Create('Motor'){
Parent = part0,
Part0 = part0,
Part1 = part1,
C0 = c0,
C1 = c1,
}
return w
end

function clerp(a, b, t)
return a:lerp(b, t)
end

RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

local RW = newMotor(Torso, RightArm, CFrame.new(1.5, 0, 0), CFrame.new(0, 0, 0)) 
local LW = newMotor(Torso, LeftArm, CFrame.new(-1.5, 0, 0), CFrame.new(0, 0, 0))
local RH = newMotor(Torso, RightLeg, CFrame.new(.5, -2, 0), CFrame.new(0, 0, 0))
local LH = newMotor(Torso, LeftLeg, CFrame.new(-.5, -2, 0), CFrame.new(0, 0, 0))
RootJoint.C1 = CFrame.new(0, 0, 0)
RootJoint.C0 = CFrame.new(0, 0, 0)
Torso.Neck.C1 = CFrame.new(0, 0, 0)
Torso.Neck.C0 = CFrame.new(0, 1.5, 0)

local rarmc1 = RW.C1
local larmc1 = LW.C1
local rlegc1 = RH.C1
local llegc1 = LH.C1

local resetc1 = false

function PlayAnimationFromTable(table, speed, bool)
RootJoint.C0 = clerp(RootJoint.C0, table[1], speed) 
Torso.Neck.C0 = clerp(Torso.Neck.C0, table[2], speed) 
RW.C0 = clerp(RW.C0, table[3], speed) 
LW.C0 = clerp(LW.C0, table[4], speed) 
RH.C0 = clerp(RH.C0, table[5], speed) 
LH.C0 = clerp(LH.C0, table[6], speed) 
if bool == true then
if resetc1 == false then
resetc1 = true
RootJoint.C1 = RootJoint.C1
Torso.Neck.C1 = Torso.Neck.C1
RW.C1 = rarmc1
LW.C1 = larmc1
RH.C1 = rlegc1
LH.C1 = llegc1
end
end
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")
frame = 0.03333333333333
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
tf = tf + s
if tf >= frame then
if allowframeloss then
script.Heartbeat:Fire()
lastframe = tick()
else
for i = 1, math.floor(tf / frame) do
script.Heartbeat:Fire()
end
lastframe = tick()
end
if tossremainder then
tf = 0
else
tf = tf - frame * math.floor(tf / frame)
end
end
end)
function swait(num)
if num == 0 or num == nil then
ArtificialHB.Event:wait()
else
for i = 0, num do
ArtificialHB.Event:wait()
end
end
end

function RemoveOutlines(part)
part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end

function so(id,par,pit,vol)
local sou = Instance.new("Sound", par or workspace)
if par == chara then
sou.Parent = chara.Torso
end
sou.Volume = vol
sou.Pitch = pit or 1
sou.SoundId = "rbxassetid://" .. id
sou.PlayOnRemove = true
sou:Destroy()
end

--This is just for builds--
New = function(Object, Parent, Name, Data)
local Object = Instance.new(Object)
for Index, Value in pairs(Data or {}) do
Object[Index] = Value
end
Object.Parent = Parent
Object.Name = Name
return Object
end


function rayCast(Position, Direction, Range, Ignore)
return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore) 
end 

function FindNearestTorso(Position, Distance, SinglePlayer)
if SinglePlayer then
return (SinglePlayer.Head.CFrame.p - Position).magnitude < Distance
end
local List = {}
for i, v in pairs(workspace:GetDescendants()) do
if v:IsA("Model") then
if v:findFirstChild("Head") then
if v ~= chara then
if (v.Head.Position - Position).magnitude <= Distance then
table.insert(List, v)
end 
end 
end 
end 
end
return List
end

EffectModel = Create("Model"){
Parent = chara,
Name = "Effects",
}

--Effect Functions--
Effects = {

Block = function(cf,partsize,meshstart,meshadd,matr,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("BlockMesh",p)
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
if spin == true then
p.CFrame = p.CFrame * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
end
end
p:Destroy()
end)()
return p
end,

Sphere = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshType = "Sphere"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Cylinder = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("CylinderMesh",p)
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Wave = function(cf,meshstart,meshadd,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://20329976"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Ring = function(cf,meshstart,meshadd,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://3270017"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Meshed = function(cf,meshstart,meshadd,colour,meshid,textid,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = meshid
m.TextureId = textid
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Explode = function(cf,partsize,meshstart,meshadd,matr,colour,move,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf * CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshType = "Sphere"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.new(0,move,0)
end
p:Destroy()
end)()
return p
end,

}

function GetDudesTorso(c)
local torsy = (c:findFirstChild("Torso") or c:findFirstChild("UpperTorso"))
if torsy ~= nil then
return torsy
end
end

function BodyVel(part,faws)
local bodyvel = Instance.new("BodyVelocity",part)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = faws
debby:AddItem(bodyvel,.2)
end

function Dmg(dude)
if dude and dude ~= chara and dude.Name ~= "CKbackup" then
if dude:FindFirstChild("TURAPPU") then return end
local debounce = Instance.new("BoolValue",dude)
debounce.Name = "TURAPPU"
coroutine.wrap(function()
local torsy = GetDudesTorso(dude)
if torsy then
local b = Instance.new("Part",dude)
b.BrickColor = BrickColor.new("Pink")
b.Size = Vector3.new(.1,.1,.1)
b.CanCollide = false
b.Transparency = 1
b.Material = "Neon"
b:BreakJoints()
so(113952851,b,1,3)
local bw = Instance.new("Weld",b)
bw.Part0 = b
bw.Part1 = torsy
local bm = Instance.new("SpecialMesh",b)
bm.MeshType = "Sphere"
bm.Scale = Vector3.new()
for i=0,1,.05 do
swait()
b.Transparency = 1-i
bm.Scale = Vector3.new(65*i,65*i,65*i)
end
coroutine.wrap(function()
swait(20)
for i=0,1,.05 do
swait()
b.Transparency = i
bm.Scale = Vector3.new(65+100*i,65+100*i,65+100*i)
end
b:Destroy()
end)()
end
for i,v in pairs(dude:children()) do
if v:IsA("Clothing") or v:IsA("BodyColors") or v:IsA("Accoutrement") then v:Destroy() end
end
local hedcol = dude:FindFirstChild("Head").BrickColor
local bcols = Instance.new("BodyColors",dude)
bcols.Name = "NeoCols"
bcols.HeadColor = hedcol
bcols.LeftArmColor = hedcol
bcols.RightArmColor = hedcol
bcols.TorsoColor = hedcol
bcols.LeftLegColor = hedcol
bcols.RightLegColor = hedcol
local Heiru = nil
local hacho = math.random(1,6)
if hacho == 1 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999847, 3.29998803, -42.2000351, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.075000003, 0.0599999987, 0.0599999987),MeshId = "rbxassetid://506240548",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(-7.62939453e-06, -1.19999862, 0.200000763, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 2 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.5, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.5499878, 4.29998732, -42.1000366, -1, 0, 0, 0, 1, 0, 0, 0, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(1.04999995, 1.04999995, 1.04999995),MeshId = "rbxassetid://398987591",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),C1 = CFrame.new(0.0499954224, -0.199999332, 0.100002289, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 3 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.5, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4499893, 3.89998746, -42.1000366, -1, 0, 0, 0, 1, 0, 0, 0, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{MeshId = "rbxassetid://164382853",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),C1 = CFrame.new(-0.0500030518, -0.599999189, 0.100002289, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 4 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999771, 2.79998851, -43.3000183, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.109999999, 0.0799999982, 0.0850000009),MeshId = "rbxassetid://561963999",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(-1.52587891e-05, -1.69999814, 1.29998398, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 5 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999847, 3.69998765, -42.600029, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.0450000018, 0.0450000018, 0.0450000018),MeshId = "rbxassetid://487000462",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(-7.62939453e-06, -0.799998999, 0.599994659, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif hacho == 6 then
Heiru = New("Part",dude,"Heiru",{Size = Vector3.new(0.5, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.5499802, 3.29998803, -42.0000381, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local HairMesh = New("SpecialMesh",Heiru,"Mesh",{Scale = Vector3.new(0.0649999976, 0.0599999987, 0.0599999987),MeshId = "rbxassetid://437152207",MeshType = Enum.MeshType.FileMesh,})
local Werudo = New("ManualWeld",Heiru,"Weld",{Part0 = Heiru,Part1 = dude:FindFirstChild("Head"),C1 = CFrame.new(0.049987793, -1.19999862, 3.81469727e-06, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
end
local haircol = {"Pink","Baby blue","Magenta","Brown","Black","Really black","White","CGA brown","Cool yellow"}
Heiru.BrickColor = BrickColor.new(haircol[math.random(1,#haircol)])
local ercho = math.random(1,8)
if ercho == 1 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 4.59999943, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{Scale = Vector3.new(1.04999995, 1, 1.04999995),MeshId = "rbxassetid://10871984",TextureId = "rbxassetid://10871968",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.100012779, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 2 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 5.39999866, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{MeshId = "rbxassetid://1072759",TextureId = "rbxassetid://1072760",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.900012016, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 3 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.300000012, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.5499954, 5.29999876, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{Scale = Vector3.new(1.20000005, 1.20000005, 1.20000005),MeshId = "rbxassetid://1374148",TextureId = "rbxassetid://413143035",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0.0500030518, 0.800012112, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 4 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 5.29999876, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{Scale = Vector3.new(0.699999988, 0.5, 0.600000024),MeshId = "rbxassetid://361948302",TextureId = "rbxassetid://361948503",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.800012112, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
elseif ercho == 5 then
local EIRO = New("Part",dude,"EIRO",{FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(0.400000006, 0.400000006, 0.400000006),CFrame = CFrame.new(-78.4999924, 5.09999895, -42.0000229, -1, -1.50263801e-10, 0, 1.50264662e-10, 0.999993861, -1.78813892e-07, 0, 1.78812812e-07, -1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Mesh = New("SpecialMesh",EIRO,"Mesh",{MeshId = "rbxassetid://1095510",TextureId = "rbxassetid://1095511",MeshType = Enum.MeshType.FileMesh,})
local Weld = New("ManualWeld",EIRO,"Weld",{Part0 = EIRO,Part1 = dude:FindFirstChild("Head"),C0 = CFrame.new(0, 0, 0, -1, 1.50264662e-10, 0, -1.50263801e-10, 0.999993861, 1.78812812e-07, 0, -1.78813892e-07, -1),C1 = CFrame.new(0, 0.600012302, -1.14440918e-05, -1, 0, 0, 0, 1, 0, 0, 0, -1),})
end
local oucho = math.random(1,6)
local sh = Instance.new("Shirt",dude)
local pn = Instance.new("Pants",dude)
if oucho == 1 then
pn.PantsTemplate = "rbxassetid://56903591"
sh:Destroy()
elseif oucho == 2 then
sh.ShirtTemplate = "rbxassetid://242933637"
pn.PantsTemplate = "rbxassetid://745334066"
elseif oucho == 3 then
sh.ShirtTemplate = "rbxassetid://1238151974"
pn.PantsTemplate = "rbxassetid://1340645290"
elseif oucho == 4 then
sh.ShirtTemplate = "rbxassetid://583471131"
pn.PantsTemplate = "rbxassetid://460147365"
elseif oucho == 5 then
pn.PantsTemplate = "rbxassetid://45541243"
sh:Destroy()
elseif oucho == 6 then
pn.PantsTemplate = "rbxassetid://41162775"
sh:Destroy()
end
Instance.new("Decal",dude:FindFirstChild("Head")).Texture = "rbxassetid://985062039"
coroutine.wrap(function()
swait(40)
local naeeym2 = Instance.new("BillboardGui",dude)
naeeym2.Size = UDim2.new(0,100,0,40)
naeeym2.StudsOffset = Vector3.new(0,3,0)
naeeym2.Adornee = dude:FindFirstChild("Head")
naeeym2.Name = "TalkingBillBoard"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.BorderSizePixel = 0
tecks2.Text = "Trapped! In another sense.."
tecks2.Font = "Cartoon"
tecks2.TextSize = 24
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(1,.6,.7)
tecks2.TextStrokeColor3 = Color3.new(1,1,1)
tecks2.Size = UDim2.new(1,0,0.5,0)
swait(10)
for i = 0,1,.05 do
swait()
tecks2.Position = tecks2.Position - UDim2.new(0,0,.005,0)
tecks2.TextStrokeTransparency = i
tecks2.TextTransparency = i
end
naeeym2:Destroy()
end)()
end)()
end
end

function MagnitudeDmg(par,magni)
for _, c in pairs(workspace:GetDescendants()) do
local hum = c:FindFirstChildOfClass("Humanoid")
if hum ~= nil and c:FindFirstChild("IsTeamMateOfCK")==nil then
local head = GetDudesTorso(c)
if head ~= nil then
local targ = head.Position - par.Position
local mag = targ.magnitude
if magni >= mag and c ~= chara then
Dmg(c)
end
end
end
end
end

local mus = Instance.new("Sound",Head)
mus.Name = "mus"
mus.SoundId = "rbxassetid://1131624146"
mus.Looped = true
mus.Volume = 1
mus:Play()

zhold = false
function shoot()
attack = true
for i=0,1,.3 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(0.0823832005, 1.55974865, -0.0981806219, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
CFrame.new(1.02804303, 0.5, -0.52656126, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
CFrame.new(-1.28728318, 0.203263342, -0.756378591, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
CFrame.new(0.499997735, -1.99999893, -1.11758709e-06, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
CFrame.new(-0.500001431, -1.99999893, -9.983778e-07, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
}, .4, false)
end
Humanoid.WalkSpeed = 2
local ref = Instance.new("Part",chara)
ref.Size = Vector3.new(0,0,0)
ref.Anchored = true
ref.CanCollide = false
ref.Transparency = 1
repeat
so(1145251796,ShotPt,math.random(95,105)/100,3)
ref.CFrame = Mouse.Hit
MagnitudeDmg(ref,2)
--Effects.Block(ShotPt.CFrame,Vector3.new(1,1,1),Vector3.new(),Vector3.new(.2,.2,.2),"Neon","Pink",true,false,.1)
--Effects.Block(CFrame.new((ShotPt.Position + Mouse.Hit.p)/2,Mouse.Hit.p),Vector3.new(1,1,(ShotPt.Position - Mouse.Hit.p).magnitude),Vector3.new(.2,.2,1),Vector3.new(.1,.1,0),"Neon","Pink",false,false,.1)
--Effects.Block(Mouse.Hit,Vector3.new(1,1,1),Vector3.new(),Vector3.new(.2,.2,.2),"Neon","Pink",true,false,.1)
for i=0,1,.5 do
swait()
PlayAnimationFromTable({		
CFrame.new(2.25380063e-06, 0, 0.100001052, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(0.0823859125, 1.55974913, -0.0981838703, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
CFrame.new(1.25785875, 0.5, -0.333723217, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
CFrame.new(-1.05747044, 0.203263938, -0.563540041, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
CFrame.new(0.423390329, -1.99999893, -0.0642812699, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
CFrame.new(-0.57660532, -1.99999893, -0.0642794371, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
}, .4, false)
end
for i=0,1,.5 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, 0, 0, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
CFrame.new(0.0823832005, 1.55974865, -0.0981806219, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
CFrame.new(1.02804303, 0.5, -0.52656126, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
CFrame.new(-1.28728318, 0.203263342, -0.756378591, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
CFrame.new(0.499997735, -1.99999893, -1.11758709e-06, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
CFrame.new(-0.500001431, -1.99999893, -9.983778e-07, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782),
}, .4, false)
end
until zhold == false
ref:Destroy()
Humanoid.WalkSpeed = 16
attack = false
end

function doge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
local bodyvel = Instance.new("BodyVelocity",RootPart)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.413182259, -0.492409885, 1, 0, 0, 0, 0.173647001, 0.984807968, 0, -0.984807968, 0.173647001),
CFrame.new(0, 1.39017391, 0.409808099, 1, 0, 0, 0, 0.499998748, -0.866026163, 0, 0.866026163, 0.499998748),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(-0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -1.30470812, -0.622091293, 1, 0, 0, 0, -0.866025984, 0.499998987, 0, -0.499998987, -0.866025984),
CFrame.new(0, 1.47984993, -0.230206192, 1, 0, 0, 0, 0.939693034, 0.34201926, 0, -0.34201926, 0.939693034),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(-0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -2.22375727, 0.305265486, 1, 0, 0, 0, 0.500000238, -0.866025388, 0, 0.866025388, 0.500000238),
CFrame.new(0, 1.35128808, -0.383415997, 1, 0, 0, 0, 0.766043901, 0.642788529, 0, -0.64278847, 0.766043901),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999337, -0.599998593, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024),
CFrame.new(-0.500003815, -1.35979521, -0.923200667, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*50
end
bodyvel:Destroy()
Humanoid.WalkSpeed = 16
attack = false
end

function bdoge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
local bodyvel = Instance.new("BodyVelocity",RootPart)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,pep,pep)
bodyvel.Velocity = RootPart.CFrame.lookVector*-50
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -2.22375727, 0.305265486, 1, 0, 0, 0, 0.500000238, -0.866025388, 0, 0.866025388, 0.500000238),
CFrame.new(0, 1.35128808, -0.383415997, 1, 0, 0, 0, 0.766043901, 0.642788529, 0, -0.64278847, 0.766043901),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999337, -0.599998593, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024),
CFrame.new(-0.500003815, -1.35979521, -0.923200667, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*-50
end
for i=0,1,.2 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -1.30470812, -0.622091293, 1, 0, 0, 0, -0.866025984, 0.499998987, 0, -0.499998987, -0.866025984),
CFrame.new(0, 1.47984993, -0.230206192, 1, 0, 0, 0, 0.939693034, 0.34201926, 0, -0.34201926, 0.939693034),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
CFrame.new(-0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
}, .4, false)
bodyvel.Velocity = RootPart.CFrame.lookVector*-50
end
bodyvel:Destroy()
Humanoid.WalkSpeed = 16
attack = false
end

function adoge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
Effects.Wave(RootPart.CFrame*CFrame.Angles(math.rad(90),0,0),Vector3.new(),Vector3.new(1,.1,1),"White",math.random(-10,10),false,.1)
BodyVel(RootPart,RootPart.CFrame.lookVector*50)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.095761165, -0.251516223, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
CFrame.new(0, 1.43075883, 0.149916381, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.96527231, 0.196966231, 1, 0, 0, 0, 0.984807789, 0.173648685, 0, -0.173648715, 0.984807789),
CFrame.new(-0.5, -1.43618584, -0.205210268, 1, 0, 0, 0, 0.939692438, 0.342020929, 0, -0.342020959, 0.939692438),
}, .4, false)
end
Humanoid.WalkSpeed = 16
attack = false
end

function badoge()
attack = true
Humanoid.WalkSpeed = 0
so(536642316,Torso,1,1)
Effects.Wave(RootPart.CFrame*CFrame.Angles(math.rad(-90),0,0),Vector3.new(),Vector3.new(1,.1,1),"White",math.random(-10,10),false,.1)
BodyVel(RootPart,RootPart.CFrame.lookVector*-50)
for i=0,1,.1 do
swait()
PlayAnimationFromTable({		
CFrame.new(0, -0.210508779, 0.312937856, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
CFrame.new(0, 1.4075644, -0.288293391, 1, 0, 0, 0, 0.866025388, 0.500000238, 0, -0.500000238, 0.866025388),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.5, -1.9652698, 0.196958005, 1, 0, 0, 0, 0.984807789, 0.173648715, 0, -0.173648685, 0.984807789),
CFrame.new(-0.5, -1.43618536, -0.205215126, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676),
}, .4, false)
end
Humanoid.WalkSpeed = 16
attack = false
end

Mouse.Button1Down:connect(function()
if attack == false then
zhold = true
shoot()
end
end)

Mouse.Button1Up:connect(function()
zhold = false
end)

local sprintt = 0
Mouse.KeyDown:connect(function(k)
k = k:lower()
if k=='m' then
if mus.IsPlaying == true then
mus:Stop()
elseif mus.IsPaused == true then
mus:Play()
end
end
if attack == false then
if k == 'q' then
if Anim == "Fall" or Anim == "Jump" then
badoge()
else
bdoge()
end
elseif k == 'e' then
if Anim == "Fall" or Anim == "Jump" then
adoge()
else
doge()
end
end
end
end)

Mouse.KeyUp:connect(function(k)
k = k:lower()
if k == 'z' then
zhold = false
end
end)

coroutine.wrap(function()
while 1 do
swait()
if doe <= 360 then
doe = doe + 2
else
doe = 0
end
end
end)()
while true do
swait()
while true do
swait()
if Head:FindFirstChild("mus")==nil then
mus = Instance.new("Sound",Head)
mus.Name = "mus"
mus.SoundId = "rbxassetid://1131624146"
mus.Looped = true
mus.Volume = 1
mus:Play()
end
if sprintt >= 1 then
sprintt = sprintt - 1
end
Torsovelocity = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
velocity = RootPart.Velocity.y
sine = sine + change
local hit, pos = rayCast(RootPart.Position, (CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0))).lookVector, 4, chara)
if RootPart.Velocity.y > 1 and hit == nil then 
Anim = "Jump"
if attack == false then
PlayAnimationFromTable({
CFrame.new(0, 0.0382082276, -0.0403150208, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
CFrame.new(0, 1.46579528, 0.0939689279, 1, 0, 0, 0, 0.939692855, -0.342019796, 0, 0.342019796, 0.939692855),
CFrame.new(1.20945489, -0.213504896, 3.55388607e-07, 0.939692736, 0.342019916, 1.53461215e-07, -0.342019945, 0.939692736, 1.93715096e-07, -8.56816769e-08, -2.23517418e-07, 1.00000012),
CFrame.new(-1.20945573, -0.213503733, 5.0439985e-07, 0.939692736, -0.342019916, -1.53461215e-07, 0.342019945, 0.939692736, 1.93715096e-07, 8.56816769e-08, -2.23517418e-07, 1.00000012),
CFrame.new(0.5, -1.99739456, -0.0180913229, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
CFrame.new(-0.5, -1.30000103, -0.39999947, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676),
}, .3, false)
end
elseif RootPart.Velocity.y < -1 and hit == nil then 
Anim = "Fall"
if attack == false then
PlayAnimationFromTable({
CFrame.new(0, -0.0646628663, 0.0399149321, 1, 0, 0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849),
CFrame.new(0, 1.4913609, -0.128171027, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
CFrame.new(1.55285025, 0.466259956, -9.26282269e-08, 0.766043842, -0.642788351, -6.46188241e-08, 0.642788291, 0.766043961, -7.4505806e-08, 1.04308128e-07, 1.49011612e-08, 1.00000012),
CFrame.new(-1.5605253, 0.475036323, -2.10609159e-07, 0.766043842, 0.642788351, 6.46188241e-08, -0.642788291, 0.766043961, -7.4505806e-08, -1.04308128e-07, 1.49011612e-08, 1.00000012),
CFrame.new(0.500000954, -1.9973948, -0.0180922765, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
CFrame.new(-0.499999046, -1.30000043, -0.400000483, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
}, .3, false)
end
elseif Torsovelocity < 1 and hit ~= nil then
Anim = "Idle"
if attack == false then
change = 1
PlayAnimationFromTable({
CFrame.new(-0.0769465268, -7.7815578e-08, -0.031559173, 0.939695537, 1.01607293e-06, 0.342021346, 7.9855522e-07, 1.00000191, 5.12654879e-07, -0.342019558, 2.16066837e-07, 0.939692855) * CFrame.new(0,.05 * math.cos((sine)/10), 0),
CFrame.new(0.0615186803, 1.4999913, 0.0559706129, 0.939695537, 7.9855522e-07, -0.342019558, 1.01607293e-06, 1.00000191, 2.16066837e-07, 0.342021346, 5.12654879e-07, 0.939692855),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.500003159, -2.00000715, -1.98185444e-06, 0.939692736, 0, -0.342019916, 0, 1, 0, 0.342019886, 0, 0.939692736) * CFrame.new(0,-.05 * math.cos((sine)/10), 0),
CFrame.new(-0.500018835, -2.0000062, 2.08616257e-07, 0.939692438, 0, 0.342020929, 0, 1, 0, -0.342020959, 0, 0.939692438) * CFrame.new(0,-.05 * math.cos((sine)/10), 0),
}, .3, false)
end
elseif Torsovelocity > 2 and hit ~= nil then
Anim = "Walk"
if attack == false then
Humanoid.WalkSpeed = 16
PlayAnimationFromTable({
CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0, 0- .08 * math.cos((sine) / 2.5), 0) * CFrame.Angles(0, 0, 0),
CFrame.new(0, 1.48263013, -0.0984808952, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
CFrame.new(0.540300786, -1.99793816, -9.82598067e-07, 0.998698533, -0.0510031395, 6.36324955e-07, 0.0510031395, 0.998698533, -1.00461093e-05, -8.35937328e-08, 1.08393433e-05, 1.00000024) * CFrame.new(0, 0, 0+ .5 * math.cos((sine) / 5)) * CFrame.Angles(math.rad(0 - 30 * math.cos((sine) / 5)), 0, 0), 
CFrame.new(-0.539563596, -1.99794078, 1.12228372e-06, 0.998635888, 0.0523072146, -1.77852357e-07, -0.0523072146, 0.998635888, -1.00715051e-05, -3.89727461e-07, 1.08406466e-05, 1.00000024) * CFrame.new(0, 0, 0- .5 * math.cos((sine) / 5)) * CFrame.Angles(math.rad(0 + 30 * math.cos((sine) / 5)), 0, 0), 
}, .3, false)
end
end
end
end
local basetpart = game.Players.Character:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
  sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end
		end
    
    	if string.sub(BAR.Text, 1, 4) == ("gale") then
	    

--cal hm  = sethiddenproperty(game.Players.CurbYismm.SimulationRadius            )
--int(hm)
---thiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)


function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end

loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()

print("cool")




--[[ Name : Gale Fighter ]]--
-------------------------------------------------------
--A Collaboration Between makhail07 and KillerDarkness0105

--Base Animaion by makhail07, attacks by KillerDarkness0105
-------------------------------------------------------


local FavIDs = {
	340106355, --Nefl Crystals
	927529620, --Dimension
	876981900, --Fantasy
	398987889, --Ordinary Days
	1117396305, --Oh wait, it's you.
	885996042, --Action Winter Journey
	919231299, --Sprawling Idiot Effigy
	743466274, --Good Day Sunshine
	727411183, --Knife Fight
	1402748531, --The Earth Is Counting On You!
	595230126 --Robot Language
	}



--The reality of my life isn't real but a Universe -makhail07
wait(0.2)
local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name)
print('yankee with no')
print('brim')
local char = workspace.non
local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")
hum.MaxHealth = 200
hum.Health = 200

-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
vt = Vector3.new
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 90
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------



-------------------------------------------------------
--Start Combo Function--
-------------------------------------------------------
local comboing = false
local combohits = 0
local combotime = 0
local maxtime = 65



function sandbox(var,func)
	local env = getfenv(func)
	local newenv = setmetatable({},{
		__index = function(self,k)
			if k=="script" then
				return var
			else
				return env[k]
			end
		end,
	})
	setfenv(func,newenv)
	return func
end
cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
comboframe = Instance.new("ScreenGui")
Frame1 = Instance.new("Frame")
Frame2 = Instance.new("Frame")
TextLabel3 = Instance.new("TextLabel")
comboframe.Name = "combinserter"
comboframe.Parent = mas
Frame1.Name = "combtimegui"
Frame1.Parent = comboframe
Frame1.Size = UDim2.new(0, 300, 0, 14)
Frame1.Position = UDim2.new(0, 900, 0.629999971, 0)
Frame1.BackgroundColor3 = Color3.new(0, 0, 0)
Frame1.BorderColor3 = Color3.new(0.0313726, 0.0470588, 0.0627451)
Frame1.BorderSizePixel = 5
Frame2.Name = "combtimeoverlay"
Frame2.Parent = Frame1
Frame2.Size = UDim2.new(0, 0, 0, 14)
Frame2.BackgroundColor3 = Color3.new(0, 1, 0)
Frame2.ZIndex = 2
TextLabel3.Parent = Frame2
TextLabel3.Transparency = 0
TextLabel3.Size = UDim2.new(0, 300, 0, 50)
TextLabel3.Text ="Hits:  "..combohits
TextLabel3.Position = UDim2.new(0, 0, -5.5999999, 0)
TextLabel3.BackgroundColor3 = Color3.new(1, 1, 1)
TextLabel3.BackgroundTransparency = 1
TextLabel3.Font = Enum.Font.Bodoni
TextLabel3.FontSize = Enum.FontSize.Size60
TextLabel3.TextColor3 = Color3.new(0, 1, 0)
TextLabel3.TextStrokeTransparency = 0
gui = game:GetService("Players").LocalPlayer.PlayerGui
for i,v in pairs(mas:GetChildren()) do
	v.Parent = game:GetService("Players").LocalPlayer.PlayerGui
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
	spawn(function()
		pcall(v)
	end)
end





coroutine.resume(coroutine.create(function()
	while true do
		wait()
		
		
		if combotime>65 then
		    combotime = 65
	    end
	    
	    
	    
	    
	    
		if combotime>.1 and comboing == true then
		    TextLabel3.Transparency = 0
		    TextLabel3.TextStrokeTransparency = 0
		    TextLabel3.BackgroundTransparency = 1
		    Frame1.Transparency = 0
		    Frame2.Transparency = 0
		       TextLabel3.Text ="Hits:  "..combohits
		    combotime = combotime - .34
Frame2.Size = Frame2.Size:lerp(UDim2.new(0, combotime/maxtime*300, 0, 14),0.42)
    end
    
    
    
    
	    if combotime<.1 then
	        		    TextLabel3.BackgroundTransparency = 1
	        		    TextLabel3.Transparency = 1
		    TextLabel3.TextStrokeTransparency = 1

Frame2.Size = UDim2.new(0, 0, 0, 14)
	        combotime = 0
	        comboing = false
	       		    Frame1.Transparency = 1
		    Frame2.Transparency = 1
		   combohits = 0 
	        
	        end
end
end))



-------------------------------------------------------
--End Combo Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChildOfClass("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
         if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end

	if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil then
			if hit.Parent.DebounceHit.Value == true then
				return
			end
		end
         if insta == true then
         hit.Parent:FindFirstChild("Head"):BreakJoints()
         end
		local c = Create("ObjectValue"){
			Name = "creator",
			Value = game:service("Players").LocalPlayer,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
		if HitSound ~= nil and HitPitch ~= nil then
			CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			if block.className == "IntValue" then
				if block.Value > 0 then
					blocked = true
					block.Value = block.Value - 1
					print(block.Value)
				end
			end
		end
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		else
			h.Health = h.Health - (Damage / 2)
			ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
		end
		if Type == "Knockdown" then
			local hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Create("BodyVelocity"){
				velocity = angle * knockback,
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			local rl = Create("BodyAngularVelocity"){
				P = 3000,
				maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
				angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodvol, .5)
			game:GetService("Debris"):AddItem(rl, .5)
		elseif Type == "Normal" then
			local vp = Create("BodyVelocity"){
				P = 500,
				maxForce = Vector3.new(math.huge, 0, math.huge),
				velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
			}
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, .5)
		elseif Type == "Up" then
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, .5)
		elseif Type == "DarkUp" then
			coroutine.resume(coroutine.create(function()
				for i = 0, 1, 0.1 do
					swait()
					Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
				end
			end))
			local bodyVelocity = Create("BodyVelocity"){
				velocity = Vector3.new(0, 20, 0),
				P = 5000,
				maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
				Parent = hit,
			}
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
		elseif Type == "Snare" then
			local bp = Create("BodyPosition"){
				P = 2000,
				D = 100,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Freeze" then
			local BodPos = Create("BodyPosition"){
				P = 50000,
				D = 1000,
				maxForce = Vector3.new(math.huge, math.huge, math.huge),
				position = hit.Parent.Torso.Position,
				Parent = hit.Parent.Torso,
			}
			local BodGy = Create("BodyGyro") {
				maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
				P = 20e+003,
				Parent = hit.Parent.Torso,
				cframe = hit.Parent.Torso.CFrame,
			}
			hit.Parent.Torso.Anchored = true
			coroutine.resume(coroutine.create(function(Part) 
				swait(1.5)
				Part.Anchored = false
			end), hit.Parent.Torso)
			game:GetService("Debris"):AddItem(BodPos, 3)
			game:GetService("Debris"):AddItem(BodGy, 3)
		end
		local debounce = Create("BoolValue"){
			Name = "DebounceHit",
			Parent = hit.Parent,
			Value = true,
		}
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Create("ObjectValue"){
			Name = "creator",
			Value = Player,
			Parent = h,
		}
		game:GetService("Debris"):AddItem(c, .5)
	end
end




	kDamagefunc=function(hit,minim,maxim,knockback,Type,Property,Delay,KnockbackType,decreaseblock)
        if hit.Parent==nil then
                return
        end
        h=hit.Parent:FindFirstChild("Humanoid")
        for _,v in pairs(hit.Parent:children()) do
        if v:IsA("Humanoid") then
        h=v
        end
        end
        if hit.Parent.Parent:FindFirstChild("Torso")~=nil then
        h=hit.Parent.Parent:FindFirstChild("Humanoid")
        end
        if hit.Parent.className=="Hat" then
        hit=hit.Parent.Parent:findFirstChild("Head")
        end
        if h~=nil and hit.Parent.Name~=char.Name and hit.Parent:FindFirstChild("Torso")~=nil then
        if hit.Parent:findFirstChild("DebounceHit")~=nil then if hit.Parent.DebounceHit.Value==true then return end end
        --[[                if game.Players:GetPlayerFromCharacter(hit.Parent)~=nil then
                        return
                end]]
--                        hs(hit,1.2) 
                        c=Instance.new("ObjectValue")
                        c.Name="creator"
                        c.Value=game:service("Players").LocalPlayer
                        c.Parent=h
                        game:GetService("Debris"):AddItem(c,.5)
                Damage=math.random(minim,maxim)
--                h:TakeDamage(Damage)
                blocked=false
                block=hit.Parent:findFirstChild("Block")
                if block~=nil then
                print(block.className)
                if block.className=="NumberValue" then
                if block.Value>0 then
                blocked=true
                if decreaseblock==nil then
                block.Value=block.Value-1
                end
                end
                end
                if block.className=="IntValue" then
                if block.Value>0 then
                blocked=true
                if decreaseblock~=nil then
                block.Value=block.Value-1
                end
                end
                end
                end
                if blocked==false then
--                h:TakeDamage(Damage)
                h.Health=h.Health-Damage
                kshowDamage(hit.Parent,Damage,.5,BrickColor.new("White"))
                else
                h.Health=h.Health-(Damage/2)
                kshowDamage(hit.Parent,Damage/2,.5,BrickColor.new("White"))
                end
                if Type=="Knockdown" then
                hum=hit.Parent.Humanoid
hum.PlatformStand=true
coroutine.resume(coroutine.create(function(HHumanoid)
swait(1)
HHumanoid.PlatformStand=false
end),hum)
                local angle=(hit.Position-(Property.Position+Vector3.new(0,0,0))).unit
--hit.CFrame=CFrame.new(hit.Position,Vector3.new(angle.x,hit.Position.y,angle.z))*CFrame.fromEulerAnglesXYZ(math.pi/4,0,0)
local bodvol=Instance.new("BodyVelocity")
bodvol.velocity=angle*knockback
bodvol.P=5000
bodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
bodvol.Parent=hit
rl=Instance.new("BodyAngularVelocity")
rl.P=3000
rl.maxTorque=Vector3.new(500,500,500)
rl.angularvelocity=Vector3.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))
rl.Parent=hit
game:GetService("Debris"):AddItem(bodvol,.5)
game:GetService("Debris"):AddItem(rl,.5)
                elseif Type=="Normal" then
                vp=Instance.new("BodyVelocity")
                vp.P=500
                vp.maxForce=Vector3.new(math.huge,0,math.huge)
--                vp.velocity=Character.Torso.CFrame.lookVector*Knockback
                if KnockbackType==1 then
                vp.velocity=Property.CFrame.lookVector*knockback+Property.Velocity/1.05
                elseif KnockbackType==2 then
                vp.velocity=Property.CFrame.lookVector*knockback
                end
                if knockback>0 then
                        vp.Parent=hit.Parent.Torso
                end
                game:GetService("Debris"):AddItem(vp,.5)
            elseif Type=="Up" then
                hit.Parent.Humanoid.PlatformStand = true
                local bodyVelocity=Instance.new("BodyVelocity")
                bodyVelocity.velocity=vt(0,15,0)
                bodyVelocity.P=5000
                bodyVelocity.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
                bodyVelocity.Parent=hit
                game:GetService("Debris"):AddItem(bodyVelocity,1)
                rl=Instance.new("BodyAngularVelocity")
                rl.P=3000
rl.AngularVelocity = Vector3.new(2000,2000,2000)
rl.MaxTorque = Vector3.new(40000,40000,40000)
                rl.Parent=hit
                hit.Parent.Humanoid.PlatformStand = false
                game:GetService("Debris"):AddItem(rl,.5)
                elseif Type=="Snare" then
                bp=Instance.new("BodyPosition")
                bp.P=2000
                bp.D=100
                bp.maxForce=Vector3.new(math.huge,math.huge,math.huge)
                bp.position=hit.Parent.Torso.Position
                bp.Parent=hit.Parent.Torso
                game:GetService("Debris"):AddItem(bp,1)
            elseif Type=="Float" then
                hit.Parent.Humanoid.PlatformStand = true
                                bp=Instance.new("BodyPosition")
                bp.P=2000
                bp.D=400
                bp.maxForce=Vector3.new(math.huge,math.huge,math.huge)
                bp.position=hit.Parent.Torso.Position+vt(0,35,24)
                                bp.Parent=hit.Parent.Torso
                	
local	rl=Instance.new("BodyAngularVelocity",hit.Parent.Torso)
rl.P=377705
rl.maxTorque=Vector3.new(1,1,1)*500
rl.angularvelocity=Vector3.new(math.random(-3,3),math.random(-6,6),math.random(-3,3))

 local BF = Instance.new("BodyForce",hit.Parent.Torso)
            BF.force = Vector3.new(0, workspace.Gravity/1.10, 0)
                game:GetService("Debris"):AddItem(bp,5)
game:GetService("Debris"):AddItem(BF,5)
game:GetService("Debris"):AddItem(rl,5)
                elseif Type=="Target" then
                if Targetting==false then
                ZTarget=hit.Parent.Torso
                coroutine.resume(coroutine.create(function(Part) 
                so("http://www.roblox.com/asset/?id=15666462",Part,1,1.5) 
                swait(5)
                so("http://www.roblox.com/asset/?id=15666462",Part,1,1.5) 
                end),ZTarget)
                TargHum=ZTarget.Parent:findFirstChild("Humanoid")
                targetgui=Instance.new("BillboardGui")
                targetgui.Parent=ZTarget
                targetgui.Size=UDim2.new(10,100,10,100)
                targ=Instance.new("ImageLabel")
                targ.Parent=targetgui
                targ.BackgroundTransparency=1
                targ.Image="rbxassetid://4834067"
                targ.Size=UDim2.new(1,0,1,0)
                cam.CameraType="Scriptable"
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)
                workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                Targetting=true
                RocketTarget=ZTarget
                for i=1,Property do
                --while Targetting==true and Humanoid.Health>0 and Character.Parent~=nil do
                if Humanoid.Health>0 and char.Parent~=nil and TargHum.Health>0 and TargHum.Parent~=nil and Targetting==true then
                swait()
                end
                --workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,Head.CFrame.p+rmdir*100)
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
                dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)
                cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)*cf(0,5,10)*euler(-0.3,0,0)
                end
                Targetting=false
                RocketTarget=nil
                targetgui.Parent=nil
                cam.CameraType="Custom"
                end
                end
                        debounce=Instance.new("BoolValue")
                        debounce.Name="DebounceHit"
                        debounce.Parent=hit.Parent
                        debounce.Value=true
                        game:GetService("Debris"):AddItem(debounce,Delay)
                        c=Instance.new("ObjectValue")
                        c.Name="creator"
                        c.Value=Player
                        c.Parent=h
                        game:GetService("Debris"):AddItem(c,.5)
                CRIT=false
                hitDeb=true
                AttackPos=6
                comboing = true
                combohits = combohits+1
                combotime = combotime+3.4


                
                if hitfloor == nil then
                    
    local velo=Instance.new("BodyVelocity")
                velo.velocity=vt(0,5.5,0)
                velo.P=8000
                velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                velo.Parent=root
                game:GetService("Debris"):AddItem(velo,0.06)
                
                                   local hitvelo=Instance.new("BodyVelocity")
                hitvelo.velocity=vt(0,5.5,0)
                hitvelo.P=8000
                hitvelo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                hitvelo.Parent=hit
                             game:GetService("Debris"):AddItem(hitvelo,0.06)
                             
                                                          coroutine.resume(coroutine.create(function()
                                 for i = 0,3.7,0.1 do
   swait()
         hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,0,-2.4)
        root.Velocity = root.CFrame.lookVector*0
        hit.Velocity = hit.CFrame.lookVector*130
end
end))
         coroutine.resume(coroutine.create(function()
             while ultra == true do
                 swait()
                 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,0,-2.4)
             end
             end))
                             
                
                end
                
                
        end
end
 
kshowDamage=function(Char,Dealt,du,Color)
        m=Instance.new("Model")
        m.Name=tostring(Dealt)
        h=Instance.new("Humanoid")
        h.Health=0
        h.MaxHealth=0
        h.Parent=m
        c=Instance.new("Part")
        c.Transparency=0
        c.BrickColor=Color
        c.Name="Head"
        c.Material = "Neon"
        c.TopSurface=0
        c.BottomSurface=0
        c.formFactor="Plate"
        c.Size=Vector3.new(1,.4,1)
        ms=Instance.new("CylinderMesh")
        ms.Scale=Vector3.new(.8,.8,.8)
        if CRIT==true then
                ms.Scale=Vector3.new(1,1.25,1)
        end
        ms.Parent=c
        c.Reflectance=0
        Instance.new("BodyGyro").Parent=c
        c.Parent=m
        if Char:findFirstChild("Head")~=nil then
        c.CFrame=CFrame.new(Char["Head"].CFrame.p+Vector3.new(0,1.5,0))
        elseif Char.Parent:findFirstChild("Head")~=nil then
        c.CFrame=CFrame.new(Char.Parent["Head"].CFrame.p+Vector3.new(0,1.5,0))
        end
        f=Instance.new("BodyPosition")
        f.P=2000
        f.D=220
        f.maxForce=Vector3.new(math.huge,math.huge,math.huge)
        f.position=c.Position+Vector3.new(0,3,0)
        f.Parent=c
        game:GetService("Debris"):AddItem(m,.5+du)
        c.CanCollide=false
        m.Parent=workspace
        c.CanCollide=false
    
end

-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end

function Eviscerate(dude)
	if dude.Name ~= char then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
			dude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
					end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
						v:Destroy()
					end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
						for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
								o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							v.Color = maincolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.08
								end
								wait(0.5)
								PartEmmit1.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end




--killer's effects





		function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end
	
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh){
		Parent = Part,
		Offset = OffSet,
		Scale = Scale,
	}
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
		
		
		
function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {
			prt,
			"Block1",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 2 then
		table.insert(Effects, {
			prt,
			"Block2",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
end

function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
local prt=CreatePart(workspace,"Neon",0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh,num) 
for i=0,1,delay do
swait()
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,(math.random(0,1)+math.random())/5)
end

function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end


function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function BreakEffect(brickcolor, cframe, x1, y1, z1)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	local num = math.random(10, 50) / 1000
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Shatter",
		num,
		prt.CFrame,
		math.random() - math.random(),
		0,
		math.random(50, 100) / 100
	})
end





						       so = function(id,par,vol,pit)
		coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound",par or workspace)
		sou.Volume=vol
		sou.Pitch=pit or 1
		sou.SoundId=id
		sou:play()
		game:GetService("Debris"):AddItem(sou,8)
		end))
		end


--end of killer's effects


function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 900817147 --900817147
local SONG2 = 0
local Music = Instance.new("Sound",tors)
Music.Volume = 0.7
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
local attacktype = 1
local attackdebounce = false
local euler = CFrame.fromEulerAnglesXYZ
local cankick = false
----------------------------------------------------------------------------------
hum.WalkSpeed = 8
hum.JumpPower = 57
--[[
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
]]
local ANIMATOR = hum.Animator
local ANIMATE = char.Animate
ANIMATE.Parent = nil
ANIMATOR.Parent = nil
-------------------------------------------------------
--End Customization--
-------------------------------------------------------


-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------

--pls be proud mak i did my best



function attackone()
    
    attack = true
    
          for i = 0, 1.35, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4-2*i), math.rad(4+2*i), math.rad(-40-11*i)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(40+11*i)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.6, 0.2) * angles(math.rad(90+4*i), math.rad(-43), math.rad(16+6*i)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-43)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, 0) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, -0.2) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
      end
      
      so("http://roblox.com/asset/?id=1340545854",ra,1,math.random(0.7,1))


con5=ra.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,3,4,math.random(2,3),"Normal",root,0,1)

so("http://roblox.com/asset/?id=636494529",ra,2,1)
 
 RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))


      wait(0.34)
attackdebounce = false

end
end
end)
                for i = 0, 1.12, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(6), math.rad(23)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(-23)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.6, -0.8) * angles(math.rad(110), math.rad(23), math.rad(2)), 0.4)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0.2) * angles(math.rad(-37), math.rad(0), math.rad(-13)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.3) * RHCF * angles(math.rad(-4), math.rad(0), math.rad(6)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0.05) * LHCF * angles(math.rad(-22), math.rad(0), math.rad(23)), 0.3)
      end
      
      con5:Disconnect()
          attack = false
          
      end












function attacktwo()
    
    attack = true
    
          for i = 0, 1.35, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(46)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(6)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
      end
      
      so("http://roblox.com/asset/?id=1340545854",la,1,math.random(0.7,1))


con5=la.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,3,4,math.random(2,3),"Normal",root,0,1)

so("http://roblox.com/asset/?id=636494529",la,2,1)
 
 RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))


      wait(0.34)
attackdebounce = false

end
end
end)




                for i = 0, 1.12, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(-6), math.rad(-27)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(27)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.16) * angles(math.rad(-33), math.rad(0), math.rad(23)), 0.4)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.67, -0.9) * angles(math.rad(116), math.rad(-28), math.rad(1)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0.05) * RHCF * angles(math.rad(-22), math.rad(0), math.rad(-18)), 0.3)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, -0.3) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(4)), 0.3)
      end
      
      con5:Disconnect()
attack = false
          
      end





function attackthree()
    
    attack = true
    
    
              for i = 0, 1.14, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-46)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(36)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-12), math.rad(0), math.rad(34)), 0.2)
      end
    
    con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,4,5,math.random(3,4),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",ll,2,1)
 
 RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))

    
          wait(0.34)
attackdebounce = false

end
end
end)

        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 9.14, 0.3 do
        swait()
        BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-54*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      attack = false
      con5:disconnect()
end



function attackfour()
    
    attack = true
            so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
     WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
              for i = 0, 5.14, 0.1 do
        swait()
        SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24+4*i), math.rad(0), math.rad(0)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0+11*i), math.rad(0), math.rad(0)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(36+4*i)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(-36-4*i)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28+4*i)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34-4*i)), 0.2)
      end
              so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
       local velo=Instance.new("BodyVelocity")
                velo.velocity=vt(0,25,0)
                velo.P=8000
                velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                velo.Parent=root
                game:GetService("Debris"):AddItem(velo,0.7)



con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.6,-1.8)
end
end))
--kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1)
 RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8)),0.44)
end
end))


      wait(0.14)
attackdebounce = false
end
end
end)

                    for i = 0, 5.11, 0.15 do
        swait()
        BlockEffect(BrickColor.new("White"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.2*i) * angles(math.rad(-10-80*i), math.rad(0), math.rad(0)), 0.42)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
      end


      attack = false
      con5:disconnect()
    end





local cooldown = false
function quickkick()
    attack = true
    
    
con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.3,-1.8)
end
end))

--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1)
 RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8)),0.44)
end
end))


      wait(0.08)
attackdebounce = false
end
end
end)

        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 11.14, 0.3 do
        swait()
        root.Velocity = root.CFrame.lookVector * 30
        BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-90*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      attack = false
      con5:disconnect()
end

    
    
    
    
    
    
    
function Taunt()
	attack = true
	hum.WalkSpeed = 0
	Cso("1535995570", hed, 8.45, 1)
	for i = 0, 8.2, 0.1 do
		swait()
		hum.WalkSpeed = 0
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25), Rad(0), Rad(16 * Cos(sine / 12))), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.1* Player_Size, 0.5 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(180), Rad(6), Rad(-56)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.1 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(45), Rad(6), Rad(86)), 0.1)
	end
	attack = false
	hum.WalkSpeed = 8
end
    
    





function Hyperkickcombo()
    
    attack = true
            so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
     WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
      for i = 0, 7.14, 0.1 do
        swait()
        SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(36)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-36)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
      end
local Cracking = Cso("292536356", tors, 10, 1)
 for i = 0, 7.14, 0.1 do
        swait()
		hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
		Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Lime green", 0, "Sphere")
		WaveEffect(BrickColor.new("Lime green"), root.CFrame * CFrame.new(0, -6, 0) * euler(0, math.random(-25, 25), 0), 1, 1, 1, 1, 0.2, 1, 0.05)
        SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
		SphereEffect(BrickColor.new("Lime green"),ll.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(30), math.rad(0), math.rad(0)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(36)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(-36)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
      end
      Cracking.Playing = false
      so("http://www.roblox.com/asset/?id=197161452", char, 3, 0.8)
              so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
              SphereEffect(BrickColor.new("Lime green"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
       local velo=Instance.new("BodyVelocity")
                velo.velocity=vt(0,27,0)
                velo.P=11000
                velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
                velo.Parent=root
                game:GetService("Debris"):AddItem(velo,1.24)



con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,3.4,-1.8)
end
end))
--kDamagefunc(hit,2,3,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.09)
attackdebounce = false
end
end
end)

                    for i = 0, 9.11, 0.2 do
        swait()
        BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.12*i) * angles(math.rad(-10-95*i), math.rad(0), math.rad(0)), 0.42)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
      end




      con5:disconnect()
      
      
      
      
      
      
      con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
                       
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.08)
attackdebounce = false
end
end
end)
      
      
      
        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 9.14, 0.3 do
        swait()
               root.Velocity = root.CFrame.lookVector * 20
        BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(53), math.rad(8), math.rad(0-54*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      
      
      
            con5:disconnect()
      
      
      
      con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)
      
      
              so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
          for i = 0, 15.14, 0.32 do
        swait()
        root.Velocity = root.CFrame.lookVector * 20
        BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-50*i), math.rad(8+20*i), math.rad(0-90*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-4*i)), 0.35)
      end
      
      attack = false
      con5:disconnect()
      
    end





local ultra = false

function Galekicks()
    
    attack = true
                so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
          for i = 0, 1.65, 0.1 do
        swait()
        root.Velocity = root.CFrame.lookVector * 0
        SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end


for i = 1, 17 do
    
          con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)
    
          for i = 0, .1, 0.2 do
        swait()
                BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
                root.Velocity = root.CFrame.lookVector * 10
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
      end

      so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))
      
          for i = 0, 0.4, 0.2 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end
      con5:disconnect()
end

          		    		    
        u =   mouse.KeyDown:connect(function(key)
          	if key == 'r' and combohits >= 150 then
		    ultra = true
		    SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,15,15,15,0.04)
		    end
          end)
          wait(0.3)
         if ultra == true then 
combohits = 0
wait(0.1)
 for i = 0, 1.65, 0.1 do
        swait()
        root.Velocity = root.CFrame.lookVector * 0
        SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end


so("http://roblox.com/asset/?id=146094803",hed,1,1.2)

for i = 1, 65 do
    --Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Really red", 0, "Brick")
          con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)

            
            
            
so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
 RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)
    
          for i = 0, .03, 0.1 do
        swait()
                BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
                root.Velocity = root.CFrame.lookVector * 10
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
      end

      so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))
      
          for i = 0, 0.07, 0.1 do
        swait()
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end
      con5:disconnect()
end

for i = 0, 1.65, 0.1 do
        swait()
        root.Velocity = root.CFrame.lookVector * 0
        SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end

con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  
coroutine.resume(coroutine.create(function()
    for i = 0,1.5,0.1 do
        swait()
 --hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
end
end))
--kDamagefunc(hit, 1, 3, 0,"Normal",root,0,1)
so("http://roblox.com/asset/?id=636494529",rl,2,.63)
 RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
end
end))


      wait(0.05)
attackdebounce = false
end
end
end)

              so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 1, 1.4)
          SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
   
  for i = 0, 2, 0.1 do
        swait()
		--BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
        RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0.2) * RHCF * angles(math.rad(-50), math.rad(0), math.rad(2)), 0.2)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
      end
        SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
        
        wait(0.25)
        con5:Disconnect() 
   

        
        
        con5=hum.Touched:connect(function(hit)
if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
if attackdebounce == false then
attackdebounce = true  

--kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
so("http://roblox.com/asset/?id=565207203",ll,7,0.63)
 
 RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
SpecialEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,5,18,5,0.04)
WaveEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,1.5,16,1.5,0.04)

coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))
    
          wait(0.06)
attackdebounce = false

end
end
end)

coroutine.resume(coroutine.create(function()
    while ultra == true do
        swait()
        root.CFrame = root.CFrame*CFrame.new(math.random(-3,3),math.random(-2,2),math.random(-3,3))
    end
    end))


        so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
        for i = 1,3 do
          for i = 0, 9.14, 0.45 do
        swait()
                root.Velocity = root.CFrame.lookVector * 30
        BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-94*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      end
    
    
    for i = 1,3 do
              for i = 0, 11.14, 0.45 do
        swait()
        root.Velocity = root.CFrame.lookVector * 30
        BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
        rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-110*i)), 0.35)
        tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
        LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
        RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(27), math.rad(0), math.rad(74)), 0.35)
        LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-34-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
      end
      
      
      
    end
     so("http://www.roblox.com/asset/?id=197161452", char, 0.5, 0.8)
    con5:disconnect()
     
     
  end -- combo hit end
            attack = false
          ultra = false
  u:disconnect()
          
      end




-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 2
        hum.WalkSpeed = 24.82
	end
end)
mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 1
        hum.WalkSpeed = 8
	end
end)

 





mouse.Button1Down:connect(function()
 if attack==false then
                if attacktype==1 then
                        attack=true
                        attacktype=2
                        attackone()
                elseif attacktype==2 then
                        attack=true
                        attacktype=3
                        attacktwo()
                elseif attacktype==3 then
                        attack=true
                        attacktype=4
                        attackthree()
                elseif attacktype==4 then
                        attack=true
                        attacktype=1
                        attackfour()
                end
        end
end)




		  mouse.KeyDown:connect(function(key)
		if key == 'e' and attack == false and cankick == true and cooldown == false then
quickkick()
cooldown = true

coroutine.resume(coroutine.create(function()
    wait(2)
cooldown = false
end))



		end
		end)








mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 't' then
			Taunt()
		elseif key == 'f' then
			Hyperkickcombo()
					elseif key == 'r' then
			Galekicks()
		end
	end
end)

-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
print("By Makhail07 and KillerDarkness0105")
print("Basic Animations by Makhail07")
print("Attack Animations by KillerDarkness0105")
print("This is pretty much our final script together")
print("--------------------------------")
print("Attacks")
print("E in air: Quick Kicks")
print("Left Mouse: 4 click combo")
print("F: Hyper Kicks")
print("R: Gale Kicks, Spam R if your combo is over 150 to do an ultra combo")
print("--------------------------------")
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	
	if hitfloor == nil then
	    cankick = true
    else
        cankick = false
        end
	
	
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(20)), 0.1)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-6.5 * Sin(sine / 12)), Rad(0), Rad(-20)), 0.1)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(110), Rad(6 + 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.3* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(110), Rad(6 - 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
			end
		elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-1), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-15 - 15 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 15 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(56)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-56)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
			end
		elseif torvel >= 22 and hitfloor ~= nil then
			Anim = "Sprint"
			change = 1.35
			if attack == false then
			    hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-8.5 - 2 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
			RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         	LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65) , Rad(0), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65)  , Rad(0) ,	Rad(-13) + la.RotVelocity.Y / 75), 0.15)
			end
		end
	end
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 0.7
	Music.Parent = tors
	Music:Resume()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end 
local basetpart = game.workspace.non:GetDescendants()
while true do wait(.1) --basepart in =
game.Players.LocalPlayer.ReplicationFocus = basetpart
end
basetpart:SetNetworkOwner(game.Players.LocalPlayer)
  while true do wait(.1)
   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
   end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
	    end
	    
	    	if string.sub(BAR.Text, 1, 5) == ("sonic") then
	    --[[KillerDarkness0105's/Codex's Sonic script]]--

 sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
       --sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1000)
       sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)

function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end

loadstring(game:GetObjects("rbxassetid://5572907584")[1].Source)()


wait(0.07)
Player=game:GetService("Players").LocalPlayer
Character=workspace.non
PlayerGui=Player.PlayerGui
Backpack=Player.Backpack
Torso=Character.Torso
Head=Character["Head"]
Humanoid=Character.Humanoid
LeftArm=Character["Left Arm"]
LeftLeg=Character["Left Leg"]
RightArm=Character["Right Arm"]
RightLeg=Character["Right Leg"]
LS=Torso["Left Shoulder"]
LH=Torso["Left Hip"]
RS=Torso["Right Shoulder"]
RH=Torso["Right Hip"]
Face = Head.face
Neck=Torso.Neck
it=Instance.new
attacktype=1
attacktype2=1
vt=Vector3.new
cf=CFrame.new
cn=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
combo = 0
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false
attackdebounce = false
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
stance = false
local ff = 2
noleg = false
evadecooldown = false
Humanoid.Animator.Parent = nil
equip = false
local Effects = {}
 attackspeed = 0.14 
 df = false
 Swing = 1
local sine = 0
local change = 1
local val = 0
local speed = 0
local rs = game:GetService("RunService").RenderStepped
cam = workspace.CurrentCamera
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create
deb = game:GetService("Debris")
Face.Transparency = 0
--Face.Texture = "rbxassetid://176217905" --176217905
Humanoid.WalkSpeed = 64
local freefall = 0

local boost = false
Humanoid.JumpPower = 88
local musicnum = 1
    
     local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
 local GravPoint = RootPart.Velocity.y
 local NV = Vector3.new(0,0,0)
print("Move list")
print("---------")
print("Shift = Boost")
print("Ctrl = Mach Speed Boost")
print("Q = Left QuickStep, E  = Right QuickStep")
print("C = Slide, in air to stomp")
print("Jump Then Hold B near a wall to wallrun")
print("M to change music, if you're standing still you'll do a special animation!")
print("Space near a wall to walljump, away from a wall homing attack")
		music = Instance.new("Sound",PlayerGui)
		music.Volume = 1
		music.TimePosition = 0
		music.Pitch = 1
		music.SoundId = "rbxassetid://1251555494"
		music.Looped = true
		music:Play()
		

		boostsound = Instance.new("Sound",PlayerGui)
		boostsound.Volume = .6
		boostsound.TimePosition = 0
		boostsound.Pitch = 1
		boostsound.SoundId = "rbxassetid://924922553"
		boostsound.Looped = false



		stompsound = Instance.new("Sound",PlayerGui)
		stompsound.Volume = 2
		stompsound.TimePosition = 0
		stompsound.Pitch = 1
		stompsound.SoundId = "rbxassetid://1295424184"
		stompsound.Looped = false



			       so = function(id,par,vol,pit)
		coroutine.resume(coroutine.create(function()
		local sou = Instance.new("Sound",par or workspace)
		sou.Volume=vol
		sou.Pitch=pit or 1
		sou.SoundId=id
		sou:play()
		game:GetService("Debris"):AddItem(sou,8)
		end))
		end
		
		--save shoulders
		RSH, LSH=nil, nil
		--welds
		RW, LW=Instance.new("Weld"), Instance.new("Weld")
		RW.Name="Right Shoulder" LW.Name="Left Shoulder"
		LH=Torso["Left Hip"]
		RH=Torso["Right Hip"]
		TorsoColor=Torso.BrickColor
		function NoOutline(Part)
		Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
		end
		player=Player
		ch=Character
		RSH=ch.Torso["Right Shoulder"]
		LSH=ch.Torso["Left Shoulder"]
		--
		RSH.Parent=nil
		LSH.Parent=nil
		--
		RW.Name="Right Shoulder"
		RW.Part0=ch.Torso
		RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5)
		RW.C1=cf(0, 0.5, 0)
		RW.Part1=ch["Right Arm"]
		RW.Parent=ch.Torso
		--
		LW.Name="Left Shoulder"
		LW.Part0=ch.Torso
		LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8)
		LW.C1=cf(0, 0.5, 0)
		LW.Part1=ch["Left Arm"]
		LW.Parent=ch.Torso
		 
		 
		newWeld = function(wp0, wp1, wc0x, wc0y, wc0z)
		    local wld = Instance.new("Weld", wp1)
		    wld.Part0 = wp0
		    wld.Part1 = wp1
		    wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
		end
		 local rs = game:GetService("RunService").RenderStepped
		 
		newWeld(RootPart, Torso, 0, -1, 0)
		Torso.Weld.C1 = CFrame.new(0, -1, 0)
		newWeld(Torso, LeftLeg, -0.5, -1, 0)
		LeftLeg.Weld.C1 = CFrame.new(0, 1, 0)
		newWeld(Torso, RightLeg, 0.5, -1, 0)
		RightLeg.Weld.C1 = CFrame.new(0, 1, 0)
		
		    Player=game:GetService('Players').LocalPlayer
		    Character=Player.Character
		    mouse=Player:GetMouse()
		    m=Instance.new('Model',Character)
		 
		 
		    local function weldBetween(a, b)
		        local weldd = Instance.new("ManualWeld")
		        weldd.Part0 = a
		        weldd.Part1 = b
		        weldd.C0 = CFrame.new()
		        weldd.C1 = b.CFrame:inverse() * a.CFrame
		        weldd.Parent = a
		        return weldd
		    end
		   
		    ArtificialHB = Instance.new("BindableEvent", script)
		ArtificialHB.Name = "Heartbeat"
		 
		script:WaitForChild("Heartbeat")
		 
		frame = 1 / 80
		tf = 0
		allowframeloss = false
		tossremainder = false
		lastframe = tick()
		script.Heartbeat:Fire()
		game:GetService("RunService").Heartbeat:connect(function(s, p)
		    tf = tf + s
		    if tf >= frame then
		        if allowframeloss then
		            script.Heartbeat:Fire()
		            lastframe = tick()
		        else
		            for i = 1, math.floor(tf / frame) do
		                script.Heartbeat:Fire()
		            end
		            lastframe = tick()
		        end
		        if tossremainder then
		            tf = 0
		        else
		            tf = tf - frame * math.floor(tf / frame)
		        end
		    end
		end)
		 
--[[]
		function swait(num)
		    if num == 0 or num == nil then
		        ArtificialHB.Event:wait()
		    else
		        for i = 0, num do
		            ArtificialHB.Event:wait()
		        end
		    end
	end

	]]
	



	function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait()
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait()
		end
	end
end

		function RemoveOutlines(part)
		    part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
		end
		   
		
		part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
		  local fp = it("Part")
		  fp.formFactor = formfactor
		  fp.Parent = parent
		  fp.Reflectance = reflectance
		  fp.Transparency = transparency
		  fp.CanCollide = false
		  fp.Locked = true
		  fp.BrickColor = brickcolor
		  fp.Name = name
		  fp.Size = size
		  fp.Position = Torso.Position
		  NoOutline(fp)
		  if fp.BrickColor == BrickColor.new("Dark indigo") then
		    fp.Material = "Neon"
		  else
		    if fp.BrickColor == BrickColor.new("Really black") then
		      fp.BrickColor = BrickColor.new("Really black")
		      fp.Material = "Metal"
		    else
		      fp.Material = "Neon"
		    end
		  end
		  fp:BreakJoints()
		  return fp
		end
		
		mesh = function(Mesh, part, meshtype, meshid, offset, scale)
		  local mesh = it(Mesh)
		  mesh.Parent = part
		  if Mesh == "SpecialMesh" then
		    mesh.MeshType = meshtype
		    mesh.MeshId = meshid
		  end
		  mesh.Offset = offset
		  mesh.Scale = scale
		  return mesh
		end
		
		weld = function(parent, part0, part1, c0)
		  local weld = it("Weld")
		  weld.Parent = parent
		  weld.Part0 = part0
		  weld.Part1 = part1
		  weld.C0 = c0
		  return weld
		end
		
		F1 = Instance.new("Folder", Character)
		F1.Name = "Effects Folder"
		F2 = Instance.new("Folder", F1)
		F2.Name = "Effects"
		Triangle = function(a, b, c)
		end
		
		MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CanCollide = false
		  prt.CFrame = cframe
		  prt.Name = "prt"
		  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Block1", delay, x3, y3, z3})
		end
		
		
		
		MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CanCollide = false
		  prt.CFrame = cframe
		  prt.Name = "prt"
		  local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3})
		end
		
		MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CFrame = cframe
		  local msh = mesh("SpecialMesh", prt, "FileMesh", "http://www.roblox.com/asset/?id=20329976", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3})
		end
		
		MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt(0.2, 0.2, 0.2))
		  prt.Anchored = true
		  prt.CFrame = cframe
		  msh = mesh("SpecialMesh", prt, "Head", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  Effects[#Effects + 1] = {prt, "Cylinder", delay, x3, y3, z3}
		end
		
		MagicCylinder2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt(0.2, 0.2, 0.2))
		  prt.Anchored = true
		  prt.CFrame = cframe
		  msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  Effects[#Effects + 1] = {prt, "Cylinder", delay, x3, y3, z3}
		end
		
		MagicBlood = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		  local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
		  prt.Anchored = true
		  prt.CFrame = cframe
		  local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
		  game:GetService("Debris"):AddItem(prt, 5)
		  table.insert(Effects, {prt, "Blood", delay, x3, y3, z3})
		end
		
		ElecEffect = function(cff, x, y, z)
		  local prt = part(3, F2, 0, 0, BrickColor.new("Dark indigo"), "Part", vt(1, 1, 1))
		  prt.Anchored = true
		  prt.CFrame = cff * cf(math.random(-x, x), math.random(-y, y), math.random(-z, z))
		  prt.CFrame = cf(prt.Position)
		  game:GetService("Debris"):AddItem(prt, 2)
		  xval = math.random() / 2
		  yval = math.random() / 2
		  zval = math.random() / 2
		  msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(xval, yval, zval))
		  Effects[#Effects + 1] = {prt, "Elec", 0.1, x, y, z, xval, yval, zval}
		end
		
		function FindNearestTorso(Position, Distance, SinglePlayer)
			if SinglePlayer then
				return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
			end
			local List = {}
			for i, v in pairs(workspace:GetChildren()) do
				if v:IsA("Model") then
					if v:findFirstChild("Torso") then
						if v ~= Character then
							if (v.Torso.Position - Position).magnitude <= Distance then
								table.insert(List, v)
							end 
						end 
					end 
				end 
			end
			return List
		end
		
		
		function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end
	
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh){
		Parent = Part,
		Offset = OffSet,
		Scale = Scale,
	}
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
		
		
		
function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	if Type == 1 or Type == nil then
		table.insert(Effects, {
			prt,
			"Block1",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	elseif Type == 2 then
		table.insert(Effects, {
			prt,
			"Block2",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
end

function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay,material)
local prt=CreatePart(workspace,material,0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh,num) 
for i=0,1,delay do
swait()
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,(math.random(0,1)+math.random())/5)
end

function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end


function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
	prt.Anchored = true
	prt.CFrame = cframe
	local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Cylinder",
		delay,
		x3,
		y3,
		z3,
		msh
	})
end

function BreakEffect(brickcolor, cframe, x1, y1, z1)
	local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
	prt.Anchored = true
	prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
	local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
	local num = math.random(10, 50) / 1000
	game:GetService("Debris"):AddItem(prt, 10)
	table.insert(Effects, {
		prt,
		"Shatter",
		num,
		prt.CFrame,
		math.random() - math.random(),
		0,
		math.random(50, 100) / 100
	})
end
		
		local lerp = function(a, b, t)
	return a * (1 - t) + b * t
end
		
		function clerp(a,b,t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1-t
		return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t))
		end
		 
		function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5/s
		return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5
		else
		local i = 0
		if m11 > m00 then
		i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
		i = 2
		end
		if i == 0 then
		local s = math.sqrt(m00-m11-m22+1)
		local recip = 0.5/s
		return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip
		elseif i == 1 then
		local s = math.sqrt(m11-m22-m00+1)
		local recip = 0.5/s
		return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip
		elseif i == 2 then
		local s = math.sqrt(m22-m00-m11+1)
		local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip
		end
		end
		end
		

		function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w*xs, w*ys, w*zs
		local xx = x*xs
		local xy = x*ys
		local xz = x*zs
		local yy = y*ys
		local yz = y*zs
		local zz = z*zs
		return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy))
		end
		function QuaternionSlerp(a, b, t)
		local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
		local theta = math.acos(cosTheta)
		local invSinTheta = 1/math.sin(theta)
		startInterp = math.sin((1-t)*theta)*invSinTheta
		finishInterp = math.sin(t*theta)*invSinTheta  
		else
		startInterp = 1-t
		finishInterp = t
		end
		else
		if (1+cosTheta) > 0.0001 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1/math.sin(theta)
		startInterp = math.sin((t-1)*theta)*invSinTheta
		finishInterp = math.sin(t*theta)*invSinTheta
		else
		startInterp = t-1
		finishInterp = t
		end
		end
		return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp
		end
		 
		function weld5(part0, part1, c0, c1)
		    weeld=Instance.new("Weld", part0)
		    weeld.Part0=part0
		    weeld.Part1=part1
		    weeld.C0=c0
		    weeld.C1=c1
		    return weeld
		end
		 
		--Example: Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
		 
		function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
		return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
	end
	
	
	



Character.Humanoid.MaxHealth = 120
Character.Humanoid.Health = 120
 
 local f = 0
 local b = Instance.new("BlurEffect",cam)
local    c = Instance.new('PointLight', Torso)
c.Range = 16
c.Color = Color3.new(0, 1,1)
c.Brightness = 1.5
 game:GetService("RunService"):BindToRenderStep("W0tT", 0, function()

b.Size = b.Size - 4
if boost == true then
c.Enabled = true
    cam.FieldOfView = lerp(cam.FieldOfView, 110, 0.5)
   -- cam.FieldOfView = 110
    freefall = 0
    Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,3),0.25)
 SphereEffect(BrickColor.new("Cyan"),RightLeg.CFrame*CFrame.new(0,-1,0)*angles(math.random(-180,180),math.random(-180,180),math.random(-180,180)),1.4,12,1.4,2.8,26,2.8,0.07)
  SphereEffect(BrickColor.new("Cyan"),LeftLeg.CFrame*CFrame.new(0,-1,0)*angles(math.random(-180,180),math.random(-180,180),math.random(-180,180)),1.4,12,1.4,2.8,26,2.8,0.07)
  if hitfloor ~= nil and Anim ~= "runIdle" then
  SpecialEffect(BrickColor.new("Cyan"),RootPart.CFrame*CFrame.new(0,-3.4,.78) ,2,2,2, 1.5,1.5,1.5,.09)
  end
end
if boost == false then
    cam.FieldOfView = lerp(cam.FieldOfView, 70, 0.076)
    --cam.FieldOfView = 70
    c.Enabled = false
end
end)



						 mouse.KeyDown:connect(function(key)
    if string.byte(key) == 48 then
        b.Size = 40
		Swing = 2
		freefall = 0
		
coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
end
end))
        Humanoid.WalkSpeed = 180
        RootPart.Velocity = RootPart.CFrame.lookVector*150
        RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-9.2) , 1, 1, 1, 8, 8, 8, 0.14,"Neon") 
        boost = true
        boostsound:Play()
end
end)

mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
		Swing = 1
        Humanoid.WalkSpeed = 64
        boost = false
        boostsound:Stop()

end
end)




						 mouse.KeyDown:connect(function(key)
    if string.byte(key) == 50 then
        b.Size = 40
        freefall = 0
		Swing = 2
		
coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.35*2.8,0.35*2.8),math.random(-0.35*2.8,0.35*2.8),math.random(-0.35*2.8,0.35*2.8)),0.48)
end
end))
		
        Humanoid.WalkSpeed = 320
        RootPart.Velocity = RootPart.CFrame.lookVector*550
        RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-9.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
        RingEffect(BrickColor.new("White"), RootPart.CFrame*CFrame.new(0,0,-11.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
        RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-13.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
        boost = true
        boostsound:Play()
end
end)

mouse.KeyUp:connect(function(key)
    if string.byte(key) == 50 then
		Swing = 1
        Humanoid.WalkSpeed = 64
        boost = false
        boostsound:Stop()

end
end)


local lastwall = nil
local jumped = false



		 
		 
		 
		 local vwall = false
		 
		 		 mouse.KeyDown:connect(function(key)
		     if key == 'b' and hitfloor == nil and attack == false then
	vrun()
end
 end)
 
 
 function vrun()
     		 	local ray = Ray.new(
		RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
	)
	local hit, position, normal = workspace:FindPartOnRay(ray, character)
	
	if hit then
	    if hit.Parent.Parent ~= Character and hit.Parent ~= Character and hit.Name ~= "prt" and hit.CanCollide == true then
	    vwall = true
	        local NV = Vector3.new(0,0,0)
	             local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
 local GravPoint = RootPart.Velocity.y
		local velo = Instance.new("BodyVelocity",Torso)
		velo.MaxForce = Vector3.new(400000,400000,400000)

		attack = true
while vwall == true and ray and hit do
swait()
change = 0.84+ Humanoid.WalkSpeed/132
if Humanoid.WalkSpeed > 40 and Humanoid.WalkSpeed < 70 then
velo.Velocity =  Vector3.new(0,40,0)
end
if Humanoid.WalkSpeed > 70 and Humanoid.WalkSpeed < 200 then
		velo.Velocity =  Vector3.new(0,80,0)
		end
		if Humanoid.WalkSpeed > 200 then
		velo.Velocity =  Vector3.new(0,130,0)
		end
		 ray = Ray.new(
		RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
	)
	hit, position, normal = workspace:FindPartOnRay(ray, character)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/2), .6) * angles(math.rad(96), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+20*math.sin(sine/2)),math.rad(0),math.rad(0+5*math.sin(sine/4)) + RootPart.RotVelocity.Y / 13),.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.1) * angles(math.rad(-90-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(15+2*math.sin(sine/4))- RootPart.RotVelocity.Y / 34),.15)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.1)*angles(math.rad(-90-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-15+2*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34),.15)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.28*math.cos(sine/4), 0-0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0+104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.3+ Humanoid.WalkSpeed/272)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.28*math.cos(sine/4),0+0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0-104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.3+ Humanoid.WalkSpeed/272)
end
		velo:Destroy()
		wait(0.07)

if vwall == false then

 RootPart.Velocity = -RootPart.CFrame.lookVector*68 + Vector3.new(0,86,0)

--[[]
		for i = 0,5,0.2 do
rs:wait()
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.79, 0) * CFrame.Angles(math.rad(0+100*i), math.rad(0), math.rad(0)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(0)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(180), math.rad(-60), math.rad(40)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(180), math.rad(60), math.rad(-40)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
end
]]


for i = 0,4,0.1 do
swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
end

 		attack = false


end


		if vwall == true then
 RootPart.Velocity = RootPart.CFrame.lookVector*38 + Vector3.new(0,86,0)

--[[]
		for i = 0,5,0.2 do
rs:wait()
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.79, 0) * CFrame.Angles(math.rad(0+100*i), math.rad(0), math.rad(0)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(0)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(180), math.rad(-60), math.rad(40)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(180), math.rad(60), math.rad(-40)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
end
]]


for i = 0,4,0.15 do
swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0-260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
end

 		attack = false

end


end
end
end
 
 

 
 	 mouse.KeyUp:connect(function(key)
		     if key == 'b' and vwall == true then
	         vwall = false
	         end
	         end)
		 


		 
		 
function Ldash()
    
    

evadecooldown = true
attack = true
k = math.random(1,2) 
if k == 1 then
so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
else
 so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
 end
 
 
 


 --+173.8*i
for i = 0,.7,0.1 do
swait()
Head.Velocity = Head.CFrame.rightVector * -135
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(32)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(-9),math.rad(-14)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.2) * angles(math.rad(27), math.rad(0), math.rad(30)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(30)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(12)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(8)), 0.2)
end

attack = false
wait(0.08)
evadecooldown = false
 
 
end





function Rdash()
    
    

evadecooldown = true
attack = true
k = math.random(1,2) 
if k == 1 then
so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
else
 so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
 end
 
 
 
 

 --+173.8*i
for i = 0,.7,0.1 do
swait()
Head.Velocity = Head.CFrame.rightVector * 135
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-32)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(9),math.rad(14)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(-30)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.2) * angles(math.rad(27), math.rad(0), math.rad(-30)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-8)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-12)), 0.2)
end

attack = false
wait(0.08)
evadecooldown = false
 
 
end
local sliding = false


function Slide()
    
     local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
     spd = spd + 30
local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
 local GravPoint = RootPart.Velocity.y
 if spd > 40 and hitfloor ~= nil then
noleg = true

attack = true
k = math.random(1,2) 
if k == 1 then
so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
else
 so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
 end
 
 
 

 
 
 

 
 
 local NV = Vector3.new(0,0,0)
local bv = Instance.new("BodyVelocity", Torso)
bv.maxForce = Vector3.new(1/0,1/0,1/0)
bv.velocity = dir*spd
	        local bg = Instance.new("BodyGyro", Torso)
bg.maxTorque = Vector3.new(1/0,1/0,1/0)
bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)
Head.Running.SoundId = "rbxassetid://1295468446"
Head.Running.TimePosition = 0

Humanoid.PlatformStand = true
while spd > 2 and hitfloor ~= nil and sliding == true do
swait()
spd = spd - 0.95
bv.velocity = dir*spd + Vector3.new(0,0,0)
bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -2.3, 0) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(12)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(34),math.rad(0),math.rad(12)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(110), math.rad(0), math.rad(70)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.2) * angles(math.rad(0), math.rad(0), math.rad(-60)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -0.56, -0.2) * CFrame.Angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
end
bv:Destroy()
bg:Destroy()
Head.Running.SoundId = "rbxassetid://758199523"
Head.Running.TimePosition = 0
Humanoid.PlatformStand = false
attack = false
sliding = false
wait(0.05)
evadecooldown = false
 
 
end
end

function land()
    attack = true
   RootPart.Velocity = Vector3.new(0,0,0)
    WaveEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,-1,0) , 1, 1, 1, 3, 0.8, 3, 0.06) 
     so("http://www.roblox.com/asset/?id=1295424585", Torso, 3.5, 1)

coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
        Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.55*2.8,0.55*2.8),math.random(-0.55*2.8,0.55*2.8),math.random(-0.55*2.8,0.55*2.8)),0.44)
        Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -2, 0) * CFrame.Angles(math.rad(-16), math.rad(0), math.rad(0)), 0.5)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(7),math.rad(0),math.rad(0)),.5)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(87)),.5)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0) * angles(math.rad(0), math.rad(0), math.rad(-87)),.5)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, 0, -0.5) * CFrame.Angles(math.rad(16), math.rad(0), math.rad(0)), 0.5)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1.14, 0.2) * CFrame.Angles(math.rad(-17), math.rad(0), math.rad(0)), 0.5)
       
end
attack = false


end))



end




function stomp()
    attack = true
    stompsound:Play()
    
   while hitfloor == nil do 
       swait()
       b.Size = 12
        WaveEffect(BrickColor.new("Cyan"), LeftLeg.CFrame*CFrame.new(0,-2.4,0) , 1, 1, 1, 0.8, 0.8, 0.8, 0.14) 
       RootPart.Velocity = Vector3.new(0,RootPart.Velocity.y/1.6,0) +Vector3.new(0,-150,0)
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(0+4*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(140+12*math.cos(sine/1.3))), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(-140+12*math.cos(sine/1.3))), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(60+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3), -0.13) * CFrame.Angles(math.rad(0+4*math.cos(sine/1.3)), math.rad(3), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, .27+0.17*math.cos(sine/1.3), -0.56) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(0), math.rad(0)), 0.1)

end
 stompsound:Stop()
land()


end


function changemusic()
    musicnum = musicnum + 1
    music.TimePosition = 0
    local osix = false
    local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude
    if musicnum > 14 then
        musicnum = 1
    end
    if musicnum == 1 then
        music.SoundId = "rbxassetid://179029173"
    end
    if musicnum == 2 then
        music.SoundId = "rbxassetid://146443855"
        end
        if musicnum == 3 then
           music.SoundId = "rbxassetid://1342408291" 
          end
          if musicnum == 4 then
            music.SoundId = "rbxassetid://201219416"  
        end
        if musicnum == 5 then
music.SoundId = "rbxassetid://1390472571" 
end
        if musicnum == 6 then
            osix = true
music.SoundId = "rbxassetid://249974783" 
end
if musicnum == 7 then
    music.SoundId = "rbxassetid://1851880603"
end
if musicnum == 8 then
 music.SoundId = "rbxassetid://412034984"
end
if musicnum == 9 then
   music.SoundId = "rbxassetid://536915629"
end
if musicnum == 10 then
music.SoundId = "rbxassetid://1200005861"
end
if musicnum == 11 then
    music.SoundId = "rbxassetid://1055930631"
end
if musicnum == 12 then
    music.SoundId = "rbxassetid://300269553"
end
if musicnum == 13 then
    music.SoundId = "rbxassetid://199897052"
end
if musicnum == 14 then
  music.SoundId = "rbxassetid://638115895"  
end

if spd < 14 then
Humanoid.Jump = true

if osix == false then
so("rbxassetid://537371462",PlayerGui,2,1)
end


RootPart.Velocity = Vector3.new(0,102,0)
attack = true
wait(0.08)
for i = 0,7,0.1 do
    swait()
    RootPart.Velocity = Vector3.new(0,2,0)
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0-260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)

end
b.Size = 40
MoonEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,0) , 1, 1, 1, 8, 8, 8, 0.06) 

if osix == true then
osix = false
so("rbxassetid://156821036",PlayerGui,2,1)
end

Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -3, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 1)
for i = 0,5,0.1 do
    swait()
RootPart.Velocity = Vector3.new(0,3.5,0)
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1+0.1*i, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.21)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(22-2*i),math.rad(0),math.rad(0)),.21)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.09*i, 0) * angles(math.rad(20-6*i), math.rad(0), math.rad(90+13*i)), 0.21)
LW.C0 = clerp(LW.C0, CFrame.new(-1.0-0.12*i, 0.5, -0.4+0.05*i) * angles(math.rad(20+13*i), math.rad(0), math.rad(20-13*i)), 0.21)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(-22-4*i)), 0.21)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(22+4*i)), 0.21)
end
attack = false
end
end


  mouse.KeyDown:connect(function(key)
if key == 'q' and attack == false and evadecooldown == false then
Ldash()
end
end)
 
 
 
   mouse.KeyDown:connect(function(key)
if key == 'e' and attack == false and evadecooldown == false then
Rdash()
end
end)

   mouse.KeyDown:connect(function(key)
if key == 'c' and attack == false and evadecooldown == false and hitfloor ~= nil then
     sliding = true
Slide()
end
end)

   mouse.KeyDown:connect(function(key)
if key == 'c' and attack == false and hitfloor == nil then
     stomp()
end
end)


local walljump = false


function walljumpp()
    	local ray = Ray.new(
		Torso.CFrame.p, RootPart.CFrame.lookVector *5
	)
	local hit, position, normal = workspace:FindPartOnRay(ray, character)
	
	if hit then
	    if  hit.Parent.Parent ~= Character and hit.Parent ~= Character then
	    local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
	    GravPoint = 0
 	    freefall = 0
	    walljump = true 
	    Humanoid.AutoRotate = false
		local velo = Instance.new("BodyVelocity",Torso)
		velo.MaxForce = Vector3.new(400000,400000,400000)
		--game.Debris:AddItem(velo,0.1)
		attack = true
while hitfloor == nil and walljump == true and ray and hit  do
swait()
freefall = 0
GravPoint = GravPoint - 0.36
		 ray = Ray.new(
		RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
	)
	hit, position, normal = workspace:FindPartOnRay(ray, character)
velo.Velocity = vt(0,GravPoint,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.9) * CFrame.Angles(math.rad(5), math.rad(90), math.rad(8)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(7),math.rad(0),math.rad(86)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(120)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-60)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-6), math.rad(14), math.rad(-12)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(23)), 0.2)
end
if walljump == false then
    k = math.random(1,3) 
if k == 1 then
so("http://www.roblox.com/asset/?id=800121776", Head, 2.5, 1)
else if k == 2 then
 so("http://www.roblox.com/asset/?id=804889329", Head, 2.5, 1)
else if k == 3 then
     so("http://www.roblox.com/asset/?id=804907617", Head, 2.5, 1)
     end
     end
end
 
    velo:Destroy()
        attack = false
    coroutine.resume(coroutine.create(function()
    for i = 0,1,0.1 do
        swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+260*i), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
end
end))
    
    Humanoid.AutoRotate = true
    RootPart.Velocity = RootPart.CFrame.lookVector * -137 + Vector3.new(0,136,0)
    wait(0.07)
     RootPart.CFrame = CFrame.new(RootPart.CFrame.p,-RootPart.CFrame.lookVector)
end
if walljump == true then
 		attack = false
walljump = false
Humanoid.AutoRotate = true
velo:Destroy()
end
end
end
end

    
    local homed = nil
    function home()
        if walljump ~= true then
        		    	for i, v in pairs(FindNearestTorso(Torso.CFrame.p, 80)) do
				if v:FindFirstChild('Head') then
					Grabbed = true
					homed = v
				end
			end
    
    if homed ~= nil and homed:FindFirstChildOfClass("Humanoid").Health > 1 and walljump == false then
        					    so("http://www.roblox.com/asset/?id=162460823", Head, 1, .8)
        					    	   local SBall = Instance.new("Part",Character)
	SBall.Name = "Homing Ball"
	SBall.CanCollide = false
	SBall.Anchored = false
	SBall.Transparency = 0.64
	SBall.CFrame = CFrame.new(RootPart.CFrame.p)
	SBall.BrickColor = BrickColor.new("Toothpaste")
	SBall.Size = Vector3.new(1,1,1)
	SBall.Material = "Neon"
	SBallweld = Instance.new("Weld")
SBallweld.Parent = SBall
SBallweld.Part0 = RootPart
SBallweld.Part1 = SBall
SBallweld.C1 = CFrame.new(0, 1, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
        SBallweld.Part0 = RootPart
	local SBallmesh = Instance.new("SpecialMesh",SBall)
	SBallmesh.MeshType = "Sphere"
	SBallmesh.Scale = Vector3.new(6,6,6)
        	trail = Instance.new("Trail", Character)
a2 = Instance.new("Attachment", Torso) a2.Position = Vector3.new(0,2,0)
a3 = Instance.new("Attachment", Torso)a3.Position = Vector3.new(0,-2.5,0)
trail.Texture = "rbxassetid://0"
trail.Attachment0 = a2
trail.Attachment1 = a3
trail.Lifetime  =  0.353
trail.MinLength = 0.03
trail.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,1)})
trail.Color = ColorSequence.new(Color3.new(0,1,1), Color3.new(0, 0,0))
trail.LightEmission = 4.8
trail.TextureLength = 0.034
        trail.Enabled = true
 attack = true
	local position = Instance.new("BodyPosition",Torso)
	position.P = 68350
	position.maxForce = Vector3.new(math.huge,math.huge,math.huge)
	
        while homed ~= nil and (homed.Torso.Position-RootPart.Position).magnitude > 8 do
        swait()
        SBall.CFrame = CFrame.new(RootPart.CFrame.p)
    Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+420*math.abs(sine/3.2)), math.rad(0), math.rad(0)), 0.6)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
    position.Position = homed.Torso.Position + Vector3.new(0,2,0) 
end
		local bodvol=Instance.new("BodyVelocity")
bodvol.velocity= RootPart.CFrame.lookVector*240 + Vector3.new(0,30,0)
bodvol.P= 35200
bodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
bodvol.Parent=homed.Head
game:GetService("Debris"):AddItem(bodvol, 0.2)
homed:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(10,30))

position:Destroy()
trail.Enabled = false
SBall:Destroy()
RootPart.Velocity = Vector3.new(0,93.5,0)
    coroutine.resume(coroutine.create(function()
for i = 0,5,0.26 do
    swait()
Humanoid.CameraOffset = Vector3.new(0,0,0)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1+0.1*i, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.21)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(22-2*i),math.rad(0),math.rad(0)),.21)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.09*i, 0) * angles(math.rad(20-6*i), math.rad(0), math.rad(90+13*i)), 0.21)
LW.C0 = clerp(LW.C0, CFrame.new(-1.0-0.12*i, 0.5, -0.4+0.05*i) * angles(math.rad(20+13*i), math.rad(0), math.rad(20-13*i)), 0.21)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(-22-4*i)), 0.21)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(22+4*i)), 0.21)
end
homed = nil
attack = false
end))

end
    
end


end











    










    
		 		 mouse.KeyDown:connect(function(key)
		 		     wait(0.16)
		     if string.byte(key) == 32 and hitfloor == nil and attack == false and walljump == false and Humanoid.Jump == true then
		 walljumpp()
	 end
	 		     if string.byte(key) == 32 and hitfloor == nil and attack == false and walljump == false and Humanoid.Jump == true then
		 home()
	 end
	 
if string.byte(key) == 32 and hitfloor == nil and attack == true and walljump == true then
walljump = false
end
	 end)
		 



   mouse.KeyDown:connect(function(key)
if key == 'm' and attack == false then
changemusic()
end
end)






   mouse.KeyUp:connect(function(key)
       wait(0.05)
if key == 'c' and sliding == true then
     sliding = false
end
end)
local look = 0



				while true do
    swait()
sine = sine + change
--speed = speed + music.PlaybackLoudness/90
local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
	
    local TiltVelocity = CFrame.new(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity))

local rlegray = Ray.new(RightLeg.Position+Vector3.new(0,0.54,0),Vector3.new(0, -1.75, 0))
local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, Character)

local llegray = Ray.new(LeftLeg.Position+Vector3.new(0,0.54,0),Vector3.new(0, -1.75, 0))
local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, Character)

    	local waterthing = Ray.new(RootPart.CFrame.p,Vector3.new(0,-1,0))
	local start, position = workspace:FindPartOnRay(waterthing, character)
	
	if start ~= nil and start.Material == "Water" then
	
    RootPart.Velocity = RootPart.Velocity + Vector3.new(0,6,0)
    
    end

if torvel<1  and Swing == 2 then
    boost = false
elseif torvel>1   and Swing == 2 then
    boost = true
    freefall = 0
end
if hitfloor ~= nil and freefall < 150 then
    freefall = 0
end
if freefall > 150 and hitfloor ~= nil then
land()
freefall = 0
end







		if RootPart.Velocity.y > 1 and hitfloor==nil then
Anim="Jump"





if attack==false then
change = 1
look = 0
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(4), math.rad(0), math.rad(0)), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10+2.05*math.cos(sine/5)),math.rad(0),math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20+2.05*math.cos(sine/5)), math.rad(-10), math.rad(50-2.05*math.cos(sine/5))), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20+2.05*math.cos(sine/5)), math.rad(-10), math.rad(-50+2.05*math.cos(sine/5))), 0.07)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, -0.6) * CFrame.Angles(math.rad(-25+3.05*math.cos(sine/5)), math.rad(-3), math.rad(0)), 0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.47, -0.7) * CFrame.Angles(math.rad(-12+3.05*math.cos(sine/5)), math.rad(0), math.rad(0)), 0.1)
end

elseif RootPart.Velocity.y < -1 and freefall <150 and hitfloor==nil then
Anim="Fall"
change = 1
freefall = freefall +0.77


if attack==false then
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(7+4*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(140+12*math.cos(sine/1.3))), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(-140+12*math.cos(sine/1.3))), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(40+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3), -0.13) * CFrame.Angles(math.rad(18+7*math.cos(sine/1.3)), math.rad(3), math.rad(0)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.37+0.17*math.cos(sine/1.3), -0.2) * CFrame.Angles(math.rad(32+7*math.cos(sine/1.3)), math.rad(0), math.rad(0)), 0.1)
end



elseif RootPart.Velocity.y < -1 and freefall > 150 and hitfloor==nil then
Anim="FreeFall"
change = 1


if attack==false then
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(-90+3*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(14+12*math.cos(sine/1.3)), math.rad(0), math.rad(110)), 0.07)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(14+12*math.cos(sine/1.3)), math.rad(0), math.rad(-110)), 0.07)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-12+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3),0.2) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(3), math.rad(-46)), 0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.17*math.cos(sine/1.3), 0.2) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(0), math.rad(46)), 0.1)
end

elseif torvel<1 and hitfloor~=nil then
Anim="Idle"
change = 1
if attack==false and equip == false then
  
			       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.04*math.cos(sine/40), -0) * CFrame.Angles(math.rad(0-0.81*math.cos(sine/40)), math.rad(-40), math.rad(0)), 0.1)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0+2.6*math.sin(sine/40)),math.rad(0),math.rad(40)),0.1)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.55+0.04*math.sin(sine/40), 0-0.04*math.cos(sine/40)) * angles(math.rad(-2+1.3*math.cos(sine/40)), math.rad(0+4*math.sin(sine/40)), math.rad(6.3+2.2*math.cos(sine/40))),0.1)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.55+0.04*math.sin(sine/40), 0-0.04*math.cos(sine/40)) * angles(math.rad(2+1.3*math.cos(sine/40)), math.rad(0-4*math.sin(sine/40)), math.rad(-6.3-2.2*math.cos(sine/40))),0.1)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, llegendPoint.Y-LeftLeg.Position.Y+0.04*math.cos(sine/40), 0) * CFrame.Angles(math.rad(0+0.81*math.cos(sine/40)), math.rad(18+0.81*math.cos(sine/40)), math.rad(-2-0.81*math.cos(sine/40))),0.1)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.57, rlegendPoint.Y-RightLeg.Position.Y+0.04*math.cos(sine/40), 0)  * CFrame.Angles(math.rad(0+0.81*math.cos(sine/40)), math.rad(-2+0.81*math.cos(sine/40)), math.rad(3-0.81*math.cos(sine/40))),0.1)
end


	
elseif torvel>1.5 and torvel<70 and hitfloor~=nil then
Anim="Walk"
change = 0.84+ Character.Humanoid.WalkSpeed/132
look = 0
if attack==false and equip == false then
					       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/2), -.8) * angles(math.rad(-26), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+20*math.sin(sine/2)),math.rad(0),math.rad(0+5*math.sin(sine/4)) + RootPart.RotVelocity.Y / 13),.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.1) * angles(math.rad(-60-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(15+2*math.sin(sine/4))- RootPart.RotVelocity.Y / 34),.15)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.1)*angles(math.rad(-60-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-15+2*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34),.15)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.28*math.cos(sine/4), 0-0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0+104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.3)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.28*math.cos(sine/4),0+0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0-104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.3)
end


		elseif torvel>=70 and torvel<200 and hitfloor~=nil then
		Anim="Run"
		change = 0.84+ Character.Humanoid.WalkSpeed/142
		if attack==false and equip == false then
					       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/1.5), -.8) * angles(math.rad(-37), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+25*math.sin(sine/1.5)),math.rad(0),math.rad(0+5*math.sin(sine/3)) + RootPart.RotVelocity.Y / 13),.1)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.3) * angles(math.rad(-72-8*math.sin(sine/1.5))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(1+0*math.cos(sine/3))- RootPart.RotVelocity.Y / 34),.25)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.3)*angles(math.rad(-72-8*math.sin(sine/1.5))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-1+0*math.cos(sine/3))+ RootPart.RotVelocity.Y / -34),.25)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.32*math.cos(sine/3), 0-0.42*math.cos(sine/3)) * CFrame.Angles(math.rad(0+134*math.sin(sine/3)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.44)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.32*math.cos(sine/3),0+0.42*math.cos(sine/3)) * CFrame.Angles(math.rad(0-134*math.sin(sine/3)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.44)
		end
		
		--[[
		if attack==false then
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1-0.4*math.cos(sine/5.5)/2, 0 *math.sin(sine/6.6)/2) * CFrame.Angles(math.rad(0) + -math.sin(sine/5.5)/1.2, math.rad(0), 0), .8)
		RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.4*math.cos(sine/5.5)/2,0 *-math.sin(sine/6.6)/2) * CFrame.Angles(math.rad(0) + math.sin(sine/5.5)/1.2, math.rad(0), 0), .8)
		end
		]]
		if attack==true and noleg == false then
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1-0.24*math.cos(sine/5), 0.+0.24*math.cos(sine/5)) * CFrame.Angles(math.rad(0-74*math.sin(sine/5)), math.rad(0), math.rad(0)), 0.3)
		   RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.24*math.cos(sine/5),0.-0.24*math.cos(sine/5)) * CFrame.Angles(math.rad(0+74*math.sin(sine/5)), math.rad(0), math.rad(0)), 0.3)
		end
		
		
		
				elseif torvel>=200 and hitfloor~=nil then
		Anim="MachRun"
		change = 0.84+ Character.Humanoid.WalkSpeed/182
		if attack==false and equip == false then
					       Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
		Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/1), -3.8) * angles(math.rad(-44), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .2)
		Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+25*math.sin(sine/1)),math.rad(0),math.rad(0+5*math.sin(sine/2)) + RootPart.RotVelocity.Y / 13),.2)
		RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.5) * angles(math.rad(-78-12*math.sin(sine/1))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(-24+0*math.cos(sine/2))- RootPart.RotVelocity.Y / 34),.35)
		LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.5)*angles(math.rad(-78-12*math.sin(sine/1))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(24+0*math.cos(sine/2))+ RootPart.RotVelocity.Y / -34),.35)
		LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.42*math.cos(sine/2), 0-0.62*math.cos(sine/2)) * CFrame.Angles(math.rad(0+134*math.sin(sine/2)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.52)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.42*math.cos(sine/2),0+0.62*math.cos(sine/2)) * CFrame.Angles(math.rad(0-134*math.sin(sine/2)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.52)
		end
		
		

end









 if 0 < #Effects then
      for e = 1, #Effects do
        if Effects[e] ~= nil then
          local Thing = Effects[e]
          if Thing ~= nil then
            local Part = Thing[1]
            local Mode = Thing[2]
            local Delay = Thing[3]
            local IncX = Thing[4]
            local IncY = Thing[5]
            local IncZ = Thing[6]
            if Thing[1].Transparency <= 1 then
              if Thing[2] == "Block1" then
                Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                Mesh = Thing[1]:FindFirstChild("Mesh")
                if not Mesh then
                  Mesh = Instance.new("BlockMesh")
                end
                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
              elseif Thing[2] == "Cylinder" then
                  Mesh = Thing[1]:FindFirstChild("Mesh")
                  if not Mesh then
                    Mesh = Instance.new("BlockMesh")
                  end
                  Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                  Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                elseif Thing[2] == "Blood" then
                    Mesh = Thing[1]:FindFirstChild("Mesh")
                    if not Mesh then
                      Mesh = Instance.new("BlockMesh")
                    end
                    Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
                    Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                    Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                  elseif Thing[2] == "Elec" then
                      Mesh = Thing[1]:FindFirstChild("Mesh")
                      if not Mesh then
                        Mesh = Instance.new("BlockMesh")
                      end
                      Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                      Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                    elseif Thing[2] == "Disappear" then
                        Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                      end
            else
              Part.Parent = nil
              game:GetService("Debris"):AddItem(Part, 0)
              table.remove(Effects, e)
            end
          end
        end
      end
    end

end
	    	end
    
    	if string.sub(BAR.Text, 1, 4) == ("exit") then
    	    
    	    sangiscool.Frame:TweenPosition(UDim2.new(-0.409, 0,0.288, 0), 'Out', 'Elastic', 1, true)
    	    wait(7)
	    game.CoreGui.sangiscool:Destroy()
	    
	    end
	    

--billie
	    	if string.sub(BAR.Text, 1, 6) == ("billie") then
	    
 
spawn(function()
    while wait() do
        settings().Physics.AllowSleep = false
         sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", math.huge)
    --   sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", math.huge)
        --   sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", math.huge)
    end
end)

function LoadLibrary(a)
    return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
end


loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
wait(1)

-- nebula's ezconvert
--[[
PUT YOUR SCRIPTS BELOW HERE VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV	
]]
local plr = game:GetService("Players").LocalPlayer
local char = workspace.non
if char:FindFirstChild("Animate") then
	char.Animate:Destroy()
end
local hum = char:FindFirstChildOfClass("Humanoid")
local tors = char.Torso
local head = char.Head
local rootpart = char.HumanoidRootPart
local RS = tors["Right Shoulder"]
local LS = tors["Left Shoulder"]
local RH = tors["Right Hip"]
local LH = tors["Left Hip"]
local neck = tors.Neck
local rootj = rootpart.RootJoint
local RSnor = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
local LSnor = CFrame.new(-1, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
local RHnor = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
local LHnor = CFrame.new(-1, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
local necknor = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local rootjnor = CFrame.new(0, 0, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local sine = 0
local music = Instance.new("Sound")
music.Parent = tors
local timepos = 0
local attack = false
local rooted = false
local playing = true
local speed = 16
local nokill = {
	"mrfunnylaughs4",
	"v_Sado"
}
local wig = Instance.new("Part")
wig.Size = Vector3.new(1.4, 1.99, 0.84)
wig.Parent = head
local mesh = Instance.new("SpecialMesh")
mesh.MeshType = Enum.MeshType.FileMesh
mesh.MeshId = "rbxassetid://952995462"
mesh.Scale = Vector3.new(1.44, 1.4, 1.22)
mesh.TextureId = "rbxassetid://949743130"
mesh.VertexColor = Vector3.new(1, 0.839, 0.73)
mesh.Parent = wig
local weld = Instance.new("Weld")
weld.Part0 = wig
weld.Part1 = head
weld.C1 = CFrame.new(0, -0.8, 0.25)
weld.Parent = wig
local rem = Instance.new("RemoteEvent")
rem.Name = "Events"
--[[
local Player = game:GetService("Players").LocalPlayer
    local Event = script:WaitForChild("UserInput_Event")
 
    local Mouse = Player:GetMouse()
    local UIS = game:GetService("UserInputService")
    local input = function(io,a)
        if a then return end
        --Since InputObject is a client-side instance, we create and pass table instead
        Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState,Hit=Mouse.Hit,Target=Mouse.Target})
    end
    UIS.InputBegan:Connect(input)
    UIS.InputEnded:Connect(input)
 
    local h,t
    --Give the server mouse data 30 times every second, but only if the values changed
    --If player is not moving their mouse, client won't fire events
    while wait(1/30) do
        if h~=Mouse.Hit or t~=Mouse.Target then
            h,t=Mouse.Hit,Mouse.Target
            Event:FireServer({isMouse=true,Target=t,Hit=h})
        end
    ]]--,plr.Character)	
rem.OnServerEvent:Connect(function(player, key)
	if player == plr then
		if attack == false then
			if key == "t" then
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://145757437"
				sound.Volume = 10
				sound.Parent = head
				local effect = Instance.new("PitchShiftSoundEffect")
				effect.Octave = 1.75
				effect.Parent = sound
				sound:Play()
				for i = 1, 120 do
					game:GetService("RunService").Stepped:Wait()
					head.Size = Vector3.new(2 + 1 * math.sin(sine / 5), 1 + 1 * math.sin(sine / 5), 1 + 1 * math.sin(sine / 5)) 
					neck.C0 = necknor * CFrame.new(0, 0, math.sin(sine / 5))
				end
				head.Size = Vector3.new(2, 1, 1)
			end
			if key == "r" then
				attack = true
				rooted = true
				playing = false
				local scream = Instance.new("Sound")
				scream.SoundId = "rbxassetid://176238381"
				scream.Parent = head
				scream:Play()
				repeat
					game:GetService("RunService").Stepped:Wait()
					RS.C0 = RSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					LS.C0 = LSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					RH.C0 = RHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					LH.C0 = LHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					rootj.C0 = rootjnor * CFrame.new(0, 0, 3 * math.sin(sine / 2)) * CFrame.Angles(sine / 2, 0, 0)
					neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
				until scream.Playing == false
				scream:Destroy()
				rooted = false
				if math.random(1, 3) == 1 then
					local sound = Instance.new("Sound")
					sound.SoundId = "rbxassetid://2878822762"
					sound.Volume = 10
					sound.PlaybackSpeed = 2
					sound.Parent = head
					sound:Play()
					repeat
						game:GetService("RunService").Stepped:Wait()
						head.Size = Vector3.new(2 + 1 * math.sin(sine / 2), 1 + 1 * math.sin(sine / 2), 1 + 1 * math.sin(sine / 2)) 
						RS.C0 = RSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						LS.C0 = LSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						RH.C0 = RHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						LH.C0 = LHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
						rootj.C0 = rootjnor
						neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
					until sound.Playing == false
					head.Size = Vector3.new(2, 1, 1)
				end
				playing = true
				attack = false
			end
			if key == "y" then
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://3475233802"
				sound.Volume = 10
				sound.Parent = head
				sound:Play()
				local thing = head.Touched:Connect(function(hit)
					local found = false
					for i,v in pairs(nokill) do
						if game:GetService("Players"):FindFirstChild(v) then
							if hit:IsDescendantOf(game:GetService("Players")[v].Character) then
								found = true
							end
						end
					end
					if found == false and hit.Size.Magnitude < 300 then
						local parent = hit.Parent
						hit.Parent = nil
						wait(math.random(20, 50) / 10)
						hit.Anchored = false
						hit.BrickColor = BrickColor.new("Bright green")
						hit.CFrame = head.CFrame
						hit.Velocity = head.CFrame.LookVector * 150
						hit.Parent = parent
						local sound = Instance.new("Sound")
						sound.SoundId = "rbxassetid://704088758"
						sound.Volume = 10
						sound.Parent = head
						sound:Play()
					end
				end)
				for i = 1, 180 do
					game:GetService("RunService").Stepped:Wait()
					head.Size = Vector3.new(20, 10, 10)
					neck.C0 = necknor * CFrame.new(0, -10, 0)
				end
				thing:Disconnect()
				head.Size = Vector3.new(2, 1, 1)
			end
			if key == "p" then
				attack = true
				playing = false
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://2533880583"
				sound.Volume = 3
				sound.TimePosition = 20.15
				sound.Parent = head
				sound:Play()
				wig.Parent = nil
				local hat = Instance.new("Part")
				hat.Name = "JevilHat"
				hat.CanCollide = false
				hat.Size = Vector3.new(1, 1, 1)
				hat.Parent = char
				local mesh = Instance.new("SpecialMesh")
				mesh.MeshType = Enum.MeshType.FileMesh
				mesh.MeshId = "rbxassetid://193760002"
				mesh.TextureId = "rbxassetid://193760041"
				mesh.VertexColor = Vector3.new(0.5, 0, 0.5)
				mesh.Parent = hat
				local weld = Instance.new("Weld")
				weld.Part0 = head
				weld.Part1 = hat
				weld.C0 = CFrame.new(0, 0.5, 0.31)
				weld.Parent = hat
				for i,v in pairs(head:GetChildren()) do
					if v:IsA("Decal") then
						local old = v.Texture
						v.Texture = "rbxassetid://241553801"
						coroutine.resume(coroutine.create(function()
							repeat game:GetService("RunService").Stepped:Wait() until sound.Playing == false or sound.TimePosition > 30.35
							v.Texture = old
						end))
					end
				end
				local anything = Instance.new("Sound")
				anything.SoundId = "rbxassetid://2544975373"
				anything.Volume = 10
				anything.Parent = head
				anything:Play()
				speed = 50
				repeat
					game:GetService("RunService").Stepped:Wait()
					RS.C0 = RSnor * CFrame.Angles(0, 0, math.pi / 2 - 1 * math.sin(sine / 3))
					LS.C0 = LSnor * CFrame.Angles(0, 0, -math.pi / 2 + 1 * math.sin(sine / 3))
					RH.C0 = RHnor
					LH.C0 = LHnor
					rootj.C0 = rootjnor
					neck.C0 = necknor
				until sound.Playing == false or sound.TimePosition > 30.35
				speed = 16
				hat:Destroy()
				wig.Parent = head
				sound:Destroy()
				playing = true
				attack = false
			end
			if key == "f" then
				attack = true
				playing = false
				speed = 150
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://2259766079"
				sound.Volume = 10
				sound.Parent = head
				sound:Play()
				local timepos = 0
				local thing = 1
				repeat
					game:GetService("RunService").Stepped:Wait()
					if sound.Parent ~= head then
						local sound = Instance.new("Sound")
						sound.TimePosition = timepos
						sound.Parent = head
					end
					sound.Volume = 10
					sound.PlaybackSpeed = 1
					sound.Playing = true
					timepos = sound.TimePosition
					RS.C0 = RSnor * CFrame.Angles(0, 0, math.pi / 2 - 1 * math.sin(sine / (15 / thing)))
					LS.C0 = LSnor * CFrame.Angles(0, 0, -math.pi / 2 + 1 * math.sin(sine / (15 / thing)))
					RH.C0 = RHnor
					LH.C0 = LHnor
					rootj.C0 = rootjnor
					neck.C0 = necknor
					thing = thing + 0.005
				until sound.Playing == false or sound.TimePosition > 10
				local old = head.BrickColor
				repeat
					game:GetService("RunService").Stepped:Wait()
					if sound.TimePosition > 20 then
						head.BrickColor = BrickColor.new("Sunrise")
					end
					sound.PlaybackSpeed = sound.PlaybackSpeed + 0.001
					head.Size = head.Size + Vector3.new(0.01, 0.01, 0.01)
					neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
				until sound.Playing == false
				for i = 1, 20 do
					local clone = head:Clone()
					clone.Parent = workspace
					clone.Velocity = Vector3.new(0, 200, 0)
					local sound = Instance.new("Sound")
					sound.SoundId = "rbxassetid://2878822762"
					sound.Volume = 0.5
					sound.Parent = head
					sound:Play()
				end
				head.Size = Vector3.new(2, 1, 1)
				head.BrickColor = old
				speed = 16
				playing = true
				attack = false
			end
			if key == "u" then
				local part = Instance.new("Part")
				part.CFrame = rootpart.CFrame * CFrame.new(0, 0, 5)
				part.Size = Vector3.new(3, 4, 3)
				part.Parent = workspace
				local click = Instance.new("ClickDetector")
				click.Parent = part
				local mesh = Instance.new("SpecialMesh")
				mesh.MeshType = Enum.MeshType.FileMesh
				mesh.MeshId = "rbxassetid://430897733"
				mesh.Scale = Vector3.new(4, 4, 4)
				mesh.TextureId = "rbxassetid://430897961"
				mesh.Parent = part
				local sound = Instance.new("Sound")
				sound.SoundId = "rbxassetid://741801027"
				sound.Volume = 3
				sound.Parent = part
				sound:Play()
				click.MouseClick:Connect(function()
					local banana = Instance.new("Part")
					banana.Size = Vector3.new(1, 1, 1)
					banana.CFrame = part.CFrame * CFrame.new(0, 5, 0)
					banana.Velocity = Vector3.new(math.random(-25, 25), 200, math.random(-25, 25))
					banana.Parent = workspace
					local mesh = Instance.new("SpecialMesh")
					mesh.MeshType = Enum.MeshType.FileMesh
					mesh.MeshId = "rbxassetid://28937301"
					mesh.TextureId = "rbxassetid://28937670"
					mesh.Scale = Vector3.new(0.8, 0.8, 0.8)
					mesh.Parent = banana
					local sound = Instance.new("Sound")
					sound.SoundId = "rbxassetid://28976727"
					sound.Volume = 2
					sound.Parent = banana
					sound:Play()
					local touched = false
					banana.Touched:Connect(function(hit)
						if hit.Parent and hit.Parent:FindFirstChild("Head") and not hit:IsDescendantOf(char) and touched == false then
							touched = true
							coroutine.resume(coroutine.create(function()
								for i = 1, 60 do
									game:GetService("RunService").Stepped:Wait()
									mesh.Scale = mesh.Scale + Vector3.new(0.3, 0.3, 0.3)
									banana.Size = banana.Size + Vector3.new(0.3, 0.3, 0.3)
								end
								banana:Destroy()
							end))
							local sound = Instance.new("Sound")
							sound.SoundId = "rbxassetid://168411776"
							sound.Volume = 10
							sound.Parent = hit.Parent.Head
							sound:Play()
						end
					end)
				end)
				repeat game:GetService("RunService").Stepped:Wait() until sound.Playing == false
				part:Destroy()
			end
		end
	end
end)
while game:GetService("RunService").Stepped:Wait() do
	sine = sine + 1
	if attack then 
		if rooted then
			hum.WalkSpeed = 0
			hum.JumpPower = 0
		else
			hum.WalkSpeed = speed
			hum.JumpPower = 50
		end
	else
		hum.WalkSpeed = 16
		hum.JumpPower = 50
	end
	for i,v in pairs(char:GetChildren()) do
		if v:IsA("Accessory") then
			v:Destroy()
		end
	end
	if music.Parent ~= tors then
		music = Instance.new("Sound")
		music.Parent = tors
		music.TimePosition = timepos
	else
		timepos = music.TimePosition
	end
	music.PlaybackSpeed = 0.84
	music.Volume = 1
	music.SoundId = "rbxassetid://3015811673"
	music.Playing = playing
	local torsvel = (tors.Velocity * Vector3.new(1, 0, 1)).Magnitude
	local hitfloor = workspace:FindPartOnRay(Ray.new(char.HumanoidRootPart.CFrame.Position, ((CFrame.new(char.HumanoidRootPart.Position, char.HumanoidRootPart.Position - Vector3.new(0, 1, 0))).LookVector).Unit * 4), char)
	if attack == false then
		if torsvel < 1 and hitfloor then
			RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(0, 0, math.pi / 2 + 0.3 * math.cos(sine / 7) + 0.5 * math.sin(sine / 14)), 0.15)
			LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(0, 0, 0.5 + 0.2 * math.sin(sine / 7) + 0.15 * math.cos(sine / 14)), 0.15)
			RH.C0 = RH.C0:Lerp(RHnor * CFrame.Angles(0, 0, -0.5 + 1 * math.sin(sine / 14) - 0.5 * math.cos(sine / 28)), 0.15)
			LH.C0 = LH.C0:Lerp(LHnor * CFrame.new(0.1 * math.sin(sine / 3.5) + 0.2 * math.cos(sine / 14), 0, 0) * CFrame.Angles(0, 0.2 * math.cos(sine / 28) - 0.3 * math.sin(sine / 48) + 0.15 * math.cos(sine / 3.5) - 0.25 * math.sin(sine / 3.5), -0.1 * math.sin(sine / 3.5) - 0.2 * math.cos(sine / 14)), 0.15)
			rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.new(0, 0, 0.3 * math.cos(sine / 4.5)), 0.15)
			neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(math.sin(sine / 10), math.cos(sine / 10), 0), 0.15)
		end
		if torsvel > 1 and hitfloor then
			RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(0, sine / 5, -1 * math.sin(sine / 7)), 0.15)
			LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(0, sine / 5, -1 * math.sin(sine / 7)), 0.15)
			RH.C0 = RH.C0:Lerp(RHnor * CFrame.new(1 * math.cos(sine / 7), 0.15 + 0.5 * math.cos(sine / 7), 0) * CFrame.Angles(0, 0.3 * math.sin(sine / 7), -0.23 + 1 * math.sin(sine / 7)), 0.15)
			LH.C0 = LH.C0:Lerp(LHnor * CFrame.new(1 * math.cos(sine / 7), 0.15 - 0.5 * math.cos(sine / 7), 0) * CFrame.Angles(0, 0.3 * math.sin(sine / 7), 0.23 + 1 * math.sin(sine / 7)), 0.15)
			rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.new(0, 0, -0.1 + 0.2 * math.cos(sine / 3.5)) * CFrame.Angles(0.2 - 0.4 * math.sin(sine / 3.5), rootpart.RotVelocity.Y / 50, -0.3 * math.sin(sine / 7)), 0.15)
			neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(0.4 * math.sin(sine / 3.5), 0, -head.RotVelocity.Y / 15 + 0.3 * math.sin(sine / 7)), 0.15)
		end
		if not hitfloor then
			RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(math.clamp(tors.Velocity.Y / 200 - 0.3, -hum.JumpPower / 200 - 0.3, hum.JumpPower / 200 - 0.3), 0, math.pi / 1.5), 0.15)
			LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(math.clamp(tors.Velocity.Y / 200 - 0.3, -hum.JumpPower / 200 - 0.3, hum.JumpPower / 200 - 0.3), 0, -math.pi / 1.5), 0.15)
			RH.C0 = RH.C0:Lerp(RHnor + Vector3.new(0, -0.6, 0.4), 0.15)
			LH.C0 = LH.C0:Lerp(LHnor * CFrame.Angles(0, 0, -0.3) + Vector3.new(0, -0.1, 0), 0.15)
			rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.Angles(-math.clamp(tors.Velocity.Y / 100, -hum.JumpPower / 100, hum.JumpPower / 100), 0, 0), 0.15)
			neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(math.random(-100, 100) / 1000, math.random(-100, 100) / 1000, math.random(-100, 100) / 1000), 0.15)
		end
	end
end

	    end
--billie end			end-- bar end
	--	CMDBAR.Text = ""

end
end)
end)


TextLabel_2.Parent = Dark
TextLabel_2.AnchorPoint = Vector2.new(0.5, 0.5)
TextLabel_2.BackgroundTransparency = 1.000
TextLabel_2.BorderSizePixel = 0
TextLabel_2.Position = UDim2.new(0.49751538, 0, 0.495130062, 0)
TextLabel_2.Size = UDim2.new(1.34710741, 0, 1.89285719, 0)
TextLabel_2.Font = Enum.Font.GothamSemibold
TextLabel_2.Text = "Execute"
TextLabel_2.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_2.TextSize = 16.000

TextLabel_3.Parent = WD
TextLabel_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_3.BackgroundTransparency = 1.000
TextLabel_3.Position = UDim2.new(0.093902424, 0, 0.300901115, 0)
TextLabel_3.Size = UDim2.new(0, 200, 0, 50)
TextLabel_3.Font = Enum.Font.GothamBold
TextLabel_3.Text = "Dark Mode"
TextLabel_3.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_3.TextSize = 20.000


local function RULWIG_fake_script() -- MainFrame.Draggify 
	local script = Instance.new('LocalScript', game.CoreGui.Selection.Frame)

	local UIS = game:GetService("UserInputService")
	function dragify(Frame)
		dragToggle = nil
		dragSpeed = 0.5
		dragInput = nil
		dragStart = nil
		dragPos = nil
		function updateInput(input)
			Delta = input.Position - dragStart
			Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
			game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.25), {Position = Position}):Play()
		end
		Frame.InputBegan:Connect(function(input)
			if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and UIS:GetFocusedTextBox() == nil then
				dragToggle = true
				dragStart = input.Position
				startPos = Frame.Position
				input.Changed:Connect(function()
					if input.UserInputState == Enum.UserInputState.End then
						dragToggle = false
					end
				end)
			end
		end)
		Frame.InputChanged:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
				dragInput = input
			end
		end)
		game:GetService("UserInputService").InputChanged:Connect(function(input)
			if input == dragInput and dragToggle then
				updateInput(input)
			end
		end)
	end
	dragify(script.Parent)
	
end
coroutine.wrap(RULWIG_fake_script)()